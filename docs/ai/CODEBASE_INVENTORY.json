{
  "project": "",
  "root_path": ".",
  "summary": {
    "total_files": 142,
    "total_lines": 18079,
    "total_classes": 121,
    "total_functions": 231
  },
  "packages": {
    "verify_consolidation.py": {
      "files": [
        {
          "file": "verify_consolidation.py",
          "path": "verify_consolidation.py",
          "module_docstring": "Verify the Conversation consolidation was successful.",
          "imports": [
            {
              "module": "sys",
              "alias": null
            },
            {
              "module": "pathlib",
              "from": true,
              "names": [
                "Path"
              ]
            },
            {
              "module": "claude_parser",
              "from": true,
              "names": [
                "load",
                "Conversation"
              ]
            },
            {
              "module": "claude_parser",
              "from": true,
              "names": [
                "UserMessage",
                "AssistantMessage"
              ]
            },
            {
              "module": "claude_parser",
              "from": true,
              "names": [
                "load"
              ]
            }
          ],
          "functions": [],
          "classes": [],
          "constants": [],
          "size": {
            "lines": 104,
            "bytes": 3265
          }
        }
      ],
      "summary": {
        "file_count": 1,
        "class_count": 0,
        "function_count": 0
      }
    },
    "tests": {
      "files": [
        {
          "file": "tests/test_parser.py",
          "path": "tests/test_parser.py",
          "module_docstring": "Tests for JSONL parser.",
          "imports": [
            {
              "module": "pytest",
              "alias": null
            },
            {
              "module": "pathlib",
              "from": true,
              "names": [
                "Path"
              ]
            },
            {
              "module": "orjson",
              "alias": null
            },
            {
              "module": "claude_parser.infrastructure.jsonl_parser",
              "from": true,
              "names": [
                "parse_jsonl",
                "parse_jsonl_streaming",
                "count_messages",
                "validate_jsonl"
              ]
            }
          ],
          "functions": [],
          "classes": [
            {
              "name": "TestParseJsonl",
              "bases": [],
              "docstring": "Test JSONL parsing.",
              "methods": [
                {
                  "name": "test_parse_valid_jsonl",
                  "signature": "(self, tmp_path)",
                  "docstring": "Test parsing valid JSONL file.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 14
                },
                {
                  "name": "test_parse_empty_file",
                  "signature": "(self, tmp_path)",
                  "docstring": "Test parsing empty file.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 25
                },
                {
                  "name": "test_parse_with_empty_lines",
                  "signature": "(self, tmp_path)",
                  "docstring": "Test parsing file with empty lines.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 33
                },
                {
                  "name": "test_parse_malformed_json",
                  "signature": "(self, tmp_path)",
                  "docstring": "Test parsing file with malformed JSON.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 41
                },
                {
                  "name": "test_file_not_found",
                  "signature": "(self)",
                  "docstring": "Test error when file doesn't exist.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 51
                },
                {
                  "name": "test_parse_unicode",
                  "signature": "(self, tmp_path)",
                  "docstring": "Test parsing file with unicode characters.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 56
                }
              ],
              "attributes": [],
              "properties": [],
              "class_variables": [],
              "line_number": 11
            },
            {
              "name": "TestParseJsonlStreaming",
              "bases": [],
              "docstring": "Test streaming JSONL parser.",
              "methods": [
                {
                  "name": "test_streaming_parse",
                  "signature": "(self, tmp_path)",
                  "docstring": "Test streaming parser.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 70
                },
                {
                  "name": "test_streaming_memory_efficient",
                  "signature": "(self, tmp_path)",
                  "docstring": "Test streaming doesn't load all into memory.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 80
                }
              ],
              "attributes": [],
              "properties": [],
              "class_variables": [],
              "line_number": 67
            },
            {
              "name": "TestCountMessages",
              "bases": [],
              "docstring": "Test message counting.",
              "methods": [
                {
                  "name": "test_count_messages",
                  "signature": "(self, tmp_path)",
                  "docstring": "Test counting messages.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 103
                }
              ],
              "attributes": [],
              "properties": [],
              "class_variables": [],
              "line_number": 100
            },
            {
              "name": "TestValidateJsonl",
              "bases": [],
              "docstring": "Test JSONL validation.",
              "methods": [
                {
                  "name": "test_validate_valid_file",
                  "signature": "(self, tmp_path)",
                  "docstring": "Test validating valid file.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 115
                },
                {
                  "name": "test_validate_invalid_file",
                  "signature": "(self, tmp_path)",
                  "docstring": "Test validating file with errors.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 124
                }
              ],
              "attributes": [],
              "properties": [],
              "class_variables": [],
              "line_number": 112
            }
          ],
          "constants": [],
          "size": {
            "lines": 131,
            "bytes": 4544
          }
        },
        {
          "file": "tests/test_watch_async.py",
          "path": "tests/test_watch_async.py",
          "module_docstring": "TDD Tests for async watch functionality.\n\nFollowing 95/5 principle - test with real scenarios.",
          "imports": [
            {
              "module": "pytest",
              "alias": null
            },
            {
              "module": "asyncio",
              "alias": null
            },
            {
              "module": "pathlib",
              "from": true,
              "names": [
                "Path"
              ]
            },
            {
              "module": "tempfile",
              "alias": null
            },
            {
              "module": "orjson",
              "alias": null
            },
            {
              "module": "claude_parser.watch",
              "from": true,
              "names": [
                "watch_async"
              ]
            },
            {
              "module": "claude_parser.models",
              "from": true,
              "names": [
                "MessageType"
              ]
            },
            {
              "module": "time",
              "alias": null
            }
          ],
          "functions": [],
          "classes": [
            {
              "name": "TestAsyncWatch",
              "bases": [],
              "docstring": "Test async watch following TDD principles.",
              "methods": [],
              "attributes": [],
              "properties": [],
              "class_variables": [],
              "line_number": 16
            },
            {
              "name": "TestAsyncWatchPerformance",
              "bases": [],
              "docstring": "Performance tests for async watch.",
              "methods": [],
              "attributes": [],
              "properties": [],
              "class_variables": [],
              "line_number": 205
            }
          ],
          "constants": [],
          "size": {
            "lines": 270,
            "bytes": 10301
          }
        },
        {
          "file": "tests/test_library_compatibility.py",
          "path": "tests/test_library_compatibility.py",
          "module_docstring": "Test that our library replacements are compatible.",
          "imports": [
            {
              "module": "json",
              "alias": null
            },
            {
              "module": "orjson",
              "alias": null
            },
            {
              "module": "pytest",
              "alias": null
            },
            {
              "module": "time",
              "alias": null
            }
          ],
          "functions": [],
          "classes": [
            {
              "name": "TestOrjsonCompatibility",
              "bases": [],
              "docstring": "Verify orjson works as a drop-in replacement for json.",
              "methods": [
                {
                  "name": "test_dumps_compatibility",
                  "signature": "(self)",
                  "docstring": "Test orjson.dumps works like json.dumps.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 11
                },
                {
                  "name": "test_loads_compatibility",
                  "signature": "(self)",
                  "docstring": "Test orjson.loads works like json.loads.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 31
                },
                {
                  "name": "test_orjson_is_faster",
                  "signature": "(self)",
                  "docstring": "Verify orjson is actually faster (why we use it).",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 41
                },
                {
                  "name": "test_usage_in_our_code",
                  "signature": "(self)",
                  "docstring": "Test the specific usage patterns in our codebase.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 62
                }
              ],
              "attributes": [],
              "properties": [],
              "class_variables": [],
              "line_number": 8
            }
          ],
          "constants": [],
          "size": {
            "lines": 78,
            "bytes": 2596
          }
        },
        {
          "file": "tests/test_navigation.py",
          "path": "tests/test_navigation.py",
          "module_docstring": "TDD tests for navigation features following 95/5 principle.",
          "imports": [
            {
              "module": "pytest",
              "alias": null
            },
            {
              "module": "pathlib",
              "from": true,
              "names": [
                "Path"
              ]
            },
            {
              "module": "claude_parser",
              "from": true,
              "names": [
                "load"
              ]
            },
            {
              "module": "claude_parser.discovery",
              "from": true,
              "names": [
                "find_current_transcript"
              ]
            },
            {
              "module": "claude_parser.domain.entities.conversation",
              "from": true,
              "names": [
                "Conversation"
              ]
            },
            {
              "module": "time",
              "alias": null
            }
          ],
          "functions": [],
          "classes": [
            {
              "name": "TestNavigationFeatures",
              "bases": [],
              "docstring": "Test navigation capabilities for conversation SDK.",
              "methods": [
                {
                  "name": "real_conversation",
                  "signature": "(self)",
                  "docstring": "Load real conversation for testing.",
                  "decorators": [
                    "pytest.fixture"
                  ],
                  "is_async": false,
                  "line_number": 15
                },
                {
                  "name": "test_get_surrounding_context",
                  "signature": "(self, real_conversation)",
                  "docstring": "Test getting messages around a specific message.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 24
                },
                {
                  "name": "test_get_messages_between_timestamps",
                  "signature": "(self, real_conversation)",
                  "docstring": "Test temporal navigation between timestamps.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 45
                },
                {
                  "name": "test_get_thread_navigation",
                  "signature": "(self, real_conversation)",
                  "docstring": "Test thread navigation using parentUuid.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 76
                },
                {
                  "name": "test_get_by_uuid",
                  "signature": "(self, real_conversation)",
                  "docstring": "Test direct UUID lookup - should be O(1).",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 92
                },
                {
                  "name": "test_filter_by_type",
                  "signature": "(self, real_conversation)",
                  "docstring": "Test filtering messages by type.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 107
                },
                {
                  "name": "test_get_session_boundaries",
                  "signature": "(self, real_conversation)",
                  "docstring": "Test finding session boundaries from sessionId changes.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 122
                }
              ],
              "attributes": [],
              "properties": [],
              "class_variables": [],
              "line_number": 11
            },
            {
              "name": "TestNavigationPerformance",
              "bases": [],
              "docstring": "Test performance requirements for navigation.",
              "methods": [
                {
                  "name": "test_uuid_lookup_is_fast",
                  "signature": "(self)",
                  "docstring": "UUID lookup should be O(1) via hashmap.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 143
                }
              ],
              "attributes": [],
              "properties": [],
              "class_variables": [],
              "line_number": 140
            }
          ],
          "constants": [],
          "size": {
            "lines": 167,
            "bytes": 6268
          }
        },
        {
          "file": "tests/test_application_service_bugs.py",
          "path": "tests/test_application_service_bugs.py",
          "module_docstring": "TDD tests to prove bugs found in conversation_service.py during code review.\n\nThese tests should FAIL initially, then pass after fixing the bugs.",
          "imports": [
            {
              "module": "pytest",
              "alias": null
            },
            {
              "module": "pathlib",
              "from": true,
              "names": [
                "Path"
              ]
            },
            {
              "module": "claude_parser.application.conversation_service",
              "from": true,
              "names": [
                "ConversationService",
                "load_large"
              ]
            },
            {
              "module": "claude_parser.application.conversation_service",
              "from": true,
              "names": [
                "load",
                "analyze"
              ]
            }
          ],
          "functions": [],
          "classes": [
            {
              "name": "TestConversationServiceBugs",
              "bases": [],
              "docstring": "Test bugs found during code review.",
              "methods": [
                {
                  "name": "test_get_repository_errors_attribute_bug",
                  "signature": "(self)",
                  "docstring": "BUG: get_repository_errors() references self._repository but constructor sets self.repository\nThis should fail with AttributeError before fix.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 15
                },
                {
                  "name": "test_load_large_missing_method_bug",
                  "signature": "(self)",
                  "docstring": "BUG: load_large() calls service.load_conversation_streaming() which doesn't exist\nThis should fail with AttributeError before fix.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 26
                },
                {
                  "name": "test_factory_function_service_creation_inefficiency",
                  "signature": "(self)",
                  "docstring": "DESIGN ISSUE: Factory functions create new service instances every time\nThis is inefficient - should reuse service instances.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 44
                }
              ],
              "attributes": [],
              "properties": [],
              "class_variables": [],
              "line_number": 12
            }
          ],
          "constants": [],
          "size": {
            "lines": 64,
            "bytes": 2371
          }
        },
        {
          "file": "tests/test_todo_display.py",
          "path": "tests/test_todo_display.py",
          "module_docstring": "Test TodoDisplay - Single Responsibility: Formatting.",
          "imports": [
            {
              "module": "pytest",
              "alias": null
            },
            {
              "module": "rich.tree",
              "from": true,
              "names": [
                "Tree"
              ]
            },
            {
              "module": "claude_parser.domain.todo.display",
              "from": true,
              "names": [
                "TodoDisplay"
              ]
            }
          ],
          "functions": [
            {
              "name": "test_build_tree_with_active",
              "signature": "()",
              "docstring": "Build tree with in-progress task.",
              "decorators": [],
              "is_async": false,
              "line_number": 7
            },
            {
              "name": "test_build_tree_no_active",
              "signature": "()",
              "docstring": "Build tree with no active task.",
              "decorators": [],
              "is_async": false,
              "line_number": 21
            },
            {
              "name": "test_build_tree_empty",
              "signature": "()",
              "docstring": "Handle empty todos.",
              "decorators": [],
              "is_async": false,
              "line_number": 33
            },
            {
              "name": "test_calculate_progress",
              "signature": "()",
              "docstring": "Calculate progress metrics.",
              "decorators": [],
              "is_async": false,
              "line_number": 39
            },
            {
              "name": "test_calculate_progress_empty",
              "signature": "()",
              "docstring": "Handle empty todos in progress.",
              "decorators": [],
              "is_async": false,
              "line_number": 53
            }
          ],
          "classes": [],
          "constants": [],
          "size": {
            "lines": 57,
            "bytes": 1686
          }
        },
        {
          "file": "tests/__init__.py",
          "path": "tests/__init__.py",
          "module_docstring": null,
          "imports": [],
          "functions": [],
          "classes": [],
          "constants": [],
          "size": {
            "lines": 1,
            "bytes": 29
          }
        },
        {
          "file": "tests/test_timeline.py",
          "path": "tests/test_timeline.py",
          "module_docstring": "Tests for Timeline domain - git-based JSONL navigation.",
          "imports": [
            {
              "module": "pytest",
              "alias": null
            },
            {
              "module": "pathlib",
              "from": true,
              "names": [
                "Path"
              ]
            },
            {
              "module": "jsonlines",
              "alias": null
            },
            {
              "module": "claude_parser.timeline",
              "from": true,
              "names": [
                "Timeline"
              ]
            }
          ],
          "functions": [
            {
              "name": "sample_jsonl_dir",
              "signature": "(tmp_path)",
              "docstring": "Create minimal JSONL for testing.",
              "decorators": [
                "pytest.fixture"
              ],
              "is_async": false,
              "line_number": 74
            },
            {
              "name": "jsonl_with_multiedit",
              "signature": "(tmp_path)",
              "docstring": "Create JSONL with MultiEdit operations.",
              "decorators": [
                "pytest.fixture"
              ],
              "is_async": false,
              "line_number": 102
            }
          ],
          "classes": [
            {
              "name": "TestTimeline",
              "bases": [],
              "docstring": "Test Timeline using GitPython and libraries.",
              "methods": [
                {
                  "name": "test_checkout_latest",
                  "signature": "(self, sample_jsonl_dir)",
                  "docstring": "Should checkout latest state.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 14
                },
                {
                  "name": "test_git_branches",
                  "signature": "(self, sample_jsonl_dir)",
                  "docstring": "Should create and list branches.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 24
                },
                {
                  "name": "test_query_commits",
                  "signature": "(self, sample_jsonl_dir)",
                  "docstring": "Should query commits with jmespath.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 34
                },
                {
                  "name": "test_diff_states",
                  "signature": "(self, sample_jsonl_dir)",
                  "docstring": "Should diff using deepdiff.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 48
                },
                {
                  "name": "test_handles_multiedit",
                  "signature": "(self, jsonl_with_multiedit)",
                  "docstring": "Should handle MultiEdit operations.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 62
                }
              ],
              "attributes": [],
              "properties": [],
              "class_variables": [],
              "line_number": 11
            }
          ],
          "constants": [],
          "size": {
            "lines": 128,
            "bytes": 3659
          }
        },
        {
          "file": "tests/test_todo_parser.py",
          "path": "tests/test_todo_parser.py",
          "module_docstring": "Test TodoParser - Single Responsibility: Parse JSON.",
          "imports": [
            {
              "module": "pytest",
              "alias": null
            },
            {
              "module": "orjson",
              "alias": null
            },
            {
              "module": "claude_parser.domain.todo.parser",
              "from": true,
              "names": [
                "TodoParser"
              ]
            }
          ],
          "functions": [
            {
              "name": "test_parse_array_format",
              "signature": "()",
              "docstring": "Parse direct array of todos.",
              "decorators": [],
              "is_async": false,
              "line_number": 7
            },
            {
              "name": "test_parse_object_format",
              "signature": "()",
              "docstring": "Parse object with todos field.",
              "decorators": [],
              "is_async": false,
              "line_number": 15
            },
            {
              "name": "test_parse_bytes",
              "signature": "()",
              "docstring": "Parse bytes input.",
              "decorators": [],
              "is_async": false,
              "line_number": 23
            },
            {
              "name": "test_parse_empty",
              "signature": "()",
              "docstring": "Parse empty todos.",
              "decorators": [],
              "is_async": false,
              "line_number": 30
            },
            {
              "name": "test_parse_invalid_json",
              "signature": "()",
              "docstring": "Handle invalid JSON gracefully.",
              "decorators": [],
              "is_async": false,
              "line_number": 36
            }
          ],
          "classes": [],
          "constants": [],
          "size": {
            "lines": 39,
            "bytes": 1123
          }
        },
        {
          "file": "tests/test_unused_modules.py",
          "path": "tests/test_unused_modules.py",
          "module_docstring": "Tests for unused modules to improve coverage.\n\nThese modules are not currently used but exist in the codebase.\nTesting them ensures they work if needed in the future.",
          "imports": [
            {
              "module": "pytest",
              "alias": null
            },
            {
              "module": "pathlib",
              "from": true,
              "names": [
                "Path"
              ]
            },
            {
              "module": "unittest.mock",
              "from": true,
              "names": [
                "MagicMock",
                "patch",
                "mock_open"
              ]
            },
            {
              "module": "orjson",
              "alias": null
            },
            {
              "module": "claude_parser.infrastructure.message_repository",
              "from": true,
              "names": [
                "JsonlMessageRepository"
              ]
            },
            {
              "module": "claude_parser.application.conversation_service",
              "from": true,
              "names": [
                "ConversationService"
              ]
            }
          ],
          "functions": [],
          "classes": [
            {
              "name": "TestInfrastructureMessageRepository",
              "bases": [],
              "docstring": "Test the infrastructure message repository.",
              "methods": [
                {
                  "name": "test_load_messages",
                  "signature": "(self, mock_loads, mock_file)",
                  "docstring": "Test loading messages from JSONL.",
                  "decorators": [
                    "patch('builtins.open', new_callable=mock_open, read_data=b'{\"type\": \"user\", \"content\": \"test\"}\\n')",
                    "patch('claude_parser.infrastructure.message_repository.orjson.loads')"
                  ],
                  "is_async": false,
                  "line_number": 21
                },
                {
                  "name": "test_load_messages_file_not_found",
                  "signature": "(self, mock_file)",
                  "docstring": "Test handling of missing file.",
                  "decorators": [
                    "patch('builtins.open', side_effect=FileNotFoundError)"
                  ],
                  "is_async": false,
                  "line_number": 32
                },
                {
                  "name": "test_load_messages_invalid_json",
                  "signature": "(self, mock_file)",
                  "docstring": "Test handling of invalid JSON.",
                  "decorators": [
                    "patch('builtins.open', new_callable=mock_open, read_data=b'invalid json\\n')"
                  ],
                  "is_async": false,
                  "line_number": 40
                },
                {
                  "name": "test_get_metadata",
                  "signature": "(self)",
                  "docstring": "Test metadata extraction.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 48
                }
              ],
              "attributes": [],
              "properties": [],
              "class_variables": [],
              "line_number": 16
            },
            {
              "name": "TestApplicationConversationService",
              "bases": [],
              "docstring": "Test the application conversation service.",
              "methods": [
                {
                  "name": "test_service_initialization",
                  "signature": "(self)",
                  "docstring": "Test service initialization.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 68
                },
                {
                  "name": "test_load_conversation",
                  "signature": "(self)",
                  "docstring": "Test loading a conversation.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 75
                },
                {
                  "name": "test_search_conversations",
                  "signature": "(self)",
                  "docstring": "Test searching conversations.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 95
                },
                {
                  "name": "test_filter_conversations",
                  "signature": "(self)",
                  "docstring": "Test filtering conversations.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 113
                },
                {
                  "name": "test_analyze_conversation",
                  "signature": "(self)",
                  "docstring": "Test analyzing a conversation.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 130
                }
              ],
              "attributes": [],
              "properties": [],
              "class_variables": [],
              "line_number": 65
            }
          ],
          "constants": [],
          "size": {
            "lines": 148,
            "bytes": 5320
          }
        },
        {
          "file": "tests/test_json_output_bug.py",
          "path": "tests/test_json_output_bug.py",
          "module_docstring": "Test for json_output bug with dict_items.",
          "imports": [
            {
              "module": "pytest",
              "alias": null
            },
            {
              "module": "orjson",
              "alias": null
            },
            {
              "module": "sys",
              "alias": null
            },
            {
              "module": "io",
              "from": true,
              "names": [
                "StringIO"
              ]
            },
            {
              "module": "claude_parser.hooks.json_output",
              "from": true,
              "names": [
                "json_output"
              ]
            }
          ],
          "functions": [
            {
              "name": "test_json_output_with_kwargs",
              "signature": "(capsys)",
              "docstring": "Test json_output doesn't crash with kwargs.",
              "decorators": [],
              "is_async": false,
              "line_number": 10
            },
            {
              "name": "test_json_output_stop_event",
              "signature": "(capsys)",
              "docstring": "Test json_output works for Stop events.",
              "decorators": [],
              "is_async": false,
              "line_number": 29
            }
          ],
          "classes": [],
          "constants": [],
          "size": {
            "lines": 37,
            "bytes": 1095
          }
        },
        {
          "file": "tests/test_discovery.py",
          "path": "tests/test_discovery.py",
          "module_docstring": "Tests for discovery domain.",
          "imports": [
            {
              "module": "pytest",
              "alias": null
            },
            {
              "module": "pathlib",
              "from": true,
              "names": [
                "Path"
              ]
            },
            {
              "module": "unittest.mock",
              "from": true,
              "names": [
                "patch",
                "MagicMock"
              ]
            },
            {
              "module": "claude_parser.discovery",
              "from": true,
              "names": [
                "find_current_transcript",
                "find_transcript_for_cwd",
                "list_all_projects",
                "find_project_by_original_path",
                "find_project_by_encoded_name"
              ]
            }
          ],
          "functions": [],
          "classes": [
            {
              "name": "TestDiscoveryFunctions",
              "bases": [],
              "docstring": "Test discovery domain functions.",
              "methods": [
                {
                  "name": "test_find_current_transcript",
                  "signature": "(self, mock_find, mock_cwd)",
                  "docstring": "Test finding transcript for current directory.",
                  "decorators": [
                    "patch('claude_parser.discovery.transcript_finder.Path.cwd')",
                    "patch('claude_parser.discovery.transcript_finder.find_transcript_for_cwd')"
                  ],
                  "is_async": false,
                  "line_number": 20
                },
                {
                  "name": "test_find_transcript_for_cwd_not_found",
                  "signature": "(self, mock_home)",
                  "docstring": "Test when Claude projects directory doesn't exist.",
                  "decorators": [
                    "patch('claude_parser.discovery.transcript_finder.Path.home')"
                  ],
                  "is_async": false,
                  "line_number": 31
                },
                {
                  "name": "test_list_all_projects_empty",
                  "signature": "(self, mock_home)",
                  "docstring": "Test listing projects when none exist.",
                  "decorators": [
                    "patch('claude_parser.discovery.transcript_finder.Path.home')"
                  ],
                  "is_async": false,
                  "line_number": 40
                },
                {
                  "name": "test_find_project_by_original_path",
                  "signature": "(self, mock_list)",
                  "docstring": "Test finding project by original path.",
                  "decorators": [
                    "patch('claude_parser.discovery.transcript_finder.list_all_projects')"
                  ],
                  "is_async": false,
                  "line_number": 49
                },
                {
                  "name": "test_find_project_by_encoded_name",
                  "signature": "(self, mock_list)",
                  "docstring": "Test finding project by encoded name.",
                  "decorators": [
                    "patch('claude_parser.discovery.transcript_finder.list_all_projects')"
                  ],
                  "is_async": false,
                  "line_number": 71
                },
                {
                  "name": "test_find_project_by_original_path_not_found",
                  "signature": "(self, mock_list)",
                  "docstring": "Test finding project that doesn't exist.",
                  "decorators": [
                    "patch('claude_parser.discovery.transcript_finder.list_all_projects')"
                  ],
                  "is_async": false,
                  "line_number": 93
                },
                {
                  "name": "test_find_project_by_encoded_name_not_found",
                  "signature": "(self, mock_list)",
                  "docstring": "Test finding project by encoded name that doesn't exist.",
                  "decorators": [
                    "patch('claude_parser.discovery.transcript_finder.list_all_projects')"
                  ],
                  "is_async": false,
                  "line_number": 102
                }
              ],
              "attributes": [],
              "properties": [],
              "class_variables": [],
              "line_number": 15
            },
            {
              "name": "TestDiscoveryWithRealData",
              "bases": [],
              "docstring": "Test discovery with real Claude Code data if available.",
              "methods": [
                {
                  "name": "test_list_all_projects_real",
                  "signature": "(self)",
                  "docstring": "Test listing real projects if they exist.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 114
                },
                {
                  "name": "test_find_current_transcript_real",
                  "signature": "(self)",
                  "docstring": "Test finding current transcript in real environment.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 127
                }
              ],
              "attributes": [],
              "properties": [],
              "class_variables": [],
              "line_number": 111
            }
          ],
          "constants": [],
          "size": {
            "lines": 134,
            "bytes": 4918
          }
        },
        {
          "file": "tests/test_exit_success_json.py",
          "path": "tests/test_exit_success_json.py",
          "module_docstring": "Test that exit_success outputs proper JSON for Claude Code.",
          "imports": [
            {
              "module": "pytest",
              "alias": null
            },
            {
              "module": "orjson",
              "alias": null
            },
            {
              "module": "claude_parser.hooks",
              "from": true,
              "names": [
                "exit_success"
              ]
            }
          ],
          "functions": [
            {
              "name": "test_exit_success_outputs_continue_json",
              "signature": "(capsys)",
              "docstring": "Test that exit_success outputs {\"continue\": true} for Claude Code.",
              "decorators": [],
              "is_async": false,
              "line_number": 8
            },
            {
              "name": "test_exit_success_with_message_outputs_json",
              "signature": "(capsys)",
              "docstring": "Test that exit_success with message still outputs valid JSON.",
              "decorators": [],
              "is_async": false,
              "line_number": 23
            }
          ],
          "classes": [],
          "constants": [],
          "size": {
            "lines": 35,
            "bytes": 1083
          }
        },
        {
          "file": "tests/test_conversation.py",
          "path": "tests/test_conversation.py",
          "module_docstring": "Tests for Conversation class.",
          "imports": [
            {
              "module": "pytest",
              "alias": null
            },
            {
              "module": "pathlib",
              "from": true,
              "names": [
                "Path"
              ]
            },
            {
              "module": "claude_parser",
              "from": true,
              "names": [
                "load"
              ]
            },
            {
              "module": "claude_parser.domain.entities.conversation",
              "from": true,
              "names": [
                "Conversation"
              ]
            },
            {
              "module": "claude_parser.models",
              "from": true,
              "names": [
                "MessageType",
                "AssistantMessage",
                "UserMessage"
              ]
            }
          ],
          "functions": [
            {
              "name": "real_claude_jsonl",
              "signature": "()",
              "docstring": "Use real Claude Code JSONL file for testing.",
              "decorators": [
                "pytest.fixture"
              ],
              "is_async": false,
              "line_number": 11
            }
          ],
          "classes": [
            {
              "name": "TestConversationInit",
              "bases": [],
              "docstring": "Test conversation initialization.",
              "methods": [
                {
                  "name": "test_conversation_creation",
                  "signature": "(self, real_claude_jsonl)",
                  "docstring": "Test creating conversation from JSONL.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 22
                },
                {
                  "name": "test_conversation_with_missing_file",
                  "signature": "(self)",
                  "docstring": "Test error handling for missing file.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 29
                },
                {
                  "name": "test_conversation_repr",
                  "signature": "(self, sample_jsonl)",
                  "docstring": "Test string representation.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 34
                }
              ],
              "attributes": [],
              "properties": [],
              "class_variables": [],
              "line_number": 19
            },
            {
              "name": "TestConversationProperties",
              "bases": [],
              "docstring": "Test conversation properties.",
              "methods": [
                {
                  "name": "test_messages_property",
                  "signature": "(self, sample_jsonl)",
                  "docstring": "Test messages property.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 46
                },
                {
                  "name": "test_session_id_property",
                  "signature": "(self, sample_jsonl)",
                  "docstring": "Test session_id extraction.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 54
                },
                {
                  "name": "test_assistant_messages",
                  "signature": "(self, sample_jsonl)",
                  "docstring": "Test assistant messages filtering.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 59
                },
                {
                  "name": "test_user_messages",
                  "signature": "(self, sample_jsonl)",
                  "docstring": "Test user messages filtering.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 66
                },
                {
                  "name": "test_tool_uses",
                  "signature": "(self, sample_jsonl)",
                  "docstring": "Test tool use filtering.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 73
                },
                {
                  "name": "test_summaries",
                  "signature": "(self, sample_jsonl)",
                  "docstring": "Test summary filtering.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 79
                },
                {
                  "name": "test_current_dir",
                  "signature": "(self, sample_jsonl)",
                  "docstring": "Test current directory extraction.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 85
                },
                {
                  "name": "test_git_branch",
                  "signature": "(self, sample_jsonl)",
                  "docstring": "Test git branch extraction.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 90
                }
              ],
              "attributes": [],
              "properties": [],
              "class_variables": [],
              "line_number": 43
            },
            {
              "name": "TestConversationMethods",
              "bases": [],
              "docstring": "Test conversation methods.",
              "methods": [
                {
                  "name": "test_filter_method",
                  "signature": "(self, sample_jsonl)",
                  "docstring": "Test filter method.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 99
                },
                {
                  "name": "test_search_method",
                  "signature": "(self, sample_jsonl)",
                  "docstring": "Test search method.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 106
                },
                {
                  "name": "test_search_case_insensitive",
                  "signature": "(self, sample_jsonl)",
                  "docstring": "Test case insensitive search.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 112
                },
                {
                  "name": "test_search_case_sensitive",
                  "signature": "(self, sample_jsonl)",
                  "docstring": "Test case sensitive search.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 118
                },
                {
                  "name": "test_before_summary",
                  "signature": "(self, sample_jsonl)",
                  "docstring": "Test before_summary method.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 124
                },
                {
                  "name": "test_before_summary_no_summary",
                  "signature": "(self, tmp_path)",
                  "docstring": "Test before_summary with no summary.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 132
                },
                {
                  "name": "test_with_errors",
                  "signature": "(self, sample_jsonl)",
                  "docstring": "Test error detection.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 141
                }
              ],
              "attributes": [],
              "properties": [],
              "class_variables": [],
              "line_number": 96
            },
            {
              "name": "TestConversationIteration",
              "bases": [],
              "docstring": "Test conversation iteration and indexing.",
              "methods": [
                {
                  "name": "test_len",
                  "signature": "(self, sample_jsonl)",
                  "docstring": "Test length.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 152
                },
                {
                  "name": "test_getitem_index",
                  "signature": "(self, sample_jsonl)",
                  "docstring": "Test indexing.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 157
                },
                {
                  "name": "test_getitem_slice",
                  "signature": "(self, sample_jsonl)",
                  "docstring": "Test slicing.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 165
                },
                {
                  "name": "test_iteration",
                  "signature": "(self, sample_jsonl)",
                  "docstring": "Test iteration.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 172
                }
              ],
              "attributes": [],
              "properties": [],
              "class_variables": [],
              "line_number": 149
            },
            {
              "name": "TestConversationErrorHandling",
              "bases": [],
              "docstring": "Test error handling.",
              "methods": [
                {
                  "name": "test_malformed_jsonl",
                  "signature": "(self, tmp_path)",
                  "docstring": "Test handling malformed JSONL.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 185
                },
                {
                  "name": "test_empty_file",
                  "signature": "(self, tmp_path)",
                  "docstring": "Test empty file handling.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 194
                }
              ],
              "attributes": [],
              "properties": [],
              "class_variables": [],
              "line_number": 182
            }
          ],
          "constants": [],
          "size": {
            "lines": 201,
            "bytes": 7345
          }
        },
        {
          "file": "tests/test_todo_storage.py",
          "path": "tests/test_todo_storage.py",
          "module_docstring": "Test TodoStorage - Single Responsibility: File I/O.",
          "imports": [
            {
              "module": "pytest",
              "alias": null
            },
            {
              "module": "pathlib",
              "from": true,
              "names": [
                "Path"
              ]
            },
            {
              "module": "orjson",
              "alias": null
            },
            {
              "module": "claude_parser.domain.todo.storage",
              "from": true,
              "names": [
                "TodoStorage"
              ]
            }
          ],
          "functions": [
            {
              "name": "test_get_path",
              "signature": "()",
              "docstring": "Get correct file path for session/agent.",
              "decorators": [],
              "is_async": false,
              "line_number": 8
            },
            {
              "name": "test_write_read_roundtrip",
              "signature": "(tmp_path, monkeypatch)",
              "docstring": "Write and read todos.",
              "decorators": [],
              "is_async": false,
              "line_number": 20
            },
            {
              "name": "test_read_nonexistent",
              "signature": "(tmp_path, monkeypatch)",
              "docstring": "Read returns empty list for missing file.",
              "decorators": [],
              "is_async": false,
              "line_number": 37
            },
            {
              "name": "test_delete",
              "signature": "(tmp_path, monkeypatch)",
              "docstring": "Delete todo file.",
              "decorators": [],
              "is_async": false,
              "line_number": 45
            }
          ],
          "classes": [],
          "constants": [],
          "size": {
            "lines": 53,
            "bytes": 1565
          }
        },
        {
          "file": "tests/test_integration.py",
          "path": "tests/test_integration.py",
          "module_docstring": "Integration tests with real Claude Code JSONL files.",
          "imports": [
            {
              "module": "pytest",
              "alias": null
            },
            {
              "module": "pathlib",
              "from": true,
              "names": [
                "Path"
              ]
            },
            {
              "module": "claude_parser",
              "from": true,
              "names": [
                "load",
                "MessageType"
              ]
            },
            {
              "module": "time",
              "alias": null
            },
            {
              "module": "os",
              "alias": null
            },
            {
              "module": "psutil",
              "alias": null
            }
          ],
          "functions": [],
          "classes": [
            {
              "name": "TestRealClaudeExport",
              "bases": [],
              "docstring": "Test with actual Claude Code export file.",
              "methods": [
                {
                  "name": "test_load_real_claude_export",
                  "signature": "(self)",
                  "docstring": "Test loading actual Claude Code export.",
                  "decorators": [
                    "pytest.mark.skipif(not Path(REAL_JSONL_PATH).exists(), reason='Real Claude JSONL file not available')"
                  ],
                  "is_async": false,
                  "line_number": 17
                },
                {
                  "name": "test_real_export_properties",
                  "signature": "(self)",
                  "docstring": "Test properties work with real export.",
                  "decorators": [
                    "pytest.mark.skipif(not Path(REAL_JSONL_PATH).exists(), reason='Real Claude JSONL file not available')"
                  ],
                  "is_async": false,
                  "line_number": 34
                },
                {
                  "name": "test_real_export_search",
                  "signature": "(self)",
                  "docstring": "Test search functionality with real data.",
                  "decorators": [
                    "pytest.mark.skipif(not Path(REAL_JSONL_PATH).exists(), reason='Real Claude JSONL file not available')"
                  ],
                  "is_async": false,
                  "line_number": 60
                },
                {
                  "name": "test_real_export_navigation",
                  "signature": "(self)",
                  "docstring": "Test navigation features with real data.",
                  "decorators": [
                    "pytest.mark.skipif(not Path(REAL_JSONL_PATH).exists(), reason='Real Claude JSONL file not available')"
                  ],
                  "is_async": false,
                  "line_number": 80
                },
                {
                  "name": "test_real_export_iteration",
                  "signature": "(self)",
                  "docstring": "Test iteration works with real data.",
                  "decorators": [
                    "pytest.mark.skipif(not Path(REAL_JSONL_PATH).exists(), reason='Real Claude JSONL file not available')"
                  ],
                  "is_async": false,
                  "line_number": 105
                }
              ],
              "attributes": [],
              "properties": [],
              "class_variables": [],
              "line_number": 12
            },
            {
              "name": "TestPerformance",
              "bases": [],
              "docstring": "Test performance with real files.",
              "methods": [
                {
                  "name": "test_loading_performance",
                  "signature": "(self)",
                  "docstring": "Test that loading is reasonably fast.",
                  "decorators": [
                    "pytest.mark.skipif(not Path(REAL_JSONL_PATH).exists(), reason='Real Claude JSONL file not available')"
                  ],
                  "is_async": false,
                  "line_number": 140
                },
                {
                  "name": "test_memory_usage_reasonable",
                  "signature": "(self)",
                  "docstring": "Test memory usage is reasonable.",
                  "decorators": [
                    "pytest.mark.skipif(not Path(REAL_JSONL_PATH).exists(), reason='Real Claude JSONL file not available')"
                  ],
                  "is_async": false,
                  "line_number": 155
                }
              ],
              "attributes": [],
              "properties": [],
              "class_variables": [],
              "line_number": 135
            },
            {
              "name": "TestEdgeCases",
              "bases": [],
              "docstring": "Test edge cases that might appear in real files.",
              "methods": [
                {
                  "name": "test_empty_messages_handled",
                  "signature": "(self, tmp_path)",
                  "docstring": "Test handling of empty or minimal messages.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 179
                },
                {
                  "name": "test_unicode_and_special_chars",
                  "signature": "(self, tmp_path)",
                  "docstring": "Test Unicode and special characters.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 197
                }
              ],
              "attributes": [],
              "properties": [],
              "class_variables": [],
              "line_number": 176
            }
          ],
          "constants": [
            "REAL_JSONL_PATH"
          ],
          "size": {
            "lines": 212,
            "bytes": 8310
          }
        },
        {
          "file": "tests/test_api.py",
          "path": "tests/test_api.py",
          "module_docstring": "Tests for public API - the 95% use cases.",
          "imports": [
            {
              "module": "pytest",
              "alias": null
            },
            {
              "module": "pathlib",
              "from": true,
              "names": [
                "Path"
              ]
            },
            {
              "module": "claude_parser",
              "from": true,
              "names": [
                "load",
                "load_many",
                "Conversation",
                "MessageType"
              ]
            },
            {
              "module": "claude_parser",
              "from": true,
              "names": [
                "load",
                "load_many",
                "Conversation"
              ]
            },
            {
              "module": "claude_parser",
              "from": true,
              "names": [
                "MessageType",
                "UserMessage",
                "AssistantMessage"
              ]
            },
            {
              "module": "claude_parser",
              "alias": null
            }
          ],
          "functions": [
            {
              "name": "simple_jsonl",
              "signature": "(tmp_path)",
              "docstring": "Simple JSONL for basic testing.",
              "decorators": [
                "pytest.fixture"
              ],
              "is_async": false,
              "line_number": 9
            }
          ],
          "classes": [
            {
              "name": "TestLoadFunction",
              "bases": [],
              "docstring": "Test the main load() function - 95% use case.",
              "methods": [
                {
                  "name": "test_load_basic",
                  "signature": "(self, simple_jsonl)",
                  "docstring": "Test basic load functionality.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 25
                },
                {
                  "name": "test_load_with_string_path",
                  "signature": "(self, simple_jsonl)",
                  "docstring": "Test load with string path.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 35
                },
                {
                  "name": "test_load_with_pathlib",
                  "signature": "(self, simple_jsonl)",
                  "docstring": "Test load with pathlib.Path.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 40
                },
                {
                  "name": "test_load_file_not_found",
                  "signature": "(self)",
                  "docstring": "Test load with non-existent file.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 45
                }
              ],
              "attributes": [],
              "properties": [],
              "class_variables": [],
              "line_number": 22
            },
            {
              "name": "TestLoadManyFunction",
              "bases": [],
              "docstring": "Test load_many() function.",
              "methods": [
                {
                  "name": "test_load_many",
                  "signature": "(self, tmp_path)",
                  "docstring": "Test loading multiple files.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 54
                },
                {
                  "name": "test_load_many_empty_list",
                  "signature": "(self)",
                  "docstring": "Test load_many with empty list.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 72
                }
              ],
              "attributes": [],
              "properties": [],
              "class_variables": [],
              "line_number": 51
            },
            {
              "name": "Test95PercentUseCases",
              "bases": [],
              "docstring": "Test the most common usage patterns.",
              "methods": [
                {
                  "name": "test_95_percent_pattern_basic",
                  "signature": "(self, simple_jsonl)",
                  "docstring": "Test the primary 95% use case pattern.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 81
                },
                {
                  "name": "test_95_percent_pattern_properties",
                  "signature": "(self, simple_jsonl)",
                  "docstring": "Test common property access patterns.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 92
                },
                {
                  "name": "test_95_percent_pattern_search",
                  "signature": "(self, simple_jsonl)",
                  "docstring": "Test common search patterns.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 105
                },
                {
                  "name": "test_95_percent_pattern_iteration",
                  "signature": "(self, simple_jsonl)",
                  "docstring": "Test iteration patterns.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 117
                },
                {
                  "name": "test_95_percent_error_handling",
                  "signature": "(self, tmp_path)",
                  "docstring": "Test that errors don't break the 95% case.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 132
                }
              ],
              "attributes": [],
              "properties": [],
              "class_variables": [],
              "line_number": 78
            },
            {
              "name": "TestAPIImports",
              "bases": [],
              "docstring": "Test that important things can be imported.",
              "methods": [
                {
                  "name": "test_main_imports",
                  "signature": "(self)",
                  "docstring": "Test main imports work.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 153
                },
                {
                  "name": "test_message_type_imports",
                  "signature": "(self)",
                  "docstring": "Test message type imports.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 161
                },
                {
                  "name": "test_version_available",
                  "signature": "(self)",
                  "docstring": "Test version is available.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 169
                }
              ],
              "attributes": [],
              "properties": [],
              "class_variables": [],
              "line_number": 150
            },
            {
              "name": "TestRealWorldUsage",
              "bases": [],
              "docstring": "Test real-world usage scenarios.",
              "methods": [
                {
                  "name": "test_typical_workflow",
                  "signature": "(self, simple_jsonl)",
                  "docstring": "Test a typical analysis workflow.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 179
                },
                {
                  "name": "test_one_liner_analysis",
                  "signature": "(self, simple_jsonl)",
                  "docstring": "Test one-liner analysis patterns.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 202
                },
                {
                  "name": "test_chain_operations",
                  "signature": "(self, simple_jsonl)",
                  "docstring": "Test method chaining patterns.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 213
                }
              ],
              "attributes": [],
              "properties": [],
              "class_variables": [],
              "line_number": 176
            }
          ],
          "constants": [],
          "size": {
            "lines": 223,
            "bytes": 7741
          }
        },
        {
          "file": "tests/test_bug_toolz_map.py",
          "path": "tests/test_bug_toolz_map.py",
          "module_docstring": "Test to reproduce the P0 bug: map() must have at least two arguments.",
          "imports": [
            {
              "module": "pytest",
              "alias": null
            },
            {
              "module": "pathlib",
              "from": true,
              "names": [
                "Path"
              ]
            },
            {
              "module": "claude_parser",
              "from": true,
              "names": [
                "load"
              ]
            }
          ],
          "functions": [
            {
              "name": "test_load_conversation_with_toolz_map_bug",
              "signature": "()",
              "docstring": "Test that we can load a conversation file without toolz map error.",
              "decorators": [],
              "is_async": false,
              "line_number": 10
            }
          ],
          "classes": [],
          "constants": [],
          "size": {
            "lines": 25,
            "bytes": 903
          }
        },
        {
          "file": "tests/test_claude_format_validation.py",
          "path": "tests/test_claude_format_validation.py",
          "module_docstring": "TDD Tests for Claude format validation.\nThese tests should FAIL initially, then pass after implementing validation.",
          "imports": [
            {
              "module": "pytest",
              "alias": null
            },
            {
              "module": "pathlib",
              "from": true,
              "names": [
                "Path"
              ]
            },
            {
              "module": "claude_parser",
              "from": true,
              "names": [
                "load"
              ]
            },
            {
              "module": "claude_parser.infrastructure.jsonl_parser",
              "from": true,
              "names": [
                "validate_claude_format"
              ]
            }
          ],
          "functions": [],
          "classes": [
            {
              "name": "TestClaudeFormatValidation",
              "bases": [],
              "docstring": "Test Claude JSONL format validation.",
              "methods": [
                {
                  "name": "test_valid_claude_format_passes",
                  "signature": "(self, tmp_path)",
                  "docstring": "TDD: Test that valid Claude JSONL passes validation.\nShould FAIL initially - validate_claude_format doesn't exist yet.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 15
                },
                {
                  "name": "test_non_claude_jsonl_fails_validation",
                  "signature": "(self, tmp_path)",
                  "docstring": "TDD: Test that non-Claude JSONL fails validation.\nShould FAIL initially - validation not implemented.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 37
                },
                {
                  "name": "test_load_with_strict_validation",
                  "signature": "(self, tmp_path)",
                  "docstring": "TDD: Test load() with strict validation mode.\nShould FAIL initially - strict mode not implemented.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 60
                },
                {
                  "name": "test_load_without_strict_validation_works",
                  "signature": "(self, tmp_path)",
                  "docstring": "TDD: Test load() without strict validation (default).\nShould work as it does now - load whatever we can parse.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 81
                },
                {
                  "name": "test_claude_format_signature_detection",
                  "signature": "(self, tmp_path)",
                  "docstring": "TDD: Test detection of Claude format signatures.\nShould FAIL initially - signature detection not implemented.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 103
                },
                {
                  "name": "test_empty_file_validation",
                  "signature": "(self, tmp_path)",
                  "docstring": "TDD: Test validation of empty files.\nShould FAIL initially.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 124
                }
              ],
              "attributes": [],
              "properties": [],
              "class_variables": [],
              "line_number": 12
            },
            {
              "name": "TestRealClaudeFileValidation",
              "bases": [],
              "docstring": "Test validation with real Claude export file.",
              "methods": [
                {
                  "name": "test_real_claude_file_passes_validation",
                  "signature": "(self)",
                  "docstring": "TDD: Test that real Claude export passes validation.\nShould FAIL initially.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 142
                }
              ],
              "attributes": [],
              "properties": [],
              "class_variables": [],
              "line_number": 139
            }
          ],
          "constants": [],
          "size": {
            "lines": 158,
            "bytes": 6717
          }
        },
        {
          "file": "tests/test_ddd_conversation.py",
          "path": "tests/test_ddd_conversation.py",
          "module_docstring": "Tests for DDD Conversation implementation with real Claude Code data.",
          "imports": [
            {
              "module": "pytest",
              "alias": null
            },
            {
              "module": "time",
              "alias": null
            },
            {
              "module": "pathlib",
              "from": true,
              "names": [
                "Path"
              ]
            },
            {
              "module": "claude_parser",
              "from": true,
              "names": [
                "load"
              ]
            },
            {
              "module": "claude_parser.domain",
              "from": true,
              "names": [
                "ConversationAnalyzer"
              ]
            },
            {
              "module": "claude_parser.domain.entities.conversation",
              "from": true,
              "names": [
                "Conversation",
                "ConversationMetadata"
              ]
            },
            {
              "module": "claude_parser.models",
              "from": true,
              "names": [
                "MessageType",
                "AssistantMessage",
                "UserMessage"
              ]
            },
            {
              "module": "time",
              "alias": null
            }
          ],
          "functions": [
            {
              "name": "real_claude_file",
              "signature": "()",
              "docstring": "Real Claude Code JSONL file for testing DDD implementation.",
              "decorators": [
                "pytest.fixture"
              ],
              "is_async": false,
              "line_number": 13
            }
          ],
          "classes": [
            {
              "name": "TestDDDArchitecture",
              "bases": [],
              "docstring": "Test Domain Driven Design implementation.",
              "methods": [
                {
                  "name": "test_load_factory_function",
                  "signature": "(self, real_claude_file)",
                  "docstring": "Test 95% use case - simple load() function.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 24
                },
                {
                  "name": "test_large_file_factory",
                  "signature": "(self, real_claude_file)",
                  "docstring": "Test 5% use case - load() handles large files.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 38
                },
                {
                  "name": "test_analyze_factory",
                  "signature": "(self, real_claude_file)",
                  "docstring": "Test conversation analysis factory function.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 46
                },
                {
                  "name": "test_extract_assistant_messages_factory",
                  "signature": "(self, real_claude_file)",
                  "docstring": "Test assistant message extraction factory function.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 58
                }
              ],
              "attributes": [],
              "properties": [],
              "class_variables": [],
              "line_number": 21
            },
            {
              "name": "TestDomainBehavior",
              "bases": [],
              "docstring": "Test rich domain model behavior.",
              "methods": [
                {
                  "name": "test_conversation_properties",
                  "signature": "(self, real_claude_file)",
                  "docstring": "Test conversation entity properties.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 77
                },
                {
                  "name": "test_conversation_search",
                  "signature": "(self, real_claude_file)",
                  "docstring": "Test domain search behavior.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 87
                },
                {
                  "name": "test_conversation_filtering",
                  "signature": "(self, real_claude_file)",
                  "docstring": "Test domain filtering behavior.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 98
                },
                {
                  "name": "test_error_detection",
                  "signature": "(self, real_claude_file)",
                  "docstring": "Test domain error detection.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 109
                }
              ],
              "attributes": [],
              "properties": [],
              "class_variables": [],
              "line_number": 74
            },
            {
              "name": "TestRepositoryPattern",
              "bases": [],
              "docstring": "Test infrastructure layer repository pattern.",
              "methods": [
                {
                  "name": "test_metadata_extraction",
                  "signature": "(self, real_claude_file)",
                  "docstring": "Test repository extracts metadata correctly.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 121
                },
                {
                  "name": "test_orjson_pydantic_compliance",
                  "signature": "(self, real_claude_file)",
                  "docstring": "Test repository uses orjson + pydantic per specification.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 131
                }
              ],
              "attributes": [],
              "properties": [],
              "class_variables": [],
              "line_number": 118
            },
            {
              "name": "TestCollectionInterface",
              "bases": [],
              "docstring": "Test conversation collection behavior.",
              "methods": [
                {
                  "name": "test_length_and_indexing",
                  "signature": "(self, real_claude_file)",
                  "docstring": "Test conversation acts like a collection.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 148
                },
                {
                  "name": "test_iteration",
                  "signature": "(self, real_claude_file)",
                  "docstring": "Test conversation iteration.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 161
                }
              ],
              "attributes": [],
              "properties": [],
              "class_variables": [],
              "line_number": 145
            },
            {
              "name": "TestSOLIDPrinciples",
              "bases": [],
              "docstring": "Test SOLID principles adherence.",
              "methods": [
                {
                  "name": "test_single_responsibility",
                  "signature": "(self, real_claude_file)",
                  "docstring": "Each class has single responsibility.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 178
                },
                {
                  "name": "test_dependency_inversion",
                  "signature": "(self, real_claude_file)",
                  "docstring": "Domain doesn't depend on infrastructure.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 190
                }
              ],
              "attributes": [],
              "properties": [],
              "class_variables": [],
              "line_number": 175
            },
            {
              "name": "TestPerformance",
              "bases": [],
              "docstring": "Test performance characteristics.",
              "methods": [
                {
                  "name": "test_large_file_performance",
                  "signature": "(self, real_claude_file)",
                  "docstring": "Test performance with real large file (3481 messages).",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 205
                },
                {
                  "name": "test_memory_efficiency",
                  "signature": "(self, real_claude_file)",
                  "docstring": "Test memory usage is reasonable.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 218
                }
              ],
              "attributes": [],
              "properties": [],
              "class_variables": [],
              "line_number": 202
            }
          ],
          "constants": [],
          "size": {
            "lines": 232,
            "bytes": 8267
          }
        },
        {
          "file": "tests/test_api_contract.py",
          "path": "tests/test_api_contract.py",
          "module_docstring": "API Contract Tests - MUST NOT BREAK!\n\nThese tests ensure backward compatibility during refactoring.\nIf these fail, we've broken the public API.",
          "imports": [
            {
              "module": "pytest",
              "alias": null
            },
            {
              "module": "pathlib",
              "from": true,
              "names": [
                "Path"
              ]
            },
            {
              "module": "claude_parser",
              "from": true,
              "names": [
                "load",
                "load_large",
                "load_many"
              ]
            },
            {
              "module": "claude_parser",
              "from": true,
              "names": [
                "Conversation"
              ]
            },
            {
              "module": "claude_parser.hooks",
              "from": true,
              "names": [
                "hook_input"
              ]
            },
            {
              "module": "claude_parser.hooks",
              "from": true,
              "names": [
                "exit_success",
                "exit_block",
                "exit_error"
              ]
            },
            {
              "module": "claude_parser.hooks",
              "from": true,
              "names": [
                "HookData"
              ]
            },
            {
              "module": "claude_parser.watch",
              "from": true,
              "names": [
                "watch"
              ]
            },
            {
              "module": "claude_parser.models",
              "from": true,
              "names": [
                "Message",
                "UserMessage",
                "AssistantMessage"
              ]
            },
            {
              "module": "claude_parser.models",
              "from": true,
              "names": [
                "ToolUseContent",
                "ToolResultContent",
                "Summary"
              ]
            },
            {
              "module": "claude_parser",
              "from": true,
              "names": [
                "Conversation"
              ]
            },
            {
              "module": "claude_parser.models",
              "from": true,
              "names": [
                "Message"
              ]
            },
            {
              "module": "claude_parser.hooks",
              "from": true,
              "names": [
                "HookData",
                "exit_success",
                "exit_block"
              ]
            },
            {
              "module": "claude_parser",
              "from": true,
              "names": [
                "load"
              ]
            },
            {
              "module": "inspect",
              "alias": null
            },
            {
              "module": "claude_parser.watch",
              "from": true,
              "names": [
                "watch"
              ]
            },
            {
              "module": "inspect",
              "alias": null
            },
            {
              "module": "claude_parser.models",
              "from": true,
              "names": [
                "Message",
                "BaseMessage",
                "UserMessage",
                "AssistantMessage",
                "ToolUseContent",
                "ToolResultContent",
                "Summary",
                "SystemMessage"
              ]
            },
            {
              "module": "typing",
              "from": true,
              "names": [
                "Union",
                "get_origin"
              ]
            },
            {
              "module": "claude_parser",
              "from": true,
              "names": [
                "parse_jsonl"
              ]
            },
            {
              "module": "claude_parser.features",
              "from": true,
              "names": [
                "get_registry"
              ]
            },
            {
              "module": "claude_parser",
              "from": true,
              "names": [
                "load"
              ]
            },
            {
              "module": "claude_parser",
              "from": true,
              "names": [
                "Conversation"
              ]
            },
            {
              "module": "claude_parser.hooks",
              "from": true,
              "names": [
                "hook_input"
              ]
            },
            {
              "module": "claude_parser.watch",
              "from": true,
              "names": [
                "watch"
              ]
            }
          ],
          "functions": [
            {
              "name": "test_core_imports_work",
              "signature": "()",
              "docstring": "Core imports must work without error.",
              "decorators": [],
              "is_async": false,
              "line_number": 12
            },
            {
              "name": "test_conversation_api_structure",
              "signature": "()",
              "docstring": "Conversation must have expected attributes.",
              "decorators": [],
              "is_async": false,
              "line_number": 35
            },
            {
              "name": "test_hook_api_structure",
              "signature": "()",
              "docstring": "Hook functions must work as documented.",
              "decorators": [],
              "is_async": false,
              "line_number": 57
            },
            {
              "name": "test_load_function_signature",
              "signature": "()",
              "docstring": "Load function must accept string or Path.",
              "decorators": [],
              "is_async": false,
              "line_number": 69
            },
            {
              "name": "test_watch_function_signature",
              "signature": "()",
              "docstring": "Watch function must accept file and callback.",
              "decorators": [],
              "is_async": false,
              "line_number": 82
            },
            {
              "name": "test_backwards_compatibility",
              "signature": "()",
              "docstring": "Old import paths should still work or have clear migration.",
              "decorators": [],
              "is_async": false,
              "line_number": 94
            },
            {
              "name": "test_model_types_available",
              "signature": "()",
              "docstring": "All documented model types must be importable.",
              "decorators": [],
              "is_async": false,
              "line_number": 106
            },
            {
              "name": "test_feature_registry_accessible",
              "signature": "()",
              "docstring": "Feature registry should be accessible for capability checking.",
              "decorators": [],
              "is_async": false,
              "line_number": 128
            },
            {
              "name": "test_feature_coverage_maintained",
              "signature": "(feature, min_coverage)",
              "docstring": "Critical features must maintain coverage.",
              "decorators": [
                "pytest.mark.parametrize('feature,min_coverage', [('load', 90), ('Conversation', 90), ('hook_input', 90), ('watch', 80)])"
              ],
              "is_async": false,
              "line_number": 146
            }
          ],
          "classes": [],
          "constants": [],
          "size": {
            "lines": 161,
            "bytes": 4917
          }
        },
        {
          "file": "tests/test_todo_swiper.py",
          "path": "tests/test_todo_swiper.py",
          "module_docstring": "Test TodoSwiper - Tinder-like todo history navigation.",
          "imports": [
            {
              "module": "pytest",
              "alias": null
            },
            {
              "module": "tempfile",
              "alias": null
            },
            {
              "module": "orjson",
              "alias": null
            },
            {
              "module": "pathlib",
              "from": true,
              "names": [
                "Path"
              ]
            },
            {
              "module": "claude_parser.domain.todo",
              "from": true,
              "names": [
                "TodoSwiper"
              ]
            }
          ],
          "functions": [
            {
              "name": "test_swiper_navigation",
              "signature": "()",
              "docstring": "Test swipe left/right through todo history.",
              "decorators": [],
              "is_async": false,
              "line_number": 9
            },
            {
              "name": "test_swiper_display_format",
              "signature": "()",
              "docstring": "Test Rich display format for swiper.",
              "decorators": [],
              "is_async": false,
              "line_number": 45
            },
            {
              "name": "test_swiper_empty_history",
              "signature": "()",
              "docstring": "Handle empty todo history.",
              "decorators": [],
              "is_async": false,
              "line_number": 62
            },
            {
              "name": "test_incremental_todo_progression",
              "signature": "()",
              "docstring": "Test incremental completion of SAME todos - core backlog behavior.",
              "decorators": [],
              "is_async": false,
              "line_number": 72
            },
            {
              "name": "test_content_similarity_grouping",
              "signature": "()",
              "docstring": "Test content similarity algorithm groups same todos correctly.",
              "decorators": [],
              "is_async": false,
              "line_number": 131
            },
            {
              "name": "test_transcript_parsing_integration",
              "signature": "()",
              "docstring": "Test full transcript parsing with realistic TodoWrite data.",
              "decorators": [],
              "is_async": false,
              "line_number": 161
            },
            {
              "name": "test_content_overlap_calculation",
              "signature": "()",
              "docstring": "Test content overlap calculation for grouping decisions.",
              "decorators": [],
              "is_async": false,
              "line_number": 250
            },
            {
              "name": "test_backlog_system_integration",
              "signature": "()",
              "docstring": "Test TodoSwiper integration with backlog workflows - critical for production.",
              "decorators": [],
              "is_async": false,
              "line_number": 281
            }
          ],
          "classes": [],
          "constants": [],
          "size": {
            "lines": 333,
            "bytes": 13350
          }
        },
        {
          "file": "tests/test_todo_manager.py",
          "path": "tests/test_todo_manager.py",
          "module_docstring": "Test TodoManager - Integration tests for facade pattern.",
          "imports": [
            {
              "module": "pytest",
              "alias": null
            },
            {
              "module": "claude_parser.domain.todo",
              "from": true,
              "names": [
                "TodoManager"
              ]
            }
          ],
          "functions": [
            {
              "name": "test_manager_integration",
              "signature": "(tmp_path, monkeypatch)",
              "docstring": "Test full workflow through manager.",
              "decorators": [],
              "is_async": false,
              "line_number": 6
            },
            {
              "name": "test_manager_main_vs_sub_agent",
              "signature": "(tmp_path, monkeypatch)",
              "docstring": "Test main agent vs sub-agent file naming.",
              "decorators": [],
              "is_async": false,
              "line_number": 39
            },
            {
              "name": "test_manager_empty_state",
              "signature": "(tmp_path, monkeypatch)",
              "docstring": "Test manager with no todos.",
              "decorators": [],
              "is_async": false,
              "line_number": 65
            }
          ],
          "classes": [],
          "constants": [],
          "size": {
            "lines": 79,
            "bytes": 2432
          }
        },
        {
          "file": "tests/fixtures.py",
          "path": "tests/fixtures.py",
          "module_docstring": "Test fixtures using real Claude Code JSONL production data.\n\nSOLID: Single responsibility - only test fixtures\n95/5: Using real production data from actual Claude sessions\nNO MOCKS: All tests use real JSONL files from jsonl-prod-data-for-test/",
          "imports": [
            {
              "module": "pathlib",
              "from": true,
              "names": [
                "Path"
              ]
            },
            {
              "module": "pytest",
              "alias": null
            }
          ],
          "functions": [
            {
              "name": "get_real_claude_jsonl_files",
              "signature": "()",
              "docstring": "Get real Claude JSONL files for testing from production data.",
              "decorators": [],
              "is_async": false,
              "line_number": 13
            },
            {
              "name": "small_claude_jsonl",
              "signature": "()",
              "docstring": "Fixture providing a small Claude JSONL file (edge case: 1 line).",
              "decorators": [
                "pytest.fixture"
              ],
              "is_async": false,
              "line_number": 31
            },
            {
              "name": "medium_claude_jsonl",
              "signature": "()",
              "docstring": "Fixture providing a medium-sized Claude JSONL file (~100 lines).",
              "decorators": [
                "pytest.fixture"
              ],
              "is_async": false,
              "line_number": 40
            },
            {
              "name": "large_claude_jsonl",
              "signature": "()",
              "docstring": "Fixture providing a large Claude JSONL file (1000+ lines).",
              "decorators": [
                "pytest.fixture"
              ],
              "is_async": false,
              "line_number": 49
            },
            {
              "name": "real_claude_jsonl",
              "signature": "()",
              "docstring": "Default fixture for any real Claude JSONL file.",
              "decorators": [
                "pytest.fixture"
              ],
              "is_async": false,
              "line_number": 58
            },
            {
              "name": "all_real_claude_jsonls",
              "signature": "()",
              "docstring": "Fixture providing all available real Claude JSONL files.",
              "decorators": [
                "pytest.fixture"
              ],
              "is_async": false,
              "line_number": 67
            },
            {
              "name": "sample_jsonl",
              "signature": "()",
              "docstring": "Legacy fixture name for backwards compatibility.",
              "decorators": [
                "pytest.fixture"
              ],
              "is_async": false,
              "line_number": 76
            }
          ],
          "classes": [],
          "constants": [],
          "size": {
            "lines": 81,
            "bytes": 2466
          }
        },
        {
          "file": "tests/test_real_jsonl_edge_cases.py",
          "path": "tests/test_real_jsonl_edge_cases.py",
          "module_docstring": "Test edge cases with real Claude JSONL files.\n\nFollowing LIBRARY_FIRST_RULE - using pytest for testing, orjson for parsing.\nTests all edge cases documented in docs/JSONL-STRUCTURE.md",
          "imports": [
            {
              "module": "pytest",
              "alias": null
            },
            {
              "module": "pathlib",
              "from": true,
              "names": [
                "Path"
              ]
            },
            {
              "module": "orjson",
              "alias": null
            },
            {
              "module": "claude_parser",
              "from": true,
              "names": [
                "load",
                "validate_claude_format"
              ]
            },
            {
              "module": "claude_parser.models.base",
              "from": true,
              "names": [
                "MessageType"
              ]
            },
            {
              "module": "claude_parser.infrastructure.jsonl_parser",
              "from": true,
              "names": [
                "parse_jsonl_streaming"
              ]
            }
          ],
          "functions": [],
          "classes": [
            {
              "name": "TestRealJSONLEdgeCases",
              "bases": [],
              "docstring": "Test edge cases using real Claude JSONL files.",
              "methods": [
                {
                  "name": "minimal_sessions",
                  "signature": "(self)",
                  "docstring": "Find minimal JSONL sessions (1-5 lines) for edge case testing.",
                  "decorators": [
                    "pytest.fixture"
                  ],
                  "is_async": false,
                  "line_number": 19
                },
                {
                  "name": "test_single_line_summary_only",
                  "signature": "(self, minimal_sessions)",
                  "docstring": "Test parsing single-line summary-only sessions.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 36
                },
                {
                  "name": "test_medium_session_with_tools",
                  "signature": "(self)",
                  "docstring": "Test a medium-sized session with tool use.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 55
                },
                {
                  "name": "test_nested_content_blocks",
                  "signature": "(self)",
                  "docstring": "Test messages with nested content blocks (assistant messages with tool use).",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 77
                },
                {
                  "name": "test_session_boundaries",
                  "signature": "(self)",
                  "docstring": "Test detection of session boundaries (different sessionIds).",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 103
                },
                {
                  "name": "test_meta_messages",
                  "signature": "(self)",
                  "docstring": "Test handling of meta messages (isMeta: true).",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 121
                },
                {
                  "name": "test_empty_content_handling",
                  "signature": "(self)",
                  "docstring": "Test handling of messages with empty or missing content.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 155
                },
                {
                  "name": "test_large_file_streaming",
                  "signature": "(self)",
                  "docstring": "Test streaming large files efficiently.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 202
                },
                {
                  "name": "test_malformed_json_handling",
                  "signature": "(self)",
                  "docstring": "Test that malformed JSON lines are skipped gracefully.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 227
                },
                {
                  "name": "test_validate_claude_format",
                  "signature": "(self)",
                  "docstring": "Test Claude format validation with real files.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 247
                }
              ],
              "attributes": [],
              "properties": [],
              "class_variables": [],
              "line_number": 15
            },
            {
              "name": "TestRealDataPatterns",
              "bases": [],
              "docstring": "Test specific patterns found in real Claude JSONL files.",
              "methods": [
                {
                  "name": "test_git_branch_tracking",
                  "signature": "(self)",
                  "docstring": "Test tracking of git branch changes within a session.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 274
                },
                {
                  "name": "test_cwd_tracking",
                  "signature": "(self)",
                  "docstring": "Test current working directory tracking.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 290
                },
                {
                  "name": "test_parent_uuid_threading",
                  "signature": "(self)",
                  "docstring": "Test reconstruction of conversation threads via parentUuid.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 304
                }
              ],
              "attributes": [],
              "properties": [],
              "class_variables": [],
              "line_number": 271
            }
          ],
          "constants": [],
          "size": {
            "lines": 332,
            "bytes": 13302
          }
        },
        {
          "file": "tests/test_phase3/test_watch_api.py",
          "path": "tests/test_phase3/test_watch_api.py",
          "module_docstring": "TDD Tests for Watch Domain API - Written FIRST.\n\nFollowing PHASE2_STRICT_PATTERN.md:\n1. Tests written before implementation\n2. 95/5 principle validation\n3. SOLID principle compliance\n4. DDD domain boundaries\n\nUses REAL Claude Code JSONL data for robust testing.\n\nSuccess Criteria:\n- watch() function exists and is callable\n- Callback receives (Conversation, List[Message])\n- Message type filtering works\n- File watching detects changes\n- Performance: handles large files efficiently\n- Error handling: graceful failure modes",
          "imports": [
            {
              "module": "pytest",
              "alias": null
            },
            {
              "module": "tempfile",
              "alias": null
            },
            {
              "module": "orjson",
              "alias": null
            },
            {
              "module": "time",
              "alias": null
            },
            {
              "module": "shutil",
              "alias": null
            },
            {
              "module": "pathlib",
              "from": true,
              "names": [
                "Path"
              ]
            },
            {
              "module": "unittest.mock",
              "from": true,
              "names": [
                "Mock",
                "patch"
              ]
            },
            {
              "module": "claude_parser.watch",
              "from": true,
              "names": [
                "watch"
              ]
            },
            {
              "module": "claude_parser.watch",
              "from": true,
              "names": [
                "watch"
              ]
            },
            {
              "module": "inspect",
              "alias": null
            },
            {
              "module": "claude_parser.watch",
              "from": true,
              "names": [
                "watch"
              ]
            },
            {
              "module": "claude_parser.watch",
              "from": true,
              "names": [
                "watch"
              ]
            },
            {
              "module": "claude_parser.watch",
              "from": true,
              "names": [
                "watch"
              ]
            },
            {
              "module": "claude_parser.watch",
              "from": true,
              "names": [
                "watch"
              ]
            },
            {
              "module": "claude_parser.watch",
              "from": true,
              "names": [
                "watch"
              ]
            },
            {
              "module": "claude_parser.watch",
              "from": true,
              "names": [
                "watch"
              ]
            },
            {
              "module": "claude_parser.watch",
              "from": true,
              "names": [
                "watch"
              ]
            }
          ],
          "functions": [],
          "classes": [
            {
              "name": "TestWatchDomainAPI",
              "bases": [],
              "docstring": "Test the watch domain API contract.",
              "methods": [
                {
                  "name": "test_watch_function_exists",
                  "signature": "(self)",
                  "docstring": "watch() function is available for import.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 79
                },
                {
                  "name": "test_watch_function_signature",
                  "signature": "(self)",
                  "docstring": "watch() has correct function signature.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 86
                },
                {
                  "name": "test_watch_95_percent_api",
                  "signature": "(self)",
                  "docstring": "95% API: One line starts watching.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 99
                },
                {
                  "name": "test_watch_callback_parameters",
                  "signature": "(self)",
                  "docstring": "Callback receives (Conversation, List[Message]) parameters.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 121
                },
                {
                  "name": "test_message_type_filtering",
                  "signature": "(self)",
                  "docstring": "Optional message_types parameter filters messages.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 152
                },
                {
                  "name": "test_file_rotation_handling",
                  "signature": "(self)",
                  "docstring": "Handles file rotation gracefully.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 177
                },
                {
                  "name": "test_watch_performance",
                  "signature": "(self)",
                  "docstring": "Handles large files efficiently.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 209
                },
                {
                  "name": "test_error_handling",
                  "signature": "(self)",
                  "docstring": "Graceful error handling for malformed JSON.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 250
                }
              ],
              "attributes": [],
              "properties": [],
              "class_variables": [],
              "line_number": 76
            },
            {
              "name": "TestWatchDomainSOLID",
              "bases": [],
              "docstring": "Test SOLID principles compliance.",
              "methods": [
                {
                  "name": "test_single_responsibility",
                  "signature": "(self)",
                  "docstring": "watch() has single responsibility: file watching.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 290
                },
                {
                  "name": "test_open_closed_principle",
                  "signature": "(self)",
                  "docstring": "Can extend behavior without modifying watch() function.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 301
                },
                {
                  "name": "test_dependency_inversion",
                  "signature": "(self)",
                  "docstring": "watch() depends on abstractions, not concrete implementations.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 309
                }
              ],
              "attributes": [],
              "properties": [],
              "class_variables": [],
              "line_number": 287
            },
            {
              "name": "TestWatchDomainDDD",
              "bases": [],
              "docstring": "Test Domain-Driven Design principles.",
              "methods": [
                {
                  "name": "test_domain_boundaries",
                  "signature": "(self)",
                  "docstring": "Watch domain has clear boundaries.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 321
                },
                {
                  "name": "test_ubiquitous_language",
                  "signature": "(self)",
                  "docstring": "Uses domain language consistently.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 330
                }
              ],
              "attributes": [],
              "properties": [],
              "class_variables": [],
              "line_number": 318
            },
            {
              "name": "TestWatch95PercentPrinciple",
              "bases": [],
              "docstring": "Test 95/5 development principle compliance.",
              "methods": [
                {
                  "name": "test_95_percent_api_simplicity",
                  "signature": "(self)",
                  "docstring": "95% use case requires  3 lines of code.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 343
                },
                {
                  "name": "test_5_percent_advanced_features",
                  "signature": "(self)",
                  "docstring": "5% use case has advanced features available.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 352
                }
              ],
              "attributes": [],
              "properties": [],
              "class_variables": [],
              "line_number": 340
            },
            {
              "name": "TestWatchIntegration",
              "bases": [],
              "docstring": "Test integration with other domains.",
              "methods": [
                {
                  "name": "test_parser_domain_integration",
                  "signature": "(self)",
                  "docstring": "Uses parser domain for JSONL parsing.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 366
                },
                {
                  "name": "test_models_domain_integration",
                  "signature": "(self)",
                  "docstring": "Uses models domain for Message objects.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 374
                },
                {
                  "name": "test_hooks_domain_integration",
                  "signature": "(self)",
                  "docstring": "Can be used from hook scripts.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 382
                }
              ],
              "attributes": [],
              "properties": [],
              "class_variables": [],
              "line_number": 363
            }
          ],
          "constants": [
            "REAL_CLAUDE_JSONL",
            "REAL_USER_MESSAGE",
            "REAL_ASSISTANT_MESSAGE"
          ],
          "size": {
            "lines": 388,
            "bytes": 13781
          }
        },
        {
          "file": "tests/test_phase2/conftest.py",
          "path": "tests/test_phase2/conftest.py",
          "module_docstring": "Test infrastructure for Phase 2 hooks testing.\n\nFollowing TDD approach - writing test fixtures FIRST before implementation.",
          "imports": [
            {
              "module": "pytest",
              "alias": null
            },
            {
              "module": "sys",
              "alias": null
            },
            {
              "module": "orjson",
              "alias": null
            },
            {
              "module": "io",
              "from": true,
              "names": [
                "StringIO"
              ]
            },
            {
              "module": "pathlib",
              "from": true,
              "names": [
                "Path"
              ]
            },
            {
              "module": "typing",
              "from": true,
              "names": [
                "Dict",
                "Any",
                "Optional"
              ]
            },
            {
              "module": "contextlib",
              "from": true,
              "names": [
                "contextmanager"
              ]
            },
            {
              "module": "time",
              "alias": null
            }
          ],
          "functions": [
            {
              "name": "mock_stdin",
              "signature": "()",
              "docstring": "Mock stdin with JSON data for testing hook input.\n\nThis simulates how Claude Code sends JSON to hook scripts via stdin.",
              "decorators": [
                "pytest.fixture"
              ],
              "is_async": false,
              "line_number": 82
            },
            {
              "name": "hook_sample",
              "signature": "()",
              "docstring": "Get hook sample data by type.\n\nReturns a function that retrieves sample data for a specific hook type.",
              "decorators": [
                "pytest.fixture"
              ],
              "is_async": false,
              "line_number": 112
            },
            {
              "name": "all_hook_types",
              "signature": "()",
              "docstring": "Get list of all hook types for parametrized tests.",
              "decorators": [
                "pytest.fixture"
              ],
              "is_async": false,
              "line_number": 134
            },
            {
              "name": "real_transcript",
              "signature": "(tmp_path)",
              "docstring": "Create or use a real JSONL transcript file.\n\nChecks for actual transcript from hook-system-v2, otherwise creates test file.",
              "decorators": [
                "pytest.fixture"
              ],
              "is_async": false,
              "line_number": 140
            },
            {
              "name": "capture_exit",
              "signature": "()",
              "docstring": "Capture sys.exit calls for testing.\n\nReturns an ExitCapture object that records exit codes.",
              "decorators": [
                "pytest.fixture"
              ],
              "is_async": false,
              "line_number": 165
            },
            {
              "name": "echo_test_script",
              "signature": "(tmp_path)",
              "docstring": "Create a test hook script for echo pipe testing.\n\nReturns path to a executable Python script that uses hook functions.",
              "decorators": [
                "pytest.fixture"
              ],
              "is_async": false,
              "line_number": 184
            },
            {
              "name": "performance_timer",
              "signature": "()",
              "docstring": "Timer for performance tests.",
              "decorators": [
                "pytest.fixture"
              ],
              "is_async": false,
              "line_number": 205
            }
          ],
          "classes": [],
          "constants": [
            "HOOK_SAMPLES"
          ],
          "size": {
            "lines": 221,
            "bytes": 6542
          }
        },
        {
          "file": "tests/test_phase2/test_hook_exits.py",
          "path": "tests/test_phase2/test_hook_exits.py",
          "module_docstring": "Tests for exit helper functions - TDD approach, tests written FIRST.\n\nSuccess criteria:\n- exit_success() exits with code 0\n- exit_block() exits with code 2 \n- exit_error() exits with code 1\n- Correct stdout/stderr routing\n- Functions are simple ( 3 lines each)",
          "imports": [
            {
              "module": "pytest",
              "alias": null
            },
            {
              "module": "sys",
              "alias": null
            },
            {
              "module": "claude_parser.hooks",
              "from": true,
              "names": [
                "exit_success"
              ]
            },
            {
              "module": "claude_parser.hooks",
              "from": true,
              "names": [
                "exit_success"
              ]
            },
            {
              "module": "claude_parser.hooks",
              "from": true,
              "names": [
                "exit_block"
              ]
            },
            {
              "module": "claude_parser.hooks",
              "from": true,
              "names": [
                "exit_error"
              ]
            },
            {
              "module": "claude_parser.hooks",
              "from": true,
              "names": [
                "exit_success",
                "exit_block",
                "exit_error"
              ]
            },
            {
              "module": "inspect",
              "alias": null
            },
            {
              "module": "claude_parser.hooks",
              "from": true,
              "names": [
                "exit_success"
              ]
            },
            {
              "module": "claude_parser.hooks",
              "from": true,
              "names": [
                "exit_success",
                "exit_block",
                "exit_error"
              ]
            },
            {
              "module": "typing",
              "from": true,
              "names": [
                "NoReturn"
              ]
            },
            {
              "module": "inspect",
              "alias": null
            },
            {
              "module": "claude_parser.hooks",
              "from": true,
              "names": [
                "exit_block"
              ]
            },
            {
              "module": "claude_parser.hooks",
              "from": true,
              "names": [
                "exit_success"
              ]
            },
            {
              "module": "claude_parser",
              "from": true,
              "names": [
                "hooks"
              ]
            }
          ],
          "functions": [
            {
              "name": "test_exit_success_no_message",
              "signature": "(capsys)",
              "docstring": "exit_success() with no message exits cleanly.",
              "decorators": [],
              "is_async": false,
              "line_number": 15
            },
            {
              "name": "test_exit_success_with_message",
              "signature": "(capsys)",
              "docstring": "exit_success() with message writes to stdout.",
              "decorators": [],
              "is_async": false,
              "line_number": 30
            },
            {
              "name": "test_exit_block_with_reason",
              "signature": "(capsys)",
              "docstring": "exit_block() requires reason and exits with code 2.",
              "decorators": [],
              "is_async": false,
              "line_number": 45
            },
            {
              "name": "test_exit_error_with_message",
              "signature": "(capsys)",
              "docstring": "exit_error() exits with code 1 and message to stderr.",
              "decorators": [],
              "is_async": false,
              "line_number": 60
            },
            {
              "name": "test_exit_functions_are_simple",
              "signature": "()",
              "docstring": "Exit functions follow Single Responsibility Principle.",
              "decorators": [],
              "is_async": false,
              "line_number": 75
            },
            {
              "name": "test_exit_success_empty_string",
              "signature": "(capsys)",
              "docstring": "exit_success() with empty string behaves like no message.",
              "decorators": [],
              "is_async": false,
              "line_number": 103
            },
            {
              "name": "test_exit_functions_type_hints",
              "signature": "()",
              "docstring": "Exit functions have proper type hints.",
              "decorators": [],
              "is_async": false,
              "line_number": 118
            },
            {
              "name": "test_exit_block_unicode_reason",
              "signature": "(capsys)",
              "docstring": "exit_block() handles unicode in reason.",
              "decorators": [],
              "is_async": false,
              "line_number": 133
            },
            {
              "name": "test_exit_success_multiline_message",
              "signature": "(capsys)",
              "docstring": "exit_success() handles multiline messages.",
              "decorators": [],
              "is_async": false,
              "line_number": 146
            },
            {
              "name": "test_exit_functions_are_exported",
              "signature": "()",
              "docstring": "Exit functions are properly exported from hooks module.",
              "decorators": [],
              "is_async": false,
              "line_number": 161
            }
          ],
          "classes": [],
          "constants": [],
          "size": {
            "lines": 173,
            "bytes": 5430
          }
        },
        {
          "file": "tests/test_phase2/test_hook_input.py",
          "path": "tests/test_phase2/test_hook_input.py",
          "module_docstring": "Tests for hook_input() function - TDD approach, tests written FIRST.\n\nSuccess criteria:\n- Parse stdin JSON for all 8 hook types\n- Exit with code 1 on invalid JSON\n- Exit with code 1 on missing required fields  \n- Performance < 10ms\n- Single function handles everything (SRP)",
          "imports": [
            {
              "module": "pytest",
              "alias": null
            },
            {
              "module": "sys",
              "alias": null
            },
            {
              "module": "orjson",
              "alias": null
            },
            {
              "module": "time",
              "alias": null
            },
            {
              "module": "io",
              "from": true,
              "names": [
                "StringIO"
              ]
            },
            {
              "module": "claude_parser.hooks",
              "from": true,
              "names": [
                "hook_input"
              ]
            },
            {
              "module": "claude_parser.hooks",
              "from": true,
              "names": [
                "hook_input"
              ]
            },
            {
              "module": "claude_parser.hooks",
              "from": true,
              "names": [
                "hook_input"
              ]
            },
            {
              "module": "claude_parser.hooks",
              "from": true,
              "names": [
                "hook_input"
              ]
            },
            {
              "module": "claude_parser.hooks",
              "from": true,
              "names": [
                "hook_input"
              ]
            },
            {
              "module": "claude_parser.hooks",
              "from": true,
              "names": [
                "hook_input"
              ]
            },
            {
              "module": "claude_parser.hooks",
              "from": true,
              "names": [
                "hook_input"
              ]
            },
            {
              "module": "claude_parser.hooks",
              "from": true,
              "names": [
                "hook_input"
              ]
            },
            {
              "module": "claude_parser.hooks",
              "from": true,
              "names": [
                "hook_input"
              ]
            },
            {
              "module": "claude_parser.hooks",
              "from": true,
              "names": [
                "hook_input"
              ]
            },
            {
              "module": "claude_parser.hooks",
              "from": true,
              "names": [
                "hook_input"
              ]
            },
            {
              "module": "inspect",
              "alias": null
            }
          ],
          "functions": [
            {
              "name": "test_hook_input_parses_valid_json",
              "signature": "(mock_stdin, hook_sample)",
              "docstring": "hook_input() successfully parses valid JSON from stdin.",
              "decorators": [],
              "is_async": false,
              "line_number": 18
            },
            {
              "name": "test_hook_input_all_hook_types",
              "signature": "(mock_stdin, hook_sample, all_hook_types)",
              "docstring": "hook_input() works for ALL 8 hook types with same function.",
              "decorators": [],
              "is_async": false,
              "line_number": 34
            },
            {
              "name": "test_hook_input_invalid_json",
              "signature": "(mock_stdin, capsys)",
              "docstring": "hook_input() exits with code 1 on invalid JSON.",
              "decorators": [],
              "is_async": false,
              "line_number": 48
            },
            {
              "name": "test_hook_input_missing_required_fields",
              "signature": "(mock_stdin, capsys)",
              "docstring": "hook_input() exits with code 1 on missing required fields.",
              "decorators": [],
              "is_async": false,
              "line_number": 65
            },
            {
              "name": "test_hook_input_empty_stdin",
              "signature": "(mock_stdin, capsys)",
              "docstring": "hook_input() handles empty stdin gracefully.",
              "decorators": [],
              "is_async": false,
              "line_number": 87
            },
            {
              "name": "test_hook_input_extra_fields_preserved",
              "signature": "(mock_stdin)",
              "docstring": "hook_input() preserves extra fields for forward compatibility.",
              "decorators": [],
              "is_async": false,
              "line_number": 100
            },
            {
              "name": "test_hook_input_performance",
              "signature": "(mock_stdin, hook_sample, performance_timer)",
              "docstring": "hook_input() completes in < 10ms.",
              "decorators": [],
              "is_async": false,
              "line_number": 122
            },
            {
              "name": "test_hook_input_validates_hook_type",
              "signature": "(mock_stdin, capsys)",
              "docstring": "hook_input() validates hook_event_name is valid type.",
              "decorators": [],
              "is_async": false,
              "line_number": 137
            },
            {
              "name": "test_hook_input_handles_unicode",
              "signature": "(mock_stdin)",
              "docstring": "hook_input() correctly handles unicode in JSON.",
              "decorators": [],
              "is_async": false,
              "line_number": 157
            },
            {
              "name": "test_hook_input_real_claude_format",
              "signature": "(mock_stdin)",
              "docstring": "hook_input() works with actual Claude Code JSON format.",
              "decorators": [],
              "is_async": false,
              "line_number": 176
            },
            {
              "name": "test_hook_input_is_single_responsibility",
              "signature": "()",
              "docstring": "hook_input() follows Single Responsibility Principle.",
              "decorators": [],
              "is_async": false,
              "line_number": 200
            }
          ],
          "classes": [],
          "constants": [],
          "size": {
            "lines": 216,
            "bytes": 6869
          }
        },
        {
          "file": "tests/test_phase2/__init__.py",
          "path": "tests/test_phase2/__init__.py",
          "module_docstring": "Phase 2 test suite for Claude Parser SDK hooks and watching.",
          "imports": [],
          "functions": [],
          "classes": [],
          "constants": [],
          "size": {
            "lines": 1,
            "bytes": 66
          }
        },
        {
          "file": "tests/test_phase2/test_hook_models.py",
          "path": "tests/test_phase2/test_hook_models.py",
          "module_docstring": "Tests for HookData model - TDD approach, tests written FIRST.\n\nSuccess criteria:\n- Single HookData model handles ALL 8 hook types (DRY)\n- Uses pydantic BaseModel with field aliases (no manual parsing)\n- All fields are Optional except core 3 (session_id, transcript_path, hook_event_name)\n- NO isinstance checks needed by users (Liskov Substitution)\n- NO separate classes per hook type (violates DRY)",
          "imports": [
            {
              "module": "pytest",
              "alias": null
            },
            {
              "module": "pathlib",
              "from": true,
              "names": [
                "Path"
              ]
            },
            {
              "module": "claude_parser.hooks.models",
              "from": true,
              "names": [
                "HookData"
              ]
            },
            {
              "module": "claude_parser.hooks.models",
              "from": true,
              "names": [
                "HookData"
              ]
            },
            {
              "module": "claude_parser.hooks.models",
              "from": true,
              "names": [
                "HookData"
              ]
            },
            {
              "module": "claude_parser.hooks.models",
              "from": true,
              "names": [
                "HookData"
              ]
            },
            {
              "module": "pydantic",
              "from": true,
              "names": [
                "ValidationError"
              ]
            },
            {
              "module": "claude_parser.hooks.models",
              "from": true,
              "names": [
                "HookData"
              ]
            },
            {
              "module": "claude_parser.hooks.models",
              "from": true,
              "names": [
                "HookData"
              ]
            },
            {
              "module": "claude_parser.hooks.models",
              "from": true,
              "names": [
                "HookData"
              ]
            },
            {
              "module": "claude_parser.hooks.models",
              "from": true,
              "names": [
                "HookData"
              ]
            },
            {
              "module": "claude_parser.hooks.models",
              "from": true,
              "names": [
                "HookData"
              ]
            },
            {
              "module": "pydantic",
              "from": true,
              "names": [
                "ValidationError"
              ]
            }
          ],
          "functions": [
            {
              "name": "test_single_model_all_hooks",
              "signature": "(hook_sample, all_hook_types)",
              "docstring": "Single HookData model handles ALL 8 hook types (DRY principle).",
              "decorators": [],
              "is_async": false,
              "line_number": 15
            },
            {
              "name": "test_optional_fields_are_none",
              "signature": "()",
              "docstring": "Optional fields default to None when not provided.",
              "decorators": [],
              "is_async": false,
              "line_number": 33
            },
            {
              "name": "test_optional_fields_when_provided",
              "signature": "()",
              "docstring": "Optional fields work correctly when provided.",
              "decorators": [],
              "is_async": false,
              "line_number": 59
            },
            {
              "name": "test_model_is_immutable",
              "signature": "()",
              "docstring": "Models are frozen (immutable) following DDD value object pattern.",
              "decorators": [],
              "is_async": false,
              "line_number": 78
            },
            {
              "name": "test_load_conversation_integration",
              "signature": "(real_transcript)",
              "docstring": "HookData can load conversation using Phase 1 parser.",
              "decorators": [],
              "is_async": false,
              "line_number": 99
            },
            {
              "name": "test_hook_type_property",
              "signature": "()",
              "docstring": "hook_type property provides convenience alias for hook_event_name.",
              "decorators": [],
              "is_async": false,
              "line_number": 116
            },
            {
              "name": "test_all_hook_specific_fields",
              "signature": "()",
              "docstring": "Test hook-specific fields for each hook type.",
              "decorators": [],
              "is_async": false,
              "line_number": 132
            },
            {
              "name": "test_extra_fields_allowed",
              "signature": "()",
              "docstring": "Model allows extra fields for forward compatibility.",
              "decorators": [],
              "is_async": false,
              "line_number": 212
            },
            {
              "name": "test_validation_errors",
              "signature": "()",
              "docstring": "Test that required fields are validated.",
              "decorators": [],
              "is_async": false,
              "line_number": 231
            }
          ],
          "classes": [],
          "constants": [],
          "size": {
            "lines": 259,
            "bytes": 8157
          }
        },
        {
          "file": "tests/test_phase2/test_posttooluse_verification.py",
          "path": "tests/test_phase2/test_posttooluse_verification.py",
          "module_docstring": "Comprehensive PostToolUse verification tests based on Anthropic's hooks.md.\n\nTests the ACTUAL behavior documented in docs/anthropic/hooks.md:\n- PostToolUse runs AFTER tool execution (can't block the tool)\n- Exit code 2 shows stderr to Claude (tool already ran)\n- JSON output with decision=\"block\" prompts Claude with reason\n- additionalContext adds info for Claude to consider\n- Tool response formats vary by tool type",
          "imports": [
            {
              "module": "pytest",
              "alias": null
            },
            {
              "module": "orjson",
              "alias": null
            },
            {
              "module": "sys",
              "alias": null
            },
            {
              "module": "io",
              "from": true,
              "names": [
                "StringIO"
              ]
            },
            {
              "module": "unittest.mock",
              "from": true,
              "names": [
                "patch",
                "MagicMock"
              ]
            },
            {
              "module": "claude_parser.hooks",
              "from": true,
              "names": [
                "hook_input",
                "exit_block",
                "exit_success"
              ]
            },
            {
              "module": "claude_parser.hooks.models",
              "from": true,
              "names": [
                "HookData"
              ]
            },
            {
              "module": "claude_parser.hooks.json_output",
              "from": true,
              "names": [
                "json_output"
              ]
            }
          ],
          "functions": [
            {
              "name": "test_full_posttooluse_integration",
              "signature": "()",
              "docstring": "Complete integration test of PostToolUse flow.",
              "decorators": [],
              "is_async": false,
              "line_number": 498
            }
          ],
          "classes": [
            {
              "name": "TestPostToolUseRealBehavior",
              "bases": [],
              "docstring": "Test PostToolUse as documented in hooks.md.",
              "methods": [
                {
                  "name": "test_posttooluse_runs_after_tool_execution",
                  "signature": "(self)",
                  "docstring": "PostToolUse runs AFTER tool - it cannot block tool execution.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 24
                },
                {
                  "name": "test_exit_code_2_shows_stderr_to_claude",
                  "signature": "(self)",
                  "docstring": "Exit code 2 shows stderr to Claude for automated processing.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 44
                },
                {
                  "name": "test_json_decision_block_prompts_claude",
                  "signature": "(self)",
                  "docstring": "decision='block' automatically prompts Claude with reason.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 62
                },
                {
                  "name": "test_undefined_decision_does_nothing",
                  "signature": "(self)",
                  "docstring": "undefined decision does nothing, reason is ignored.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 82
                },
                {
                  "name": "test_additional_context_for_claude",
                  "signature": "(self)",
                  "docstring": "additionalContext adds information for Claude to consider.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 101
                }
              ],
              "attributes": [],
              "properties": [],
              "class_variables": [],
              "line_number": 21
            },
            {
              "name": "TestPostToolUseToolResponses",
              "bases": [],
              "docstring": "Test various tool_response formats from real tools.",
              "methods": [
                {
                  "name": "test_write_tool_response_format",
                  "signature": "(self)",
                  "docstring": "Write tool returns filePath and success.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 123
                },
                {
                  "name": "test_bash_tool_string_response",
                  "signature": "(self)",
                  "docstring": "Bash tool returns string output directly.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 144
                },
                {
                  "name": "test_edit_tool_list_response",
                  "signature": "(self)",
                  "docstring": "Edit tool returns List[Dict] format.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 162
                },
                {
                  "name": "test_ls_tool_string_response",
                  "signature": "(self)",
                  "docstring": "LS tool returns directory listing as string.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 186
                },
                {
                  "name": "test_grep_tool_string_response",
                  "signature": "(self)",
                  "docstring": "Grep tool returns matches as string.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 204
                }
              ],
              "attributes": [],
              "properties": [],
              "class_variables": [],
              "line_number": 120
            },
            {
              "name": "TestPostToolUseRealScenarios",
              "bases": [],
              "docstring": "Test real-world PostToolUse scenarios from Claude Code.",
              "methods": [
                {
                  "name": "test_lint_after_write",
                  "signature": "(self)",
                  "docstring": "Run linter after Write tool and provide feedback.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 225
                },
                {
                  "name": "test_test_failure_after_edit",
                  "signature": "(self)",
                  "docstring": "Detect test failures after Edit tool.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 257
                },
                {
                  "name": "test_security_scan_after_bash",
                  "signature": "(self)",
                  "docstring": "Security scan after Bash command execution.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 288
                },
                {
                  "name": "test_performance_warning_after_grep",
                  "signature": "(self)",
                  "docstring": "Warn about performance after inefficient Grep.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 311
                }
              ],
              "attributes": [],
              "properties": [],
              "class_variables": [],
              "line_number": 222
            },
            {
              "name": "TestPostToolUseContinueVsBlock",
              "bases": [],
              "docstring": "Test the difference between continue=false and decision=block.",
              "methods": [
                {
                  "name": "test_decision_block_provides_feedback",
                  "signature": "(self)",
                  "docstring": "decision=block provides automated feedback to Claude.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 341
                },
                {
                  "name": "test_continue_false_stops_processing",
                  "signature": "(self)",
                  "docstring": "continue=false stops Claude from processing further.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 354
                },
                {
                  "name": "test_continue_true_with_block",
                  "signature": "(self)",
                  "docstring": "continue=true with decision=block allows feedback.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 371
                }
              ],
              "attributes": [],
              "properties": [],
              "class_variables": [],
              "line_number": 338
            },
            {
              "name": "TestPostToolUseWithMCPTools",
              "bases": [],
              "docstring": "Test PostToolUse with MCP (Model Context Protocol) tools.",
              "methods": [
                {
                  "name": "test_mcp_tool_naming_pattern",
                  "signature": "(self)",
                  "docstring": "MCP tools follow mcp__<server>__<tool> pattern.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 388
                },
                {
                  "name": "test_mcp_filesystem_tool",
                  "signature": "(self)",
                  "docstring": "Test MCP filesystem server tool.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 407
                }
              ],
              "attributes": [],
              "properties": [],
              "class_variables": [],
              "line_number": 385
            },
            {
              "name": "TestPostToolUseEdgeCases",
              "bases": [],
              "docstring": "Test edge cases and error conditions.",
              "methods": [
                {
                  "name": "test_missing_tool_response",
                  "signature": "(self)",
                  "docstring": "Handle missing tool_response field.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 428
                },
                {
                  "name": "test_empty_tool_response",
                  "signature": "(self)",
                  "docstring": "Handle empty tool_response.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 444
                },
                {
                  "name": "test_large_tool_response",
                  "signature": "(self)",
                  "docstring": "Handle very large tool responses.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 460
                },
                {
                  "name": "test_malformed_json_in_response",
                  "signature": "(self)",
                  "docstring": "Handle malformed JSON in tool_response.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 478
                }
              ],
              "attributes": [],
              "properties": [],
              "class_variables": [],
              "line_number": 425
            }
          ],
          "constants": [],
          "size": {
            "lines": 552,
            "bytes": 20951
          }
        },
        {
          "file": "tests/test_phase2/test_tool_response_string_bug.py",
          "path": "tests/test_phase2/test_tool_response_string_bug.py",
          "module_docstring": "Test for critical bug fix: tool_response accepting strings.\n\nBUG REPORT: Claude sends string responses for many tools (LS, Grep, Read, etc.)\nbut claude-parser only accepted Dict or List[Dict].\n\nThis test validates the fix using real Claude output examples.",
          "imports": [
            {
              "module": "orjson",
              "alias": null
            },
            {
              "module": "pytest",
              "alias": null
            },
            {
              "module": "claude_parser.hooks.models",
              "from": true,
              "names": [
                "HookData"
              ]
            }
          ],
          "functions": [],
          "classes": [
            {
              "name": "TestToolResponseStringBug",
              "bases": [],
              "docstring": "Test that tool_response correctly handles all formats.",
              "methods": [
                {
                  "name": "test_ls_tool_returns_string",
                  "signature": "(self)",
                  "docstring": "LS tool returns formatted directory listing as string.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 17
                },
                {
                  "name": "test_grep_tool_returns_string",
                  "signature": "(self)",
                  "docstring": "Grep tool returns search results as string.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 35
                },
                {
                  "name": "test_read_tool_returns_string",
                  "signature": "(self)",
                  "docstring": "Read tool returns file contents as string.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 51
                },
                {
                  "name": "test_bash_tool_returns_string",
                  "signature": "(self)",
                  "docstring": "Bash tool returns command output as string.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 67
                },
                {
                  "name": "test_edit_tool_still_accepts_list_dict",
                  "signature": "(self)",
                  "docstring": "Edit tool can still return List[Dict] format.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 83
                },
                {
                  "name": "test_custom_tool_still_accepts_dict",
                  "signature": "(self)",
                  "docstring": "Custom tools can still return Dict format.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 101
                },
                {
                  "name": "test_tool_response_can_be_none",
                  "signature": "(self)",
                  "docstring": "tool_response can be None/missing.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 120
                },
                {
                  "name": "test_real_world_ls_output",
                  "signature": "(self)",
                  "docstring": "Test with actual LS output from Claude.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 134
                }
              ],
              "attributes": [],
              "properties": [],
              "class_variables": [],
              "line_number": 14
            }
          ],
          "constants": [],
          "size": {
            "lines": 166,
            "bytes": 5914
          }
        },
        {
          "file": "tests/test_phase2/test_json_output.py",
          "path": "tests/test_phase2/test_json_output.py",
          "module_docstring": "Tests for advanced JSON output hook helpers.\n\nTests the json_output() function and advanced.allow()/deny()/ask() methods\nto ensure they produce correct JSON for Claude Code hooks.",
          "imports": [
            {
              "module": "pytest",
              "alias": null
            },
            {
              "module": "sys",
              "alias": null
            },
            {
              "module": "io",
              "from": true,
              "names": [
                "StringIO"
              ]
            },
            {
              "module": "unittest.mock",
              "from": true,
              "names": [
                "patch"
              ]
            },
            {
              "module": "orjson",
              "alias": null
            },
            {
              "module": "claude_parser.hooks",
              "from": true,
              "names": [
                "json_output",
                "advanced"
              ]
            }
          ],
          "functions": [],
          "classes": [
            {
              "name": "TestJsonOutput",
              "bases": [],
              "docstring": "Test the json_output function.",
              "methods": [
                {
                  "name": "test_pretooluse_allow_format",
                  "signature": "(self)",
                  "docstring": "Test PreToolUse produces correct allow format.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 19
                },
                {
                  "name": "test_pretooluse_deny_format",
                  "signature": "(self)",
                  "docstring": "Test PreToolUse produces correct deny format.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 39
                },
                {
                  "name": "test_pretooluse_ask_format",
                  "signature": "(self)",
                  "docstring": "Test PreToolUse produces correct ask format.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 56
                },
                {
                  "name": "test_legacy_approve_to_allow_conversion",
                  "signature": "(self)",
                  "docstring": "Test legacy 'approve' converts to 'allow'.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 72
                },
                {
                  "name": "test_legacy_block_to_deny_conversion",
                  "signature": "(self)",
                  "docstring": "Test legacy 'block' converts to 'deny'.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 86
                },
                {
                  "name": "test_posttooluse_format",
                  "signature": "(self)",
                  "docstring": "Test PostToolUse uses simple format.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 100
                },
                {
                  "name": "test_userpromptsubmit_with_context",
                  "signature": "(self)",
                  "docstring": "Test UserPromptSubmit can add additional context.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 119
                },
                {
                  "name": "test_sessionstart_with_context",
                  "signature": "(self)",
                  "docstring": "Test SessionStart can add context.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 138
                },
                {
                  "name": "test_stop_format",
                  "signature": "(self)",
                  "docstring": "Test Stop hook format.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 153
                },
                {
                  "name": "test_default_format_for_unknown_hook",
                  "signature": "(self)",
                  "docstring": "Test unknown hook types use simple format.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 169
                }
              ],
              "attributes": [],
              "properties": [],
              "class_variables": [],
              "line_number": 16
            },
            {
              "name": "TestAdvancedHelpers",
              "bases": [],
              "docstring": "Test the advanced helper methods.",
              "methods": [
                {
                  "name": "test_advanced_allow",
                  "signature": "(self)",
                  "docstring": "Test advanced.allow() helper.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 191
                },
                {
                  "name": "test_advanced_allow_default_reason",
                  "signature": "(self)",
                  "docstring": "Test advanced.allow() with default reason.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 204
                },
                {
                  "name": "test_advanced_deny",
                  "signature": "(self)",
                  "docstring": "Test advanced.deny() helper.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 216
                },
                {
                  "name": "test_advanced_deny_default_reason",
                  "signature": "(self)",
                  "docstring": "Test advanced.deny() with default reason.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 229
                },
                {
                  "name": "test_advanced_ask",
                  "signature": "(self)",
                  "docstring": "Test advanced.ask() helper.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 241
                },
                {
                  "name": "test_advanced_add_context_userprompt",
                  "signature": "(self)",
                  "docstring": "Test advanced.add_context() for UserPromptSubmit.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 254
                },
                {
                  "name": "test_advanced_add_context_sessionstart",
                  "signature": "(self)",
                  "docstring": "Test advanced.add_context() for SessionStart.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 266
                },
                {
                  "name": "test_advanced_prevent",
                  "signature": "(self)",
                  "docstring": "Test advanced.prevent() for Stop hooks.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 277
                },
                {
                  "name": "test_json_output_always_exits_zero",
                  "signature": "(self)",
                  "docstring": "Test that json_output always exits with code 0.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 289
                },
                {
                  "name": "test_json_output_uses_orjson",
                  "signature": "(self)",
                  "docstring": "Verify we're using orjson for JSON serialization.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 305
                }
              ],
              "attributes": [],
              "properties": [],
              "class_variables": [],
              "line_number": 188
            }
          ],
          "constants": [],
          "size": {
            "lines": 319,
            "bytes": 12896
          }
        },
        {
          "file": "tests/test_phase2/test_claude_format_validation.py",
          "path": "tests/test_phase2/test_claude_format_validation.py",
          "module_docstring": "Test validation against REAL Claude Code JSON format.\n\nThis test ensures our HookData model works with actual Claude Code output,\nnot just theoretical schema.\n\nBug Report: https://github.com/anthropic/claude-code/issues/schema-mismatch",
          "imports": [
            {
              "module": "pytest",
              "alias": null
            },
            {
              "module": "orjson",
              "alias": null
            },
            {
              "module": "claude_parser.hooks.models",
              "from": true,
              "names": [
                "HookData"
              ]
            },
            {
              "module": "pathlib",
              "from": true,
              "names": [
                "Path"
              ]
            }
          ],
          "functions": [],
          "classes": [
            {
              "name": "TestRealClaudeFormatCompatibility",
              "bases": [],
              "docstring": "Test against actual Claude Code JSON samples.",
              "methods": [
                {
                  "name": "test_real_post_tool_use_format",
                  "signature": "(self)",
                  "docstring": "Test real PostToolUse JSON from Claude Code.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 17
                },
                {
                  "name": "test_real_stop_hook_format",
                  "signature": "(self)",
                  "docstring": "Test real Stop hook JSON from Claude Code.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 54
                },
                {
                  "name": "test_real_pre_tool_use_format",
                  "signature": "(self)",
                  "docstring": "Test real PreToolUse JSON from Claude Code.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 70
                },
                {
                  "name": "test_camel_case_and_snake_case_both_work",
                  "signature": "(self)",
                  "docstring": "Test that both camelCase (Claude) and snake_case (Python) work.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 91
                },
                {
                  "name": "test_tool_response_dict_format_still_works",
                  "signature": "(self)",
                  "docstring": "Ensure Dict format still works (backward compatibility).",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 117
                },
                {
                  "name": "test_hook_type_property_alias",
                  "signature": "(self)",
                  "docstring": "Test convenience alias for hook_event_name.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 137
                },
                {
                  "name": "test_load_conversation_integration",
                  "signature": "(self)",
                  "docstring": "Test that load_conversation() works with real paths.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 151
                },
                {
                  "name": "test_json_serialization_roundtrip",
                  "signature": "(self)",
                  "docstring": "Test that we can serialize and deserialize correctly.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 171
                }
              ],
              "attributes": [],
              "properties": [],
              "class_variables": [],
              "line_number": 14
            }
          ],
          "constants": [],
          "size": {
            "lines": 192,
            "bytes": 7475
          }
        }
      ],
      "summary": {
        "file_count": 35,
        "class_count": 53,
        "function_count": 89
      }
    },
    "examples": {
      "files": [
        {
          "file": "examples/sse_streaming.py",
          "path": "examples/sse_streaming.py",
          "module_docstring": "95/5 Solution: SSE Streaming with claude-parser\n\nThis example shows how to create a production-ready SSE endpoint\nwith just a few lines of code. No manual threading needed!",
          "imports": [
            {
              "module": "fastapi",
              "from": true,
              "names": [
                "FastAPI"
              ]
            },
            {
              "module": "fastapi.responses",
              "from": true,
              "names": [
                "StreamingResponse"
              ]
            },
            {
              "module": "sse_starlette.sse",
              "from": true,
              "names": [
                "EventSourceResponse"
              ]
            },
            {
              "module": "pathlib",
              "from": true,
              "names": [
                "Path"
              ]
            },
            {
              "module": "orjson",
              "alias": null
            },
            {
              "module": "claude_parser.watch",
              "from": true,
              "names": [
                "watch_async",
                "stream_for_sse"
              ]
            },
            {
              "module": "asyncio",
              "alias": null
            },
            {
              "module": "uvicorn",
              "alias": null
            },
            {
              "module": "asyncio",
              "alias": null
            }
          ],
          "functions": [],
          "classes": [],
          "constants": [],
          "size": {
            "lines": 213,
            "bytes": 6812
          }
        },
        {
          "file": "examples/todo_manager_demo.py",
          "path": "examples/todo_manager_demo.py",
          "module_docstring": "Demo TodoManager - Show current todos with discovery.",
          "imports": [
            {
              "module": "sys",
              "alias": null
            },
            {
              "module": "pathlib",
              "from": true,
              "names": [
                "Path"
              ]
            },
            {
              "module": "claude_parser.discovery.transcript_finder",
              "from": true,
              "names": [
                "find_current_transcript"
              ]
            },
            {
              "module": "claude_parser.domain.todo",
              "from": true,
              "names": [
                "TodoManager"
              ]
            }
          ],
          "functions": [
            {
              "name": "main",
              "signature": "()",
              "docstring": "Demo TodoManager with current session.",
              "decorators": [],
              "is_async": false,
              "line_number": 13
            }
          ],
          "classes": [],
          "constants": [],
          "size": {
            "lines": 44,
            "bytes": 1188
          }
        },
        {
          "file": "examples/todo_demo.py",
          "path": "examples/todo_demo.py",
          "module_docstring": "Demo TodoManager usage.",
          "imports": [
            {
              "module": "claude_parser.domain.todo",
              "from": true,
              "names": [
                "TodoManager"
              ]
            },
            {
              "module": "pathlib",
              "from": true,
              "names": [
                "Path"
              ]
            }
          ],
          "functions": [
            {
              "name": "main",
              "signature": "()",
              "docstring": "Demo todo operations.",
              "decorators": [],
              "is_async": false,
              "line_number": 6
            }
          ],
          "classes": [],
          "constants": [],
          "size": {
            "lines": 46,
            "bytes": 1532
          }
        },
        {
          "file": "examples/todo_swiper_demo.py",
          "path": "examples/todo_swiper_demo.py",
          "module_docstring": "Demo TodoSwiper - Navigate todo history like Tinder.",
          "imports": [
            {
              "module": "sys",
              "alias": null
            },
            {
              "module": "pathlib",
              "from": true,
              "names": [
                "Path"
              ]
            },
            {
              "module": "claude_parser.discovery.transcript_finder",
              "from": true,
              "names": [
                "find_current_transcript"
              ]
            },
            {
              "module": "claude_parser.domain.todo",
              "from": true,
              "names": [
                "TodoSwiper"
              ]
            }
          ],
          "functions": [
            {
              "name": "main",
              "signature": "()",
              "docstring": "Demo todo history navigation.",
              "decorators": [],
              "is_async": false,
              "line_number": 13
            }
          ],
          "classes": [],
          "constants": [],
          "size": {
            "lines": 47,
            "bytes": 1279
          }
        }
      ],
      "summary": {
        "file_count": 4,
        "class_count": 0,
        "function_count": 3
      }
    },
    "claude_parser": {
      "domains": {
        "core": {
          "responsibility": "Core functionality and main exports",
          "files": [
            {
              "file": "claude_parser/feature_registry.py",
              "path": "claude_parser/feature_registry.py",
              "module_docstring": "Feature Registry - Backward compatibility.\n\nThis file maintains backward compatibility.\nThe actual implementation is in the features/ package.\n\nSOLID: Single import/export responsibility",
              "imports": [
                {
                  "module": "features",
                  "from": true,
                  "names": [
                    "Feature",
                    "FeatureStatus",
                    "FeatureCategory",
                    "FeatureRegistry",
                    "get_registry"
                  ]
                },
                {
                  "module": "features.registry",
                  "from": true,
                  "names": [
                    "save_registry",
                    "load_registry"
                  ]
                }
              ],
              "functions": [],
              "classes": [],
              "constants": [
                "CURRENT_REGISTRY"
              ],
              "size": {
                "lines": 32,
                "bytes": 625
              }
            },
            {
              "file": "claude_parser/timeline.py",
              "path": "claude_parser/timeline.py",
              "module_docstring": "Timeline - Ultra minimal using maximum libraries.\nEvery operation delegates to a library.",
              "imports": [
                {
                  "module": "tempfile",
                  "alias": null
                },
                {
                  "module": "pathlib",
                  "from": true,
                  "names": [
                    "Path"
                  ]
                },
                {
                  "module": "typing",
                  "from": true,
                  "names": [
                    "Dict",
                    "Any",
                    "List"
                  ]
                },
                {
                  "module": "jsonlines",
                  "alias": null
                },
                {
                  "module": "git",
                  "from": true,
                  "names": [
                    "Repo"
                  ]
                },
                {
                  "module": "git.exc",
                  "from": true,
                  "names": [
                    "GitCommandError"
                  ]
                },
                {
                  "module": "jmespath",
                  "alias": null
                },
                {
                  "module": "deepdiff",
                  "from": true,
                  "names": [
                    "DeepDiff"
                  ]
                },
                {
                  "module": "functools",
                  "from": true,
                  "names": [
                    "lru_cache"
                  ]
                },
                {
                  "module": "more_itertools",
                  "from": true,
                  "names": [
                    "flatten"
                  ]
                },
                {
                  "module": "shutil",
                  "alias": null
                }
              ],
              "functions": [],
              "classes": [
                {
                  "name": "Timeline",
                  "bases": [],
                  "docstring": "Pure delegation to libraries - almost no custom logic.",
                  "methods": [
                    {
                      "name": "__init__",
                      "signature": "(self, jsonl_dir: Path)",
                      "docstring": null,
                      "decorators": [],
                      "is_async": false,
                      "line_number": 21
                    },
                    {
                      "name": "_setup_git",
                      "signature": "(self)",
                      "docstring": null,
                      "decorators": [],
                      "is_async": false,
                      "line_number": 29
                    },
                    {
                      "name": "_apply_all",
                      "signature": "(self)",
                      "docstring": null,
                      "decorators": [],
                      "is_async": false,
                      "line_number": 34
                    },
                    {
                      "name": "_commit_event",
                      "signature": "(self, e: Dict)",
                      "docstring": null,
                      "decorators": [],
                      "is_async": false,
                      "line_number": 38
                    },
                    {
                      "name": "checkout",
                      "signature": "(self, point: str) -> Dict[str, Any]",
                      "docstring": null,
                      "decorators": [
                        "lru_cache(maxsize=128)"
                      ],
                      "is_async": false,
                      "line_number": 61
                    },
                    {
                      "name": "branch",
                      "signature": "(self, name: str)",
                      "docstring": null,
                      "decorators": [],
                      "is_async": false,
                      "line_number": 83
                    },
                    {
                      "name": "list_branches",
                      "signature": "(self) -> List[str]",
                      "docstring": null,
                      "decorators": [],
                      "is_async": false,
                      "line_number": 86
                    },
                    {
                      "name": "merge",
                      "signature": "(self, branch: str, into: str) -> List[str]",
                      "docstring": null,
                      "decorators": [],
                      "is_async": false,
                      "line_number": 89
                    },
                    {
                      "name": "diff",
                      "signature": "(self, from_point: str, to_point: str) -> Dict",
                      "docstring": null,
                      "decorators": [],
                      "is_async": false,
                      "line_number": 97
                    },
                    {
                      "name": "query",
                      "signature": "(self, expr: str, limit: int) -> List[Dict]",
                      "docstring": null,
                      "decorators": [],
                      "is_async": false,
                      "line_number": 103
                    },
                    {
                      "name": "clear_cache",
                      "signature": "(self)",
                      "docstring": null,
                      "decorators": [],
                      "is_async": false,
                      "line_number": 112
                    }
                  ],
                  "attributes": [],
                  "properties": [],
                  "class_variables": [],
                  "line_number": 18
                }
              ],
              "constants": [],
              "size": {
                "lines": 114,
                "bytes": 3815
              }
            },
            {
              "file": "claude_parser/models.py",
              "path": "claude_parser/models.py",
              "module_docstring": "Message models - Backward compatibility.\n\nThis file maintains backward compatibility.\nThe actual implementation is in the models/ package.\n\nSOLID: Single import/export responsibility",
              "imports": [
                {
                  "module": "models",
                  "from": true,
                  "names": [
                    "MessageType",
                    "BaseMessage",
                    "Message",
                    "UserMessage",
                    "AssistantMessage",
                    "ToolUse",
                    "ToolResult",
                    "Summary",
                    "SystemMessage",
                    "parse_message"
                  ]
                }
              ],
              "functions": [],
              "classes": [],
              "constants": [],
              "size": {
                "lines": 34,
                "bytes": 580
              }
            },
            {
              "file": "claude_parser/__init__.py",
              "path": "claude_parser/__init__.py",
              "module_docstring": "Claude Parser - Parse Claude Code JSONL files with ease.\n\nThe 95/5 principle: 95% of users just need one line:\n    conv = load(\"session.jsonl\")\n\nFor the remaining 5%, full power is available through the classes.\n\nArchitecture:\n- Domain Driven Design (DDD) with clean separation of concerns\n- SOLID principles throughout the codebase  \n- Uses orjson + pydantic per specification for maximum performance",
              "imports": [
                {
                  "module": "application.conversation_service",
                  "from": true,
                  "names": [
                    "load",
                    "load_large",
                    "load_many",
                    "analyze",
                    "extract_assistant_messages_between"
                  ]
                },
                {
                  "module": "discovery",
                  "from": true,
                  "names": [
                    "find_current_transcript",
                    "find_transcript_for_cwd"
                  ]
                },
                {
                  "module": "domain.entities.conversation",
                  "from": true,
                  "names": [
                    "Conversation"
                  ]
                },
                {
                  "module": "domain.value_objects.metadata",
                  "from": true,
                  "names": [
                    "ConversationMetadata"
                  ]
                },
                {
                  "module": "models",
                  "from": true,
                  "names": [
                    "Message",
                    "MessageType",
                    "BaseMessage",
                    "UserMessage",
                    "AssistantMessage",
                    "Summary",
                    "SystemMessage",
                    "parse_message",
                    "ContentBlock",
                    "ToolUseContent",
                    "ToolResultContent"
                  ]
                },
                {
                  "module": "infrastructure.jsonl_parser",
                  "from": true,
                  "names": [
                    "parse_jsonl",
                    "parse_jsonl_streaming",
                    "count_messages",
                    "validate_jsonl",
                    "validate_claude_format"
                  ]
                },
                {
                  "module": "analytics.analyzer",
                  "from": true,
                  "names": [
                    "TokenCounter",
                    "ConversationAnalytics"
                  ]
                },
                {
                  "module": "pathlib",
                  "from": true,
                  "names": [
                    "Path"
                  ]
                },
                {
                  "module": "typing",
                  "from": true,
                  "names": [
                    "List"
                  ]
                },
                {
                  "module": "toolz",
                  "from": true,
                  "names": [
                    "map",
                    "reduce"
                  ]
                }
              ],
              "functions": [],
              "classes": [],
              "constants": [],
              "size": {
                "lines": 90,
                "bytes": 2400
              }
            }
          ],
          "summary": {
            "file_count": 4,
            "class_count": 1,
            "function_count": 0
          }
        },
        "memory": {
          "responsibility": "Memory domain functionality",
          "files": [
            {
              "file": "claude_parser/memory/exporter.py",
              "path": "claude_parser/memory/exporter.py",
              "module_docstring": "Memory export implementation.\n\nProvides functionality to export Claude conversations to memory systems.\nDesigned to work with mem0 and similar vector databases.",
              "imports": [
                {
                  "module": "typing",
                  "from": true,
                  "names": [
                    "List",
                    "Dict",
                    "Any",
                    "Optional"
                  ]
                },
                {
                  "module": "dataclasses",
                  "from": true,
                  "names": [
                    "dataclass"
                  ]
                },
                {
                  "module": "pathlib",
                  "from": true,
                  "names": [
                    "Path"
                  ]
                },
                {
                  "module": "hashlib",
                  "alias": null
                },
                {
                  "module": "domain.entities.conversation",
                  "from": true,
                  "names": [
                    "Conversation"
                  ]
                },
                {
                  "module": "models",
                  "from": true,
                  "names": [
                    "Message",
                    "AssistantMessage",
                    "UserMessage",
                    "ToolUse",
                    "ToolResult",
                    "Summary"
                  ]
                }
              ],
              "functions": [],
              "classes": [
                {
                  "name": "ConversationMemory",
                  "bases": [],
                  "docstring": "A memory extracted from a conversation.",
                  "methods": [
                    {
                      "name": "generate_id",
                      "signature": "(self) -> str",
                      "docstring": "Generate a unique ID for this memory.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 25
                    }
                  ],
                  "attributes": [],
                  "properties": [],
                  "class_variables": [
                    {
                      "name": "content",
                      "type": "str"
                    },
                    {
                      "name": "metadata",
                      "type": "Dict[str, Any]"
                    },
                    {
                      "name": "embedding_text",
                      "type": "Optional[str]"
                    },
                    {
                      "name": "memory_id",
                      "type": "Optional[str]"
                    }
                  ],
                  "line_number": 17
                },
                {
                  "name": "MemoryExporter",
                  "bases": [],
                  "docstring": "Export conversations to memory format.\n\nThis class provides methods to extract memories from conversations\nand prepare them for storage in vector databases like mem0.\n\nExample:\n    exporter = MemoryExporter()\n    memories = exporter.export(conversation)\n    \n    # Memories are ready for mem0 or other systems\n    for memory in memories:\n        print(f\"Memory: {memory.content[:100]}...\")\n        print(f\"Metadata: {memory.metadata}\")",
                  "methods": [
                    {
                      "name": "__init__",
                      "signature": "(self, chunk_size: int, include_metadata: bool, batch_size: int)",
                      "docstring": "Initialize the memory exporter.\n\nArgs:\n    chunk_size: Maximum characters per memory chunk\n    include_metadata: Whether to include message metadata\n    batch_size: Number of memories to process at once",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 48
                    },
                    {
                      "name": "export",
                      "signature": "(self, conversation: Conversation) -> List[ConversationMemory]",
                      "docstring": "Export a conversation to memory format.\n\nArgs:\n    conversation: The conversation to export\n    \nReturns:\n    List of ConversationMemory objects ready for storage",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 65
                    },
                    {
                      "name": "export_batch",
                      "signature": "(self, conversations: List[Conversation]) -> List[ConversationMemory]",
                      "docstring": "Export multiple conversations in batch.\n\nArgs:\n    conversations: List of conversations to export\n    \nReturns:\n    Combined list of memories from all conversations",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 107
                    },
                    {
                      "name": "_find_response",
                      "signature": "(self, user_msg: UserMessage, assistant_messages: List[AssistantMessage]) -> Optional[AssistantMessage]",
                      "docstring": "Find the assistant response to a user message.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 129
                    },
                    {
                      "name": "_create_memory_pair",
                      "signature": "(self, user_msg: UserMessage, assistant_msg: AssistantMessage) -> ConversationMemory",
                      "docstring": "Create a memory from a user-assistant message pair.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 147
                    },
                    {
                      "name": "_extract_tool_memories",
                      "signature": "(self, conversation: Conversation) -> List[ConversationMemory]",
                      "docstring": "Extract memories from tool uses.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 180
                    },
                    {
                      "name": "_create_summary_memory",
                      "signature": "(self, summary) -> ConversationMemory",
                      "docstring": "Create a memory from a summary.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 223
                    }
                  ],
                  "attributes": [],
                  "properties": [],
                  "class_variables": [],
                  "line_number": 32
                }
              ],
              "constants": [],
              "size": {
                "lines": 246,
                "bytes": 7918
              }
            },
            {
              "file": "claude_parser/memory/__init__.py",
              "path": "claude_parser/memory/__init__.py",
              "module_docstring": "Memory export functionality for Claude Parser.\n\nThis module provides functionality for exporting conversation data\nto memory systems and vector databases.\n\nExample:\n    from claude_parser import load\n    from claude_parser.memory import MemoryExporter\n    \n    conv = load(\"conversation.jsonl\")\n    exporter = MemoryExporter()\n    \n    # Export to memory format\n    memories = exporter.export(conv)\n    \n    # Each memory has content and metadata\n    for memory in memories:\n        print(f\"Memory: {memory.content[:100]}...\")\n        print(f\"ID: {memory.memory_id}\")",
              "imports": [
                {
                  "module": "exporter",
                  "from": true,
                  "names": [
                    "MemoryExporter",
                    "ConversationMemory"
                  ]
                }
              ],
              "functions": [],
              "classes": [],
              "constants": [],
              "size": {
                "lines": 27,
                "bytes": 695
              }
            }
          ],
          "summary": {
            "file_count": 2,
            "class_count": 2,
            "function_count": 0
          }
        },
        "features": {
          "responsibility": "Feature registry and capability tracking",
          "files": [
            {
              "file": "claude_parser/features/formatters.py",
              "path": "claude_parser/features/formatters.py",
              "module_docstring": "Feature formatters for documentation.\n\nSOLID: Single Responsibility - Only formatting\n95/5: Using toolz for functional operations",
              "imports": [
                {
                  "module": "toolz",
                  "from": true,
                  "names": [
                    "pipe",
                    "map"
                  ]
                }
              ],
              "functions": [
                {
                  "name": "to_markdown_table",
                  "signature": "(registry) -> str",
                  "docstring": "Generate markdown table for documentation.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 11
                }
              ],
              "classes": [],
              "constants": [],
              "size": {
                "lines": 28,
                "bytes": 938
              }
            },
            {
              "file": "claude_parser/features/models.py",
              "path": "claude_parser/features/models.py",
              "module_docstring": "Feature models for SDK capability tracking.\n\nSOLID: Single Responsibility - Only data models\nDDD: Value Objects - Immutable feature definitions",
              "imports": [
                {
                  "module": "enum",
                  "from": true,
                  "names": [
                    "Enum"
                  ]
                },
                {
                  "module": "typing",
                  "from": true,
                  "names": [
                    "List",
                    "Optional"
                  ]
                },
                {
                  "module": "pydantic",
                  "from": true,
                  "names": [
                    "BaseModel",
                    "Field"
                  ]
                }
              ],
              "functions": [],
              "classes": [
                {
                  "name": "FeatureStatus",
                  "bases": [
                    "str",
                    "Enum"
                  ],
                  "docstring": "Feature implementation status.",
                  "methods": [],
                  "attributes": [
                    "COMPLETE",
                    "PARTIAL",
                    "BETA",
                    "EXPERIMENTAL",
                    "DEPRECATED",
                    "PLANNED",
                    "NOT_STARTED"
                  ],
                  "properties": [],
                  "class_variables": [],
                  "line_number": 13
                },
                {
                  "name": "FeatureCategory",
                  "bases": [
                    "str",
                    "Enum"
                  ],
                  "docstring": "Feature categories for organization.",
                  "methods": [],
                  "attributes": [
                    "PARSER",
                    "HOOKS",
                    "WATCH",
                    "ANALYTICS",
                    "MEMORY",
                    "TRANSPORT",
                    "FILTERS",
                    "NAVIGATION"
                  ],
                  "properties": [],
                  "class_variables": [],
                  "line_number": 24
                },
                {
                  "name": "Feature",
                  "bases": [
                    "BaseModel"
                  ],
                  "docstring": "Individual feature definition.",
                  "methods": [],
                  "attributes": [
                    "model_config"
                  ],
                  "properties": [],
                  "class_variables": [
                    {
                      "name": "name",
                      "type": "str"
                    },
                    {
                      "name": "category",
                      "type": "FeatureCategory"
                    },
                    {
                      "name": "status",
                      "type": "FeatureStatus"
                    },
                    {
                      "name": "description",
                      "type": "str"
                    },
                    {
                      "name": "api_method",
                      "type": "Optional[str]"
                    },
                    {
                      "name": "version_added",
                      "type": "Optional[str]"
                    },
                    {
                      "name": "version_deprecated",
                      "type": "Optional[str]"
                    },
                    {
                      "name": "removal_version",
                      "type": "Optional[str]"
                    },
                    {
                      "name": "tests_passing",
                      "type": "Optional[int]"
                    },
                    {
                      "name": "tests_total",
                      "type": "Optional[int]"
                    },
                    {
                      "name": "coverage_percent",
                      "type": "Optional[float]"
                    },
                    {
                      "name": "depends_on",
                      "type": "List[str]"
                    },
                    {
                      "name": "migration_guide",
                      "type": "Optional[str]"
                    },
                    {
                      "name": "notes",
                      "type": "Optional[str]"
                    }
                  ],
                  "line_number": 36
                }
              ],
              "constants": [],
              "size": {
                "lines": 67,
                "bytes": 2104
              }
            },
            {
              "file": "claude_parser/features/registry.py",
              "path": "claude_parser/features/registry.py",
              "module_docstring": "Feature registry operations.\n\nSOLID: Single Responsibility - Only registry operations\n95/5: Using toolz for functional operations",
              "imports": [
                {
                  "module": "typing",
                  "from": true,
                  "names": [
                    "List",
                    "Dict"
                  ]
                },
                {
                  "module": "pydantic",
                  "from": true,
                  "names": [
                    "BaseModel",
                    "Field"
                  ]
                },
                {
                  "module": "pendulum",
                  "alias": null
                },
                {
                  "module": "orjson",
                  "alias": null
                },
                {
                  "module": "toolz",
                  "from": true,
                  "names": [
                    "pipe",
                    "filter",
                    "map"
                  ]
                },
                {
                  "module": "models",
                  "from": true,
                  "names": [
                    "Feature",
                    "FeatureStatus",
                    "FeatureCategory"
                  ]
                }
              ],
              "functions": [
                {
                  "name": "save_registry",
                  "signature": "(registry: FeatureRegistry, path: str)",
                  "docstring": "Save registry to JSON file.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 77
                },
                {
                  "name": "load_registry",
                  "signature": "(path: str) -> FeatureRegistry",
                  "docstring": "Load registry from JSON file.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 83
                }
              ],
              "classes": [
                {
                  "name": "FeatureRegistry",
                  "bases": [
                    "BaseModel"
                  ],
                  "docstring": "SDK Feature Registry - Single source of truth for capabilities.",
                  "methods": [
                    {
                      "name": "get_by_status",
                      "signature": "(self, status: FeatureStatus) -> List[Feature]",
                      "docstring": "Get features by status.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 32
                    },
                    {
                      "name": "get_by_category",
                      "signature": "(self, category: FeatureCategory) -> List[Feature]",
                      "docstring": "Get features by category.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 36
                    },
                    {
                      "name": "get_complete_features",
                      "signature": "(self) -> List[Feature]",
                      "docstring": "Get all complete features.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 40
                    },
                    {
                      "name": "get_incomplete_features",
                      "signature": "(self) -> List[Feature]",
                      "docstring": "Get all incomplete features.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 44
                    },
                    {
                      "name": "get_deprecated_features",
                      "signature": "(self) -> List[Feature]",
                      "docstring": "Get deprecated features.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 53
                    },
                    {
                      "name": "to_capability_matrix",
                      "signature": "(self) -> Dict[str, Dict[str, str]]",
                      "docstring": "Generate capability matrix for documentation.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 57
                    }
                  ],
                  "attributes": [
                    "model_config"
                  ],
                  "properties": [],
                  "class_variables": [
                    {
                      "name": "sdk_name",
                      "type": "str"
                    },
                    {
                      "name": "version",
                      "type": "str"
                    },
                    {
                      "name": "updated",
                      "type": "str"
                    },
                    {
                      "name": "features",
                      "type": "List[Feature]"
                    }
                  ],
                  "line_number": 17
                }
              ],
              "constants": [],
              "size": {
                "lines": 87,
                "bytes": 2938
              }
            },
            {
              "file": "claude_parser/features/__init__.py",
              "path": "claude_parser/features/__init__.py",
              "module_docstring": "Feature tracking system for Claude Parser SDK.\n\nSOLID: Separated into single responsibilities\n- models.py: Data models only\n- registry.py: Registry operations only  \n- data.py: Feature data only",
              "imports": [
                {
                  "module": "models",
                  "from": true,
                  "names": [
                    "Feature",
                    "FeatureStatus",
                    "FeatureCategory"
                  ]
                },
                {
                  "module": "registry",
                  "from": true,
                  "names": [
                    "FeatureRegistry"
                  ]
                },
                {
                  "module": "data",
                  "from": true,
                  "names": [
                    "get_current_features",
                    "get_registry"
                  ]
                }
              ],
              "functions": [],
              "classes": [],
              "constants": [],
              "size": {
                "lines": 21,
                "bytes": 499
              }
            },
            {
              "file": "claude_parser/features/feature_data2.py",
              "path": "claude_parser/features/feature_data2.py",
              "module_docstring": "Feature data definitions - Part 2.\n\nSOLID: Single Responsibility - Other domain features\nDRY: Reusable feature definitions",
              "imports": [
                {
                  "module": "models",
                  "from": true,
                  "names": [
                    "Feature",
                    "FeatureStatus",
                    "FeatureCategory"
                  ]
                }
              ],
              "functions": [
                {
                  "name": "get_todo_features",
                  "signature": "()",
                  "docstring": "Get Todo domain features.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 11
                },
                {
                  "name": "get_watch_transport_features",
                  "signature": "()",
                  "docstring": "Get watch and transport features.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 53
                },
                {
                  "name": "get_filter_navigation_features",
                  "signature": "()",
                  "docstring": "Get filter and navigation features.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 82
                },
                {
                  "name": "get_planned_features",
                  "signature": "()",
                  "docstring": "Get planned features.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 109
                }
              ],
              "classes": [],
              "constants": [],
              "size": {
                "lines": 148,
                "bytes": 4998
              }
            },
            {
              "file": "claude_parser/features/feature_data.py",
              "path": "claude_parser/features/feature_data.py",
              "module_docstring": "Feature data definitions - Part 1.\n\nSOLID: Single Responsibility - Parser and Hooks features\nDRY: Reusable feature definitions",
              "imports": [
                {
                  "module": "models",
                  "from": true,
                  "names": [
                    "Feature",
                    "FeatureStatus",
                    "FeatureCategory"
                  ]
                }
              ],
              "functions": [
                {
                  "name": "get_parser_features",
                  "signature": "()",
                  "docstring": "Get parser domain features.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 11
                },
                {
                  "name": "get_hooks_features",
                  "signature": "()",
                  "docstring": "Get hooks domain features.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 39
                }
              ],
              "classes": [],
              "constants": [],
              "size": {
                "lines": 86,
                "bytes": 2698
              }
            },
            {
              "file": "claude_parser/features/data.py",
              "path": "claude_parser/features/data.py",
              "module_docstring": "Feature data aggregator for Claude Parser SDK.\n\nSOLID: Single Responsibility - Only aggregation\nDRY: Imports from split data files",
              "imports": [
                {
                  "module": "toolz",
                  "from": true,
                  "names": [
                    "concat"
                  ]
                },
                {
                  "module": "feature_data",
                  "from": true,
                  "names": [
                    "get_parser_features",
                    "get_hooks_features"
                  ]
                },
                {
                  "module": "feature_data2",
                  "from": true,
                  "names": [
                    "get_todo_features",
                    "get_watch_transport_features",
                    "get_filter_navigation_features",
                    "get_planned_features"
                  ]
                },
                {
                  "module": "registry",
                  "from": true,
                  "names": [
                    "FeatureRegistry"
                  ]
                }
              ],
              "functions": [
                {
                  "name": "get_current_features",
                  "signature": "()",
                  "docstring": "Get all current feature definitions.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 20
                },
                {
                  "name": "get_registry",
                  "signature": "() -> FeatureRegistry",
                  "docstring": "Get the current feature registry.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 32
                }
              ],
              "classes": [],
              "constants": [],
              "size": {
                "lines": 37,
                "bytes": 915
              }
            }
          ],
          "summary": {
            "file_count": 7,
            "class_count": 4,
            "function_count": 11
          }
        },
        "discovery": {
          "responsibility": "Discovery domain functionality",
          "files": [
            {
              "file": "claude_parser/discovery/transcript_finder.py",
              "path": "claude_parser/discovery/transcript_finder.py",
              "module_docstring": "Transcript discovery implementation.\n\nMaps project paths to Claude Code transcript files.\nHandles directory names and finds most recent sessions.",
              "imports": [
                {
                  "module": "pathlib",
                  "from": true,
                  "names": [
                    "Path"
                  ]
                },
                {
                  "module": "typing",
                  "from": true,
                  "names": [
                    "Optional",
                    "List"
                  ]
                },
                {
                  "module": "orjson",
                  "alias": null
                },
                {
                  "module": "toolz",
                  "from": true,
                  "names": [
                    "filter",
                    "map",
                    "compose",
                    "first"
                  ]
                },
                {
                  "module": "more_itertools",
                  "from": true,
                  "names": [
                    "first"
                  ]
                }
              ],
              "functions": [
                {
                  "name": "find_current_transcript",
                  "signature": "() -> Optional[str]",
                  "docstring": "Find transcript for current working directory.\n\n95% use case - auto-detect from where you are.\n\nReturns:\n    Path to most recent transcript file, or None if not found\n    \nExample:\n    transcript = find_current_transcript()\n    if transcript:\n        conv = load(transcript)",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 15
                },
                {
                  "name": "find_transcript_for_cwd",
                  "signature": "(project_path: Path) -> Optional[str]",
                  "docstring": "Find transcript for specific project directory.\n\n5% use case - explicit path for remote plugins, CI/CD, etc.\n\nArgs:\n    project_path: Path to project directory\n    \nReturns:\n    Path to most recent transcript file, or None if not found\n    \nExample:\n    # For remote plugin\n    transcript = find_transcript_for_cwd(Path(\"/remote/project/path\"))\n    \n    # For CI/CD\n    from os import environ\n    transcript = find_transcript_for_cwd(Path(environ[\"PROJECT_ROOT\"]))",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 31
                },
                {
                  "name": "list_all_projects",
                  "signature": "() -> List[dict]",
                  "docstring": "List all Claude projects with their transcripts.\n  \n  Returns project info including both encoded directory names and original paths.\n  Perfect for building project selectors and APIs.\n  \n  Returns:\n      List of project dictionaries with:\n      - original_path: The actual project path (e.g., \"/Volumes/AliDev/ai-projects/memory\")\n      - encoded_name: The directory name in ~/.claude/projects (e.g., \"-Volumes-AliDev-ai-projects-memory\")\n      - transcripts: List of transcript filenames with metadata\n      \n  Example:\n      projects = list_all_projects()\n      # Use functional approach in examples too\n      list(toolz_map(\n          lambda project: print(f\"{project['original_path']} -> {project['encoded_name']}\nTranscripts: {len(project['transcripts'])}\"),\n          projects\n      ))\n  ",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 71
                },
                {
                  "name": "find_project_by_original_path",
                  "signature": "(target_path: str | Path) -> Optional[dict]",
                  "docstring": "Find project info by original path.\n\nArgs:\n    target_path: Original project path (e.g., \"/Volumes/AliDev/ai-projects/memory\")\n    \nReturns:\n    Project dict with encoded_name, transcripts, etc., or None if not found\n    \nExample:\n    project = find_project_by_original_path(\"/Volumes/AliDev/ai-projects/memory\")\n    if project:\n        print(f\"Encoded name: {project['encoded_name']}\")\n        print(f\"Latest transcript: {project['latest_transcript']}\")",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 134
                },
                {
                  "name": "find_project_by_encoded_name",
                  "signature": "(encoded_name: str) -> Optional[dict]",
                  "docstring": "Find project info by encoded directory name.\n\nArgs:\n    encoded_name: Encoded directory name (e.g., \"-Volumes-AliDev-ai-projects-memory\")\n    \nReturns:\n    Project dict with original_path, transcripts, etc., or None if not found\n    \nExample:\n    project = find_project_by_encoded_name(\"-Volumes-AliDev-ai-projects-memory\")\n    if project:\n        print(f\"Original path: {project['original_path']}\")\n        print(f\"Number of transcripts: {len(project['transcripts'])}\")",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 160
                },
                {
                  "name": "_find_matching_project_dir",
                  "signature": "(claude_projects: Path, target_path: Path) -> Optional[Path]",
                  "docstring": "Find Claude project directory by checking cwd in JSONL files.\n\n95/5 approach: Read first line of JSONL to get actual cwd path.\nThis handles all edge cases with dashes in original paths.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 184
                },
                {
                  "name": "_extract_original_path_from_jsonl",
                  "signature": "(jsonl_file: Path) -> Optional[str]",
                  "docstring": "Extract original project path from JSONL file.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 220
                },
                {
                  "name": "_build_transcript_info",
                  "signature": "(jsonl_file: Path) -> dict",
                  "docstring": "Build transcript info dict from JSONL file.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 241
                },
                {
                  "name": "_find_most_recent_transcript",
                  "signature": "(project_dir: Path) -> Optional[Path]",
                  "docstring": "Find the most recently modified .jsonl file in project directory.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 253
                }
              ],
              "classes": [],
              "constants": [],
              "size": {
                "lines": 263,
                "bytes": 9030
              }
            },
            {
              "file": "claude_parser/discovery/__init__.py",
              "path": "claude_parser/discovery/__init__.py",
              "module_docstring": "Discovery domain - Find Claude Code transcript paths.\n\n95/5 Principle:\n- Simple factory function for current CWD\n- Rich options for advanced discovery patterns",
              "imports": [
                {
                  "module": "transcript_finder",
                  "from": true,
                  "names": [
                    "find_current_transcript",
                    "find_transcript_for_cwd",
                    "list_all_projects",
                    "find_project_by_original_path",
                    "find_project_by_encoded_name"
                  ]
                }
              ],
              "functions": [],
              "classes": [],
              "constants": [],
              "size": {
                "lines": 23,
                "bytes": 531
              }
            }
          ],
          "summary": {
            "file_count": 2,
            "class_count": 0,
            "function_count": 9
          }
        },
        "models": {
          "responsibility": "Data models and domain entities",
          "files": [
            {
              "file": "claude_parser/models/user.py",
              "path": "claude_parser/models/user.py",
              "module_docstring": "User message model.\n\nSOLID: Single Responsibility - User messages only\nDDD: Value object for user messages",
              "imports": [
                {
                  "module": "typing",
                  "from": true,
                  "names": [
                    "Optional"
                  ]
                },
                {
                  "module": "pydantic",
                  "from": true,
                  "names": [
                    "Field"
                  ]
                },
                {
                  "module": "base",
                  "from": true,
                  "names": [
                    "BaseMessage",
                    "MessageType"
                  ]
                }
              ],
              "functions": [],
              "classes": [
                {
                  "name": "UserMessage",
                  "bases": [
                    "BaseMessage"
                  ],
                  "docstring": "User message in conversation.",
                  "methods": [],
                  "attributes": [],
                  "properties": [
                    "text_content"
                  ],
                  "class_variables": [
                    {
                      "name": "type",
                      "type": "MessageType"
                    },
                    {
                      "name": "content",
                      "type": "str"
                    },
                    {
                      "name": "cwd",
                      "type": "Optional[str]"
                    },
                    {
                      "name": "git_branch",
                      "type": "Optional[str]"
                    },
                    {
                      "name": "tool_approval",
                      "type": "Optional[str]"
                    }
                  ],
                  "line_number": 14
                }
              ],
              "constants": [],
              "size": {
                "lines": 30,
                "bytes": 787
              }
            },
            {
              "file": "claude_parser/models/system.py",
              "path": "claude_parser/models/system.py",
              "module_docstring": "System message model.\n\nSOLID: Single Responsibility - System messages only\nDDD: Value object for system messages",
              "imports": [
                {
                  "module": "pydantic",
                  "from": true,
                  "names": [
                    "Field"
                  ]
                },
                {
                  "module": "base",
                  "from": true,
                  "names": [
                    "BaseMessage",
                    "MessageType"
                  ]
                }
              ],
              "functions": [],
              "classes": [
                {
                  "name": "SystemMessage",
                  "bases": [
                    "BaseMessage"
                  ],
                  "docstring": "System message (prompts, instructions).",
                  "methods": [],
                  "attributes": [],
                  "properties": [
                    "text_content"
                  ],
                  "class_variables": [
                    {
                      "name": "type",
                      "type": "MessageType"
                    },
                    {
                      "name": "content",
                      "type": "str"
                    }
                  ],
                  "line_number": 13
                }
              ],
              "constants": [],
              "size": {
                "lines": 22,
                "bytes": 508
              }
            },
            {
              "file": "claude_parser/models/assistant.py",
              "path": "claude_parser/models/assistant.py",
              "module_docstring": "Assistant message model.\n\nSOLID: Single Responsibility - Assistant messages only\nDDD: Value object for assistant messages",
              "imports": [
                {
                  "module": "typing",
                  "from": true,
                  "names": [
                    "Optional"
                  ]
                },
                {
                  "module": "pydantic",
                  "from": true,
                  "names": [
                    "Field"
                  ]
                },
                {
                  "module": "base",
                  "from": true,
                  "names": [
                    "BaseMessage",
                    "MessageType"
                  ]
                }
              ],
              "functions": [],
              "classes": [
                {
                  "name": "AssistantMessage",
                  "bases": [
                    "BaseMessage"
                  ],
                  "docstring": "Assistant (Claude) message in conversation.",
                  "methods": [],
                  "attributes": [],
                  "properties": [
                    "text_content",
                    "total_tokens"
                  ],
                  "class_variables": [
                    {
                      "name": "type",
                      "type": "MessageType"
                    },
                    {
                      "name": "content",
                      "type": "str"
                    },
                    {
                      "name": "input_tokens",
                      "type": "Optional[int]"
                    },
                    {
                      "name": "output_tokens",
                      "type": "Optional[int]"
                    },
                    {
                      "name": "cache_read_tokens",
                      "type": "Optional[int]"
                    },
                    {
                      "name": "cache_write_tokens",
                      "type": "Optional[int]"
                    }
                  ],
                  "line_number": 14
                }
              ],
              "constants": [],
              "size": {
                "lines": 39,
                "bytes": 1180
              }
            },
            {
              "file": "claude_parser/models/__init__.py",
              "path": "claude_parser/models/__init__.py",
              "module_docstring": "Message models for Claude Parser.\n\nSOLID: Each model in its own file\nDDD: Clear message types as value objects",
              "imports": [
                {
                  "module": "base",
                  "from": true,
                  "names": [
                    "MessageType",
                    "BaseMessage",
                    "Message"
                  ]
                },
                {
                  "module": "user",
                  "from": true,
                  "names": [
                    "UserMessage"
                  ]
                },
                {
                  "module": "assistant",
                  "from": true,
                  "names": [
                    "AssistantMessage"
                  ]
                },
                {
                  "module": "summary",
                  "from": true,
                  "names": [
                    "Summary"
                  ]
                },
                {
                  "module": "system",
                  "from": true,
                  "names": [
                    "SystemMessage"
                  ]
                },
                {
                  "module": "parser",
                  "from": true,
                  "names": [
                    "parse_message"
                  ]
                },
                {
                  "module": "content",
                  "from": true,
                  "names": [
                    "ContentBlock",
                    "ToolUseContent",
                    "ToolResultContent"
                  ]
                },
                {
                  "module": "usage",
                  "from": true,
                  "names": [
                    "UsageInfo"
                  ]
                }
              ],
              "functions": [],
              "classes": [],
              "constants": [],
              "size": {
                "lines": 30,
                "bytes": 689
              }
            },
            {
              "file": "claude_parser/models/parser.py",
              "path": "claude_parser/models/parser.py",
              "module_docstring": "Message parser utilities.\n\nSOLID: Single Responsibility - Message parsing only\n95/5: Using pydantic for validation, orjson for parsing",
              "imports": [
                {
                  "module": "typing",
                  "from": true,
                  "names": [
                    "Any",
                    "Dict",
                    "Optional",
                    "Union"
                  ]
                },
                {
                  "module": "orjson",
                  "alias": null
                },
                {
                  "module": "infrastructure.logger_config",
                  "from": true,
                  "names": [
                    "logger"
                  ]
                },
                {
                  "module": "toolz",
                  "from": true,
                  "names": [
                    "pipe",
                    "map",
                    "filter",
                    "merge"
                  ]
                },
                {
                  "module": "base",
                  "from": true,
                  "names": [
                    "MessageType",
                    "Message"
                  ]
                },
                {
                  "module": "user",
                  "from": true,
                  "names": [
                    "UserMessage"
                  ]
                },
                {
                  "module": "assistant",
                  "from": true,
                  "names": [
                    "AssistantMessage"
                  ]
                },
                {
                  "module": "summary",
                  "from": true,
                  "names": [
                    "Summary"
                  ]
                },
                {
                  "module": "system",
                  "from": true,
                  "names": [
                    "SystemMessage"
                  ]
                }
              ],
              "functions": [
                {
                  "name": "parse_message",
                  "signature": "(data: Union[str, bytes, Dict[str, Any]]) -> Optional[Message]",
                  "docstring": "Parse a message from various formats.\n\nLIBRARY FIRST: Using orjson for parsing, pydantic for validation.\nHandles both old format (content at top level) and new format (nested in message field).",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 30
                }
              ],
              "classes": [],
              "constants": [
                "MESSAGE_CLASSES"
              ],
              "size": {
                "lines": 113,
                "bytes": 4447
              }
            },
            {
              "file": "claude_parser/models/summary.py",
              "path": "claude_parser/models/summary.py",
              "module_docstring": "Summary message model.\n\nSOLID: Single Responsibility - Summary messages only\nDDD: Value object for conversation summaries",
              "imports": [
                {
                  "module": "typing",
                  "from": true,
                  "names": [
                    "Optional"
                  ]
                },
                {
                  "module": "pydantic",
                  "from": true,
                  "names": [
                    "BaseModel",
                    "Field",
                    "ConfigDict"
                  ]
                },
                {
                  "module": "base",
                  "from": true,
                  "names": [
                    "MessageType"
                  ]
                }
              ],
              "functions": [],
              "classes": [
                {
                  "name": "Summary",
                  "bases": [
                    "BaseModel"
                  ],
                  "docstring": "Summary of conversation segment.\n\nSimplified model based on real JSONL structure:\n{\"type\":\"summary\",\"summary\":\"...\",\"leafUuid\":\"...\"}",
                  "methods": [],
                  "attributes": [
                    "model_config"
                  ],
                  "properties": [
                    "text_content"
                  ],
                  "class_variables": [
                    {
                      "name": "type",
                      "type": "MessageType"
                    },
                    {
                      "name": "summary",
                      "type": "str"
                    },
                    {
                      "name": "leaf_uuid",
                      "type": "Optional[str]"
                    }
                  ],
                  "line_number": 14
                }
              ],
              "constants": [],
              "size": {
                "lines": 34,
                "bytes": 851
              }
            },
            {
              "file": "claude_parser/models/content.py",
              "path": "claude_parser/models/content.py",
              "module_docstring": "Content block models for Claude messages.\n\nBased on analysis of 41,085 real messages showing tool_use/tool_result \nare CONTENT BLOCKS, not message types.\n\nSOLID: Single responsibility for content block structures",
              "imports": [
                {
                  "module": "enum",
                  "from": true,
                  "names": [
                    "Enum"
                  ]
                },
                {
                  "module": "typing",
                  "from": true,
                  "names": [
                    "Union",
                    "Any",
                    "Dict",
                    "Optional"
                  ]
                },
                {
                  "module": "pydantic",
                  "from": true,
                  "names": [
                    "BaseModel",
                    "Field"
                  ]
                }
              ],
              "functions": [],
              "classes": [
                {
                  "name": "ContentBlockType",
                  "bases": [
                    "str",
                    "Enum"
                  ],
                  "docstring": "Content block types discovered from real messages.\n\nDistribution from 41,085 messages:\n- text: 12,285 occurrences\n- tool_use: 9,102 occurrences  \n- tool_result: 9,102 occurrences\n- thinking: 508 occurrences\n- image: 16 occurrences",
                  "methods": [],
                  "attributes": [
                    "TEXT",
                    "TOOL_USE",
                    "TOOL_RESULT",
                    "THINKING",
                    "IMAGE"
                  ],
                  "properties": [],
                  "class_variables": [],
                  "line_number": 15
                },
                {
                  "name": "BaseContentBlock",
                  "bases": [
                    "BaseModel"
                  ],
                  "docstring": "Base class for all content blocks.",
                  "methods": [],
                  "attributes": [],
                  "properties": [],
                  "class_variables": [
                    {
                      "name": "type",
                      "type": "ContentBlockType"
                    }
                  ],
                  "line_number": 32
                },
                {
                  "name": "TextContent",
                  "bases": [
                    "BaseContentBlock"
                  ],
                  "docstring": "Text content block.",
                  "methods": [],
                  "attributes": [],
                  "properties": [],
                  "class_variables": [
                    {
                      "name": "type",
                      "type": "ContentBlockType"
                    },
                    {
                      "name": "text",
                      "type": "str"
                    }
                  ],
                  "line_number": 40
                },
                {
                  "name": "ThinkingContent",
                  "bases": [
                    "BaseContentBlock"
                  ],
                  "docstring": "Claude's thinking process content block.",
                  "methods": [],
                  "attributes": [],
                  "properties": [],
                  "class_variables": [
                    {
                      "name": "type",
                      "type": "ContentBlockType"
                    },
                    {
                      "name": "content",
                      "type": "str"
                    }
                  ],
                  "line_number": 49
                },
                {
                  "name": "ImageContent",
                  "bases": [
                    "BaseContentBlock"
                  ],
                  "docstring": "Image content block.",
                  "methods": [],
                  "attributes": [],
                  "properties": [],
                  "class_variables": [
                    {
                      "name": "type",
                      "type": "ContentBlockType"
                    },
                    {
                      "name": "source",
                      "type": "Dict[str, Any]"
                    }
                  ],
                  "line_number": 58
                },
                {
                  "name": "ToolUseContent",
                  "bases": [
                    "BaseContentBlock"
                  ],
                  "docstring": "Tool use request content block.",
                  "methods": [],
                  "attributes": [],
                  "properties": [],
                  "class_variables": [
                    {
                      "name": "type",
                      "type": "ContentBlockType"
                    },
                    {
                      "name": "id",
                      "type": "str"
                    },
                    {
                      "name": "name",
                      "type": "str"
                    },
                    {
                      "name": "input",
                      "type": "Dict[str, Any]"
                    }
                  ],
                  "line_number": 67
                },
                {
                  "name": "ToolResultContent",
                  "bases": [
                    "BaseContentBlock"
                  ],
                  "docstring": "Tool execution result content block.",
                  "methods": [],
                  "attributes": [],
                  "properties": [],
                  "class_variables": [
                    {
                      "name": "type",
                      "type": "ContentBlockType"
                    },
                    {
                      "name": "tool_use_id",
                      "type": "str"
                    },
                    {
                      "name": "content",
                      "type": "Union[str, list]"
                    },
                    {
                      "name": "is_error",
                      "type": "Optional[bool]"
                    }
                  ],
                  "line_number": 82
                }
              ],
              "constants": [],
              "size": {
                "lines": 105,
                "bytes": 2701
              }
            },
            {
              "file": "claude_parser/models/usage.py",
              "path": "claude_parser/models/usage.py",
              "module_docstring": "Token usage model based on discoveries from 41,085 real messages.\n\nSOLID: Single Responsibility - Token usage tracking only\nDDD: Value object for token usage",
              "imports": [
                {
                  "module": "typing",
                  "from": true,
                  "names": [
                    "Optional",
                    "Dict",
                    "Any"
                  ]
                },
                {
                  "module": "pydantic",
                  "from": true,
                  "names": [
                    "BaseModel",
                    "Field"
                  ]
                }
              ],
              "functions": [],
              "classes": [
                {
                  "name": "CacheCreation",
                  "bases": [
                    "BaseModel"
                  ],
                  "docstring": "Cache creation breakdown.",
                  "methods": [],
                  "attributes": [],
                  "properties": [],
                  "class_variables": [
                    {
                      "name": "ephemeral_5m_input_tokens",
                      "type": "int"
                    },
                    {
                      "name": "ephemeral_1h_input_tokens",
                      "type": "int"
                    }
                  ],
                  "line_number": 12
                },
                {
                  "name": "ServerToolUse",
                  "bases": [
                    "BaseModel"
                  ],
                  "docstring": "Server-side tool usage tracking.",
                  "methods": [],
                  "attributes": [],
                  "properties": [],
                  "class_variables": [
                    {
                      "name": "web_search_requests",
                      "type": "int"
                    }
                  ],
                  "line_number": 19
                },
                {
                  "name": "UsageInfo",
                  "bases": [
                    "BaseModel"
                  ],
                  "docstring": "Complete token usage information from Claude API.\n\nDiscovered from analyzing 17,064 assistant messages.",
                  "methods": [
                    {
                      "name": "to_dict",
                      "signature": "(self) -> Dict[str, Any]",
                      "docstring": "Export usage info as dictionary.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 76
                    }
                  ],
                  "attributes": [],
                  "properties": [
                    "total_tokens",
                    "cache_efficiency",
                    "is_cached",
                    "cache_savings"
                  ],
                  "class_variables": [
                    {
                      "name": "input_tokens",
                      "type": "int"
                    },
                    {
                      "name": "output_tokens",
                      "type": "int"
                    },
                    {
                      "name": "cache_creation_input_tokens",
                      "type": "int"
                    },
                    {
                      "name": "cache_read_input_tokens",
                      "type": "int"
                    },
                    {
                      "name": "cache_creation",
                      "type": "Optional[CacheCreation]"
                    },
                    {
                      "name": "service_tier",
                      "type": "Optional[str]"
                    },
                    {
                      "name": "server_tool_use",
                      "type": "Optional[ServerToolUse]"
                    }
                  ],
                  "line_number": 25
                }
              ],
              "constants": [],
              "size": {
                "lines": 87,
                "bytes": 2909
              }
            },
            {
              "file": "claude_parser/models/base.py",
              "path": "claude_parser/models/base.py",
              "module_docstring": "Base message models.\n\nSOLID: Single Responsibility - Base message structure only\nDDD: Base value object for all messages",
              "imports": [
                {
                  "module": "enum",
                  "from": true,
                  "names": [
                    "Enum"
                  ]
                },
                {
                  "module": "typing",
                  "from": true,
                  "names": [
                    "Optional",
                    "Union",
                    "List",
                    "Any"
                  ]
                },
                {
                  "module": "pydantic",
                  "from": true,
                  "names": [
                    "BaseModel",
                    "Field",
                    "ConfigDict"
                  ]
                },
                {
                  "module": "pendulum",
                  "alias": null
                }
              ],
              "functions": [],
              "classes": [
                {
                  "name": "MessageType",
                  "bases": [
                    "str",
                    "Enum"
                  ],
                  "docstring": "Message types in Claude conversations.\n\nBased on analysis of 41,085 real messages:\n- NO tool_use/tool_result at root level (they're content block types)\n- Only user, assistant, system, summary message types exist",
                  "methods": [],
                  "attributes": [
                    "USER",
                    "ASSISTANT",
                    "SYSTEM",
                    "SUMMARY"
                  ],
                  "properties": [],
                  "class_variables": [],
                  "line_number": 14
                },
                {
                  "name": "BaseMessage",
                  "bases": [
                    "BaseModel"
                  ],
                  "docstring": "Base class for all message types in Claude JSONL format.\n\nBased on analysis of 41,085 real Claude Code messages.\nAll fields match the actual JSONL structure from docs/JSONL_STRUCTURE.md",
                  "methods": [],
                  "attributes": [
                    "model_config"
                  ],
                  "properties": [
                    "text_content",
                    "parsed_timestamp"
                  ],
                  "class_variables": [
                    {
                      "name": "type",
                      "type": "MessageType"
                    },
                    {
                      "name": "uuid",
                      "type": "str"
                    },
                    {
                      "name": "parent_uuid",
                      "type": "Optional[str]"
                    },
                    {
                      "name": "session_id",
                      "type": "str"
                    },
                    {
                      "name": "cwd",
                      "type": "str"
                    },
                    {
                      "name": "git_branch",
                      "type": "str"
                    },
                    {
                      "name": "version",
                      "type": "str"
                    },
                    {
                      "name": "timestamp",
                      "type": "str"
                    },
                    {
                      "name": "is_sidechain",
                      "type": "bool"
                    },
                    {
                      "name": "user_type",
                      "type": "str"
                    },
                    {
                      "name": "is_meta",
                      "type": "Optional[bool]"
                    },
                    {
                      "name": "is_compact_summary",
                      "type": "Optional[bool]"
                    },
                    {
                      "name": "is_api_error_message",
                      "type": "Optional[bool]"
                    },
                    {
                      "name": "tool_use_id",
                      "type": "Optional[str]"
                    },
                    {
                      "name": "tool_use_result",
                      "type": "Optional[Union[dict, str, List[dict]]]"
                    },
                    {
                      "name": "request_id",
                      "type": "Optional[str]"
                    }
                  ],
                  "line_number": 27
                }
              ],
              "constants": [],
              "size": {
                "lines": 140,
                "bytes": 3958
              }
            }
          ],
          "summary": {
            "file_count": 9,
            "class_count": 16,
            "function_count": 1
          }
        },
        "hooks": {
          "responsibility": "Hook system for Claude Code integration",
          "files": [
            {
              "file": "claude_parser/hooks/models.py",
              "path": "claude_parser/hooks/models.py",
              "module_docstring": "Hook data models for Claude Code hooks.\n\nFollowing DRY principle: Single model for ALL 8 hook types.\nNo subclasses, no isinstance checks needed.",
              "imports": [
                {
                  "module": "typing",
                  "from": true,
                  "names": [
                    "Optional",
                    "Dict",
                    "Any",
                    "Literal",
                    "Union",
                    "List"
                  ]
                },
                {
                  "module": "pydantic",
                  "from": true,
                  "names": [
                    "BaseModel",
                    "Field",
                    "ConfigDict"
                  ]
                },
                {
                  "module": "claude_parser",
                  "from": true,
                  "names": [
                    "load"
                  ]
                }
              ],
              "functions": [],
              "classes": [
                {
                  "name": "HookData",
                  "bases": [
                    "BaseModel"
                  ],
                  "docstring": "Universal hook data model (DRY principle).\n\nSingle model handles ALL 8 Claude Code hook types.\nImmutable value object following DDD principles.\n\nExample:\n    data = HookData(**json_from_stdin)\n    print(data.hook_type)  # Works for any hook\n    print(data.tool_name)  # None if not a tool hook",
                  "methods": [
                    {
                      "name": "load_conversation",
                      "signature": "(self) -> Any",
                      "docstring": "Load the conversation from transcript_path.\n\nIntegration point with Parser domain (Phase 1).\nEnables hooks to access conversation history.\n\nReturns:\n    Conversation object from the transcript file\n    \nExample:\n    data = hook_input()\n    conv = data.load_conversation()\n    recent = conv.messages_before_summary(10)",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 72
                    }
                  ],
                  "attributes": [
                    "model_config"
                  ],
                  "properties": [
                    "hook_type"
                  ],
                  "class_variables": [
                    {
                      "name": "session_id",
                      "type": "str"
                    },
                    {
                      "name": "transcript_path",
                      "type": "str"
                    },
                    {
                      "name": "cwd",
                      "type": "str"
                    },
                    {
                      "name": "hook_event_name",
                      "type": "HookEventType"
                    },
                    {
                      "name": "tool_name",
                      "type": "Optional[str]"
                    },
                    {
                      "name": "tool_input",
                      "type": "Optional[Dict[str, Any]]"
                    },
                    {
                      "name": "tool_response",
                      "type": "Optional[Union[str, Dict[str, Any], List[Dict[str, Any]]]]"
                    },
                    {
                      "name": "prompt",
                      "type": "Optional[str]"
                    },
                    {
                      "name": "message",
                      "type": "Optional[str]"
                    },
                    {
                      "name": "stop_hook_active",
                      "type": "Optional[bool]"
                    },
                    {
                      "name": "trigger",
                      "type": "Optional[str]"
                    },
                    {
                      "name": "custom_instructions",
                      "type": "Optional[str]"
                    },
                    {
                      "name": "source",
                      "type": "Optional[str]"
                    }
                  ],
                  "line_number": 23
                }
              ],
              "constants": [],
              "size": {
                "lines": 87,
                "bytes": 3105
              }
            },
            {
              "file": "claude_parser/hooks/__init__.py",
              "path": "claude_parser/hooks/__init__.py",
              "module_docstring": "Claude Parser SDK - Hooks Domain.\n\nProvides helpers for Claude Code hook scripts.\n95% use case: 3 lines to handle any hook.\n\nExample:\n    from claude_parser.hooks import hook_input, exit_block, exit_success\n    \n    data = hook_input()\n    if data.tool_name == \"Write\": exit_block(\"No writes\")\n    exit_success()",
              "imports": [
                {
                  "module": "input",
                  "from": true,
                  "names": [
                    "hook_input"
                  ]
                },
                {
                  "module": "models",
                  "from": true,
                  "names": [
                    "HookData"
                  ]
                },
                {
                  "module": "exits",
                  "from": true,
                  "names": [
                    "exit_success",
                    "exit_block",
                    "exit_error"
                  ]
                },
                {
                  "module": "json_output",
                  "from": true,
                  "names": [
                    "json_output",
                    "advanced"
                  ]
                }
              ],
              "functions": [],
              "classes": [],
              "constants": [],
              "size": {
                "lines": 38,
                "bytes": 773
              }
            },
            {
              "file": "claude_parser/hooks/json_output.py",
              "path": "claude_parser/hooks/json_output.py",
              "module_docstring": "Advanced JSON output for Claude Code hooks.\n\nThis module provides the 5% advanced API for users who need\nstructured JSON responses for specific hook types.\n\n95% of users should use the simple exit_success/exit_block functions.",
              "imports": [
                {
                  "module": "sys",
                  "alias": null
                },
                {
                  "module": "typing",
                  "from": true,
                  "names": [
                    "Optional",
                    "Dict",
                    "Any"
                  ]
                },
                {
                  "module": "orjson",
                  "alias": null
                },
                {
                  "module": "toolz",
                  "from": true,
                  "names": [
                    "merge",
                    "itemfilter"
                  ]
                }
              ],
              "functions": [
                {
                  "name": "json_output",
                  "signature": "(decision: Optional[str], reason: Optional[str], hook_type: Optional[str], additional_context: Optional[str]) -> None",
                  "docstring": "Output JSON response for Claude Code hooks.\n\nSmart JSON output that matches Claude's expectations for each hook type.\nAutomatically handles the different formats required by different hooks.\n\nArgs:\n    decision: The decision (\"allow\", \"deny\", \"ask\" for PreToolUse, etc.)\n    reason: Explanation for the decision\n    hook_type: The hook event type (auto-detects format)\n    additional_context: For UserPromptSubmit and SessionStart\n    **kwargs: Additional hook-specific fields\n\nExamples:\n    # PreToolUse - uses special format\n    json_output(decision=\"deny\", reason=\"Security\", hook_type=\"PreToolUse\")\n    \n    # UserPromptSubmit - adds context\n    json_output(decision=\"continue\", additional_context=\"Extra info\", \n               hook_type=\"UserPromptSubmit\")\n    \n    # PostToolUse - simple format\n    json_output(decision=\"continue\", reason=\"OK\", hook_type=\"PostToolUse\")",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 15
                }
              ],
              "classes": [
                {
                  "name": "AdvancedHooks",
                  "bases": [],
                  "docstring": "Advanced hook-specific convenience methods (5% API).\n\nThese are optional convenience methods that generate the correct\nJSON for specific hook types. Most users should use the basic\nexit_success/exit_block functions instead.",
                  "methods": [
                    {
                      "name": "allow",
                      "signature": "(reason: str) -> None",
                      "docstring": "Allow a PreToolUse request.",
                      "decorators": [
                        "staticmethod"
                      ],
                      "is_async": false,
                      "line_number": 113
                    },
                    {
                      "name": "deny",
                      "signature": "(reason: str) -> None",
                      "docstring": "Deny a PreToolUse request.",
                      "decorators": [
                        "staticmethod"
                      ],
                      "is_async": false,
                      "line_number": 118
                    },
                    {
                      "name": "ask",
                      "signature": "(reason: str) -> None",
                      "docstring": "Ask user for PreToolUse permission.",
                      "decorators": [
                        "staticmethod"
                      ],
                      "is_async": false,
                      "line_number": 123
                    },
                    {
                      "name": "add_context",
                      "signature": "(context: str, hook_type: str) -> None",
                      "docstring": "Add additional context to UserPromptSubmit or SessionStart.",
                      "decorators": [
                        "staticmethod"
                      ],
                      "is_async": false,
                      "line_number": 128
                    },
                    {
                      "name": "prevent",
                      "signature": "(reason: str) -> None",
                      "docstring": "Prevent Stop/SubagentStop from stopping.",
                      "decorators": [
                        "staticmethod"
                      ],
                      "is_async": false,
                      "line_number": 137
                    }
                  ],
                  "attributes": [],
                  "properties": [],
                  "class_variables": [],
                  "line_number": 104
                }
              ],
              "constants": [],
              "size": {
                "lines": 143,
                "bytes": 4952
              }
            },
            {
              "file": "claude_parser/hooks/input.py",
              "path": "claude_parser/hooks/input.py",
              "module_docstring": "Hook input parsing functionality.\n\nSingle Responsibility: Parse JSON from stdin into HookData.\nNo other logic, no side effects beyond exit on error.",
              "imports": [
                {
                  "module": "sys",
                  "alias": null
                },
                {
                  "module": "typing",
                  "from": true,
                  "names": [
                    "NoReturn"
                  ]
                },
                {
                  "module": "orjson",
                  "alias": null
                },
                {
                  "module": "pydantic",
                  "from": true,
                  "names": [
                    "ValidationError"
                  ]
                },
                {
                  "module": "models",
                  "from": true,
                  "names": [
                    "HookData"
                  ]
                }
              ],
              "functions": [
                {
                  "name": "hook_input",
                  "signature": "() -> HookData",
                  "docstring": "Parse hook JSON from stdin.\n\nWorks for ALL 8 Claude Code hook types with zero configuration.\nSingle function, single responsibility.\n\nReturns:\n    HookData: Parsed and validated hook data\n    \nExits:\n    1: On invalid JSON or validation errors\n    \nExample:\n    data = hook_input()  # That's it!\n    print(data.hook_type)\n    print(data.tool_name)",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 15
                }
              ],
              "classes": [],
              "constants": [],
              "size": {
                "lines": 55,
                "bytes": 1548
              }
            },
            {
              "file": "claude_parser/hooks/hook_responses.py",
              "path": "claude_parser/hooks/hook_responses.py",
              "module_docstring": "Hook response models using pydantic - replaces 145 lines with ~30.",
              "imports": [
                {
                  "module": "sys",
                  "alias": null
                },
                {
                  "module": "typing",
                  "from": true,
                  "names": [
                    "Optional",
                    "Literal"
                  ]
                },
                {
                  "module": "pydantic",
                  "from": true,
                  "names": [
                    "BaseModel",
                    "Field"
                  ]
                },
                {
                  "module": "orjson",
                  "alias": null
                },
                {
                  "module": "pydantic",
                  "from": true,
                  "names": [
                    "Field"
                  ]
                }
              ],
              "functions": [],
              "classes": [
                {
                  "name": "HookResponse",
                  "bases": [
                    "BaseModel"
                  ],
                  "docstring": "Base hook response that outputs JSON and exits.",
                  "methods": [
                    {
                      "name": "respond",
                      "signature": "(self) -> None",
                      "docstring": "Output JSON and exit.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 12
                    }
                  ],
                  "attributes": [],
                  "properties": [],
                  "class_variables": [],
                  "line_number": 9
                },
                {
                  "name": "SimpleResponse",
                  "bases": [
                    "HookResponse"
                  ],
                  "docstring": "Simple continue response for most hooks - matches Claude's expected format.",
                  "methods": [],
                  "attributes": [],
                  "properties": [],
                  "class_variables": [
                    {
                      "name": "continue_",
                      "type": "bool"
                    }
                  ],
                  "line_number": 20
                },
                {
                  "name": "PreToolUseResponse",
                  "bases": [
                    "HookResponse"
                  ],
                  "docstring": "PreToolUse specific response.",
                  "methods": [],
                  "attributes": [],
                  "properties": [],
                  "class_variables": [
                    {
                      "name": "hookSpecificOutput",
                      "type": "dict"
                    }
                  ],
                  "line_number": 25
                },
                {
                  "name": "ContextResponse",
                  "bases": [
                    "HookResponse"
                  ],
                  "docstring": "Response with additional context for UserPromptSubmit/SessionStart.",
                  "methods": [],
                  "attributes": [],
                  "properties": [],
                  "class_variables": [
                    {
                      "name": "hookSpecificOutput",
                      "type": "dict"
                    }
                  ],
                  "line_number": 34
                }
              ],
              "constants": [],
              "size": {
                "lines": 39,
                "bytes": 1103
              }
            },
            {
              "file": "claude_parser/hooks/exits.py",
              "path": "claude_parser/hooks/exits.py",
              "module_docstring": "Exit helper functions for Claude Code hooks.\n\nFollowing 95/5 principle: Each function is  3 lines of code.",
              "imports": [
                {
                  "module": "sys",
                  "alias": null
                },
                {
                  "module": "typing",
                  "from": true,
                  "names": [
                    "NoReturn"
                  ]
                },
                {
                  "module": "orjson",
                  "alias": null
                }
              ],
              "functions": [
                {
                  "name": "exit_success",
                  "signature": "(message: str) -> NoReturn",
                  "docstring": "Exit with success code 0 and JSON output for Claude Code.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 11
                },
                {
                  "name": "exit_block",
                  "signature": "(reason: str) -> NoReturn",
                  "docstring": "Exit with blocking code 2.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 17
                },
                {
                  "name": "exit_error",
                  "signature": "(message: str) -> NoReturn",
                  "docstring": "Exit with error code 1.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 23
                }
              ],
              "classes": [],
              "constants": [],
              "size": {
                "lines": 26,
                "bytes": 628
              }
            }
          ],
          "summary": {
            "file_count": 6,
            "class_count": 6,
            "function_count": 5
          }
        },
        "watch": {
          "responsibility": "File watching and monitoring",
          "files": [
            {
              "file": "claude_parser/watch/async_watcher.py",
              "path": "claude_parser/watch/async_watcher.py",
              "module_docstring": "Async watcher implementation - Watch Domain.\n\nSOLID Principles:\n- SRP: Single responsibility - async file watching\n- OCP: Open for extension via callbacks\n- LSP: Can substitute for sync watcher interface\n- ISP: Focused interface - watch_async only\n- DIP: Depends on abstractions (watchfiles library)\n\n95/5 Principle:\n- Uses watchfiles.awatch (NOT custom file polling)\n- Simple async generator interface\n- No manual threading (watchfiles handles it)",
              "imports": [
                {
                  "module": "typing",
                  "from": true,
                  "names": [
                    "AsyncGenerator",
                    "Optional",
                    "List",
                    "Callable"
                  ]
                },
                {
                  "module": "pathlib",
                  "from": true,
                  "names": [
                    "Path"
                  ]
                },
                {
                  "module": "asyncio",
                  "alias": null
                },
                {
                  "module": "watchfiles",
                  "from": true,
                  "names": [
                    "awatch",
                    "Change"
                  ]
                },
                {
                  "module": "loguru",
                  "from": true,
                  "names": [
                    "logger"
                  ]
                },
                {
                  "module": "domain.entities.conversation",
                  "from": true,
                  "names": [
                    "Conversation"
                  ]
                },
                {
                  "module": "infrastructure.message_repository",
                  "from": true,
                  "names": [
                    "JsonlMessageRepository"
                  ]
                },
                {
                  "module": "models",
                  "from": true,
                  "names": [
                    "Message"
                  ]
                }
              ],
              "functions": [],
              "classes": [
                {
                  "name": "AsyncWatcher",
                  "bases": [],
                  "docstring": "Async file watcher following DDD principles.",
                  "methods": [
                    {
                      "name": "__init__",
                      "signature": "(self, repository: Optional[JsonlMessageRepository])",
                      "docstring": "Initialize with repository dependency injection.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 31
                    }
                  ],
                  "attributes": [],
                  "properties": [],
                  "class_variables": [],
                  "line_number": 28
                }
              ],
              "constants": [],
              "size": {
                "lines": 169,
                "bytes": 5978
              }
            },
            {
              "file": "claude_parser/watch/sse_helpers.py",
              "path": "claude_parser/watch/sse_helpers.py",
              "module_docstring": "SSE (Server-Sent Events) helper functions for streaming.\n\n95/5 Principle: Dead simple SSE streaming for web frameworks.",
              "imports": [
                {
                  "module": "typing",
                  "from": true,
                  "names": [
                    "AsyncGenerator",
                    "Optional",
                    "Callable"
                  ]
                },
                {
                  "module": "pathlib",
                  "from": true,
                  "names": [
                    "Path"
                  ]
                },
                {
                  "module": "asyncio",
                  "alias": null
                },
                {
                  "module": "loguru",
                  "from": true,
                  "names": [
                    "logger"
                  ]
                },
                {
                  "module": "orjson",
                  "alias": null
                },
                {
                  "module": "async_watcher",
                  "from": true,
                  "names": [
                    "watch_async"
                  ]
                },
                {
                  "module": "models",
                  "from": true,
                  "names": [
                    "Message"
                  ]
                }
              ],
              "functions": [],
              "classes": [],
              "constants": [],
              "size": {
                "lines": 76,
                "bytes": 2345
              }
            },
            {
              "file": "claude_parser/watch/__init__.py",
              "path": "claude_parser/watch/__init__.py",
              "module_docstring": "Claude Parser SDK - Watch Domain.\n\nProvides file watching for real-time JSONL monitoring.\n95% use case: One line starts watching.\n\nSync Example:\n    from claude_parser.watch import watch\n    \n    def on_new(conv, new_messages):\n        print(f\"Got {len(new_messages)} new messages\")\n    \n    watch(\"session.jsonl\", on_new)  # Blocks, monitors forever\n\nAsync Example:\n    from claude_parser.watch import watch_async\n    \n    async for conv, new_messages in watch_async(\"session.jsonl\"):\n        print(f\"Got {len(new_messages)} new messages\")",
              "imports": [
                {
                  "module": "watcher",
                  "from": true,
                  "names": [
                    "watch"
                  ]
                },
                {
                  "module": "async_watcher",
                  "from": true,
                  "names": [
                    "watch_async"
                  ]
                },
                {
                  "module": "sse_helpers",
                  "from": true,
                  "names": [
                    "stream_for_sse",
                    "create_sse_stream"
                  ]
                }
              ],
              "functions": [],
              "classes": [],
              "constants": [],
              "size": {
                "lines": 33,
                "bytes": 800
              }
            },
            {
              "file": "claude_parser/watch/watcher.py",
              "path": "claude_parser/watch/watcher.py",
              "module_docstring": "Watch domain implementation following 95/5 principle.\n\nSingle Responsibility: File watching with incremental parsing.\nUses watchfiles library for cross-platform file monitoring.",
              "imports": [
                {
                  "module": "typing",
                  "from": true,
                  "names": [
                    "Callable",
                    "Optional",
                    "List",
                    "Set"
                  ]
                },
                {
                  "module": "pathlib",
                  "from": true,
                  "names": [
                    "Path"
                  ]
                },
                {
                  "module": "sys",
                  "alias": null
                },
                {
                  "module": "toolz",
                  "from": true,
                  "names": [
                    "filter",
                    "map"
                  ]
                },
                {
                  "module": "more_itertools",
                  "from": true,
                  "names": [
                    "consume"
                  ]
                },
                {
                  "module": "models.base",
                  "from": true,
                  "names": [
                    "Message"
                  ]
                },
                {
                  "module": "domain.entities.conversation",
                  "from": true,
                  "names": [
                    "Conversation"
                  ]
                },
                {
                  "module": "",
                  "from": true,
                  "names": [
                    "load"
                  ]
                },
                {
                  "module": "watchfiles",
                  "alias": null
                },
                {
                  "module": "functools",
                  "from": true,
                  "names": [
                    "partial"
                  ]
                },
                {
                  "module": "orjson",
                  "alias": null
                },
                {
                  "module": "models",
                  "from": true,
                  "names": [
                    "parse_message"
                  ]
                },
                {
                  "module": "operator",
                  "from": true,
                  "names": [
                    "methodcaller"
                  ]
                }
              ],
              "functions": [
                {
                  "name": "watch",
                  "signature": "(file_path: str, callback: Callable[[Conversation, List[Message]], None], message_types: Optional[List[str]]) -> None",
                  "docstring": "Watch JSONL file for changes and call callback with new messages.\n\nArgs:\n    file_path: Path to JSONL file\n    callback: Function called with (full_conversation, new_messages)\n    message_types: Optional filter [\"user\", \"assistant\", \"tool_use\", etc.]\n\nExample (95% use case):\n    def on_new(conv, new_msgs):\n        print(f\"Got {len(new_msgs)} new messages\")\n    \n    watch(\"session.jsonl\", on_new)  # Blocks, monitors forever",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 63
                },
                {
                  "name": "_process_file_changes",
                  "signature": "(changes, file_path: str, reader, message_type_filter, callback)",
                  "docstring": "Process file changes functionally.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 115
                },
                {
                  "name": "_parse_new_messages",
                  "signature": "(lines: List[str], message_type_filter: Optional[Set[str]]) -> List[Message]",
                  "docstring": "Parse new JSONL lines into Message objects.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 135
                }
              ],
              "classes": [
                {
                  "name": "IncrementalReader",
                  "bases": [],
                  "docstring": "Single Responsibility: Track file reading position.",
                  "methods": [
                    {
                      "name": "__init__",
                      "signature": "(self, file_path: str)",
                      "docstring": null,
                      "decorators": [],
                      "is_async": false,
                      "line_number": 27
                    },
                    {
                      "name": "get_new_lines",
                      "signature": "(self) -> List[str]",
                      "docstring": "Read only new lines since last read.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 32
                    }
                  ],
                  "attributes": [],
                  "properties": [],
                  "class_variables": [],
                  "line_number": 24
                }
              ],
              "constants": [],
              "size": {
                "lines": 160,
                "bytes": 5573
              }
            }
          ],
          "summary": {
            "file_count": 4,
            "class_count": 2,
            "function_count": 3
          }
        },
        "application": {
          "responsibility": "Application domain functionality",
          "files": [
            {
              "file": "claude_parser/application/conversation_service.py",
              "path": "claude_parser/application/conversation_service.py",
              "module_docstring": "Conversation application service.\n\nSOLID:\n- SRP: Single responsibility - conversation use cases\n- DIP: Depends on domain abstractions, not infrastructure\n\n95/5 Principle:\n- Simple factory functions for 95% use cases\n- Rich options for 5% advanced use cases",
              "imports": [
                {
                  "module": "typing",
                  "from": true,
                  "names": [
                    "List",
                    "Optional"
                  ]
                },
                {
                  "module": "pathlib",
                  "from": true,
                  "names": [
                    "Path"
                  ]
                },
                {
                  "module": "toolz",
                  "from": true,
                  "names": [
                    "map"
                  ]
                },
                {
                  "module": "domain.entities.conversation",
                  "from": true,
                  "names": [
                    "Conversation"
                  ]
                },
                {
                  "module": "domain.value_objects.metadata",
                  "from": true,
                  "names": [
                    "ConversationMetadata"
                  ]
                },
                {
                  "module": "domain.services.analyzer",
                  "from": true,
                  "names": [
                    "ConversationAnalyzer"
                  ]
                },
                {
                  "module": "infrastructure.message_repository",
                  "from": true,
                  "names": [
                    "JsonlMessageRepository"
                  ]
                },
                {
                  "module": "models.base",
                  "from": true,
                  "names": [
                    "Message"
                  ]
                },
                {
                  "module": "models.assistant",
                  "from": true,
                  "names": [
                    "AssistantMessage"
                  ]
                },
                {
                  "module": "infrastructure.jsonl_parser",
                  "from": true,
                  "names": [
                    "validate_claude_format"
                  ]
                }
              ],
              "functions": [
                {
                  "name": "load",
                  "signature": "(filepath: str | Path, strict: bool) -> Conversation",
                  "docstring": "Load a Claude conversation from JSONL file.\n\nThis is the 95% use case - dead simple API.\n\nExample:\n    conv = load(\"chat.jsonl\")\n    assistant_msgs = conv.assistant_messages()\n    results = conv.search(\"error\")\n\nArgs:\n    filepath: Path to Claude JSONL file\n    strict: If True, validate that this is a Claude-format JSONL file\n    \nReturns:\n    Conversation object with rich domain behavior\n\nRaises:\n    ValueError: If strict=True and file is not Claude format",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 87
                },
                {
                  "name": "load_large",
                  "signature": "(filepath: str | Path) -> Conversation",
                  "docstring": "Load large conversation files with lazy loading optimization.\n\n5% use case for files > 100MB. Uses lazy-object-proxy to delay \nloading until the conversation data is actually accessed.\n\nArgs:\n    filepath: Path to large Claude JSONL file\n    \nReturns:\n    Conversation proxy that loads lazily on first access",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 120
                },
                {
                  "name": "load_many",
                  "signature": "(filepaths: List[str | Path]) -> List[Conversation]",
                  "docstring": "Load multiple conversations efficiently.\n\n5% use case for batch processing.\n\nArgs:\n    filepaths: List of paths to Claude JSONL files\n    \nReturns:\n    List of conversation objects",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 139
                },
                {
                  "name": "analyze",
                  "signature": "(conversation: Conversation) -> dict",
                  "docstring": "Analyze conversation and return insights.\n\nArgs:\n    conversation: Conversation to analyze\n    \nReturns:\n    Dictionary with conversation statistics and insights",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 155
                },
                {
                  "name": "extract_assistant_messages_between",
                  "signature": "(conversation: Conversation, start_point: str | int, end_point: str | int) -> List[AssistantMessage]",
                  "docstring": "Extract Claude's responses between two conversation points.\n\nArgs:\n    conversation: Conversation to extract from  \n    start_point: Start identifier (UUID, content, or index)\n    end_point: End identifier (UUID, content, or index)\n    \nReturns:\n    Assistant messages in the specified range",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 168
                }
              ],
              "classes": [
                {
                  "name": "ConversationService",
                  "bases": [],
                  "docstring": "Application service for conversation operations.",
                  "methods": [
                    {
                      "name": "__init__",
                      "signature": "(self, repository)",
                      "docstring": null,
                      "decorators": [],
                      "is_async": false,
                      "line_number": 28
                    },
                    {
                      "name": "load_conversation",
                      "signature": "(self, filepath: str | Path) -> Conversation",
                      "docstring": "Load conversation from JSONL file.\n\nThis is the main factory method following 95/5 principle.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 31
                    },
                    {
                      "name": "analyze_conversation",
                      "signature": "(self, conversation: Conversation) -> dict",
                      "docstring": "Get conversation analysis.\n\nUse case: Generate insights and statistics.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 49
                    },
                    {
                      "name": "extract_assistant_conversation_segment",
                      "signature": "(self, conversation: Conversation, start_point: str | int, end_point: str | int) -> List[AssistantMessage]",
                      "docstring": "Extract assistant messages between two conversation points.\n\nUse case: Get Claude's responses in a specific timeframe or context.\n\nArgs:\n    conversation: The conversation to extract from\n    start_point: UUID, content substring, or message index for start\n    end_point: UUID, content substring, or message index for end\n    \nReturns:\n    List of assistant messages in the range",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 57
                    },
                    {
                      "name": "get_repository_errors",
                      "signature": "(self) -> List[tuple]",
                      "docstring": "Get any parsing errors from the last load operation.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 78
                    }
                  ],
                  "attributes": [],
                  "properties": [],
                  "class_variables": [],
                  "line_number": 25
                }
              ],
              "constants": [],
              "size": {
                "lines": 186,
                "bytes": 5934
              }
            },
            {
              "file": "claude_parser/application/__init__.py",
              "path": "claude_parser/application/__init__.py",
              "module_docstring": "Application layer - Use cases and API.\n\nFollowing DDD:\n- Application Services: Orchestrate domain operations\n- Use Cases: Business workflows\n- DTOs: Data transfer objects for external interfaces",
              "imports": [],
              "functions": [],
              "classes": [],
              "constants": [],
              "size": {
                "lines": 8,
                "bytes": 202
              }
            },
            {
              "file": "claude_parser/application/sse_service.py",
              "path": "claude_parser/application/sse_service.py",
              "module_docstring": "Streaming Service - Application Layer.\n\nProvides backend-agnostic streaming using watch domain.\nWorks with any async framework (FastAPI, Sanic, aiohttp, Quart, etc).\n\nSOLID:\n- SRP: Single responsibility - message streaming\n- DIP: Depends on watch domain abstractions\n- OCP: Open for extension via formatters",
              "imports": [
                {
                  "module": "typing",
                  "from": true,
                  "names": [
                    "AsyncGenerator",
                    "Optional",
                    "Callable",
                    "Dict",
                    "Any",
                    "Union"
                  ]
                },
                {
                  "module": "pathlib",
                  "from": true,
                  "names": [
                    "Path"
                  ]
                },
                {
                  "module": "orjson",
                  "alias": null
                },
                {
                  "module": "enum",
                  "from": true,
                  "names": [
                    "Enum"
                  ]
                },
                {
                  "module": "loguru",
                  "from": true,
                  "names": [
                    "logger"
                  ]
                },
                {
                  "module": "watch",
                  "from": true,
                  "names": [
                    "watch_async"
                  ]
                },
                {
                  "module": "models",
                  "from": true,
                  "names": [
                    "Message"
                  ]
                },
                {
                  "module": "asyncio",
                  "alias": null
                }
              ],
              "functions": [],
              "classes": [
                {
                  "name": "StreamFormat",
                  "bases": [
                    "str",
                    "Enum"
                  ],
                  "docstring": "Supported streaming formats.",
                  "methods": [],
                  "attributes": [
                    "JSON",
                    "SSE",
                    "NDJSON",
                    "RAW"
                  ],
                  "properties": [],
                  "class_variables": [],
                  "line_number": 23
                },
                {
                  "name": "StreamingService",
                  "bases": [],
                  "docstring": "Backend-agnostic streaming service.\n\nWorks with any async Python web framework.",
                  "methods": [
                    {
                      "name": "default_formatter",
                      "signature": "(msg: Message) -> Dict[str, Any]",
                      "docstring": "Default message formatter.",
                      "decorators": [
                        "staticmethod"
                      ],
                      "is_async": false,
                      "line_number": 39
                    }
                  ],
                  "attributes": [],
                  "properties": [],
                  "class_variables": [],
                  "line_number": 31
                }
              ],
              "constants": [],
              "size": {
                "lines": 219,
                "bytes": 7701
              }
            }
          ],
          "summary": {
            "file_count": 3,
            "class_count": 3,
            "function_count": 5
          }
        },
        "infrastructure": {
          "responsibility": "Infrastructure and utilities",
          "files": [
            {
              "file": "claude_parser/infrastructure/logger_config.py",
              "path": "claude_parser/infrastructure/logger_config.py",
              "module_docstring": "Configure loguru to output to stderr only.\n\nThis prevents loguru from breaking hooks that need clean stdout for JSON.",
              "imports": [
                {
                  "module": "sys",
                  "alias": null
                },
                {
                  "module": "loguru",
                  "from": true,
                  "names": [
                    "logger"
                  ]
                }
              ],
              "functions": [],
              "classes": [],
              "constants": [],
              "size": {
                "lines": 13,
                "bytes": 310
              }
            },
            {
              "file": "claude_parser/infrastructure/jsonl_parser.py",
              "path": "claude_parser/infrastructure/jsonl_parser.py",
              "module_docstring": "JSONL parsing infrastructure using functional programming.\n\n95/5 Principle:\n- Uses orjson for fast parsing\n- Uses toolz/more-itertools for functional operations\n- NO manual loops, NO manual state management",
              "imports": [
                {
                  "module": "orjson",
                  "alias": null
                },
                {
                  "module": "pathlib",
                  "from": true,
                  "names": [
                    "Path"
                  ]
                },
                {
                  "module": "typing",
                  "from": true,
                  "names": [
                    "List",
                    "Dict",
                    "Any",
                    "Iterator",
                    "Tuple",
                    "Optional"
                  ]
                },
                {
                  "module": "loguru",
                  "from": true,
                  "names": [
                    "logger"
                  ]
                },
                {
                  "module": "toolz",
                  "from": true,
                  "names": [
                    "filter",
                    "map",
                    "partition",
                    "pipe",
                    "compose",
                    "reduce"
                  ]
                },
                {
                  "module": "more_itertools",
                  "from": true,
                  "names": [
                    "partition",
                    "ilen"
                  ]
                }
              ],
              "functions": [
                {
                  "name": "parse_line_safe",
                  "signature": "(indexed_line: Tuple[int, bytes]) -> Optional[Tuple[str, Any]]",
                  "docstring": "Parse a single line, returning tagged result.\n\nReturns:\n    None if empty line\n    ('success', data) if parsed successfully  \n    ('error', (line_num, error_msg)) if failed",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 25
                },
                {
                  "name": "parse_jsonl",
                  "signature": "(filepath: str | Path) -> List[Dict[str, Any]]",
                  "docstring": "Parse JSONL file using functional approach.\n\nArgs:\n    filepath: Path to JSONL file\n    \nReturns:\n    List of parsed JSON objects\n    \nRaises:\n    FileNotFoundError: If file doesn't exist",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 44
                },
                {
                  "name": "parse_jsonl_streaming",
                  "signature": "(filepath: str | Path) -> Iterator[Dict[str, Any]]",
                  "docstring": "Parse JSONL file with streaming (memory efficient).\n\nUses functional generators for lazy evaluation.\n\nArgs:\n    filepath: Path to JSONL file\n    \nYields:\n    Parsed JSON objects one at a time\n    \nRaises:\n    FileNotFoundError: If file doesn't exist",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 84
                },
                {
                  "name": "count_messages",
                  "signature": "(filepath: str | Path) -> int",
                  "docstring": "Count messages in JSONL file without loading all into memory.\n\nUses functional approach with ilen for counting.\n\nArgs:\n    filepath: Path to JSONL file\n    \nReturns:\n    Number of valid JSON messages",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 114
                },
                {
                  "name": "validate_jsonl",
                  "signature": "(filepath: str | Path) -> Tuple[bool, List[int]]",
                  "docstring": "Validate JSONL file structure functionally.\n\nArgs:\n    filepath: Path to JSONL file\n    \nReturns:\n    Tuple of (is_valid, list_of_error_line_numbers)",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 129
                },
                {
                  "name": "validate_claude_format",
                  "signature": "(filepath: str | Path) -> Tuple[bool, List[str]]",
                  "docstring": "Validate that JSONL file follows Claude Code format.\n\nUses functional approach for validation.\n\nArgs:\n    filepath: Path to JSONL file\n    \nReturns:\n    Tuple of (is_valid, list_of_error_messages)",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 163
                }
              ],
              "classes": [],
              "constants": [],
              "size": {
                "lines": 252,
                "bytes": 7555
              }
            },
            {
              "file": "claude_parser/infrastructure/__init__.py",
              "path": "claude_parser/infrastructure/__init__.py",
              "module_docstring": "Infrastructure layer - External concerns and adapters.\n\nFollowing DDD:\n- Repositories: Concrete data access implementations\n- External Services: File system, JSON parsing, etc.\n- Adapters: Convert between domain and external formats",
              "imports": [],
              "functions": [],
              "classes": [],
              "constants": [],
              "size": {
                "lines": 8,
                "bytes": 240
              }
            },
            {
              "file": "claude_parser/infrastructure/file_utils.py",
              "path": "claude_parser/infrastructure/file_utils.py",
              "module_docstring": "File utilities for DRY principle compliance.\n\nSOLID: Single Responsibility - File operations\nDRY: Shared utilities to eliminate duplication\n95/5: Using pathlib and orjson libraries",
              "imports": [
                {
                  "module": "pathlib",
                  "from": true,
                  "names": [
                    "Path"
                  ]
                },
                {
                  "module": "typing",
                  "from": true,
                  "names": [
                    "Iterator",
                    "Optional",
                    "Any"
                  ]
                },
                {
                  "module": "orjson",
                  "alias": null
                },
                {
                  "module": "logger_config",
                  "from": true,
                  "names": [
                    "logger"
                  ]
                }
              ],
              "functions": [
                {
                  "name": "ensure_file_exists",
                  "signature": "(filepath: Path) -> Path",
                  "docstring": "Ensure file exists, raise FileNotFoundError if not.\n\nDRY: Single place for file existence validation.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 15
                },
                {
                  "name": "read_jsonl_lines",
                  "signature": "(filepath: Path) -> Iterator[tuple[int, bytes]]",
                  "docstring": "Read JSONL file lines with line numbers.\n\nDRY: Single place for file reading pattern.\nYields: (line_number, line_bytes) tuples",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 26
                },
                {
                  "name": "parse_json_safe",
                  "signature": "(data: bytes, line_num: Optional[int]) -> tuple[bool, Any]",
                  "docstring": "Parse JSON safely with error handling.\n\nDRY: Single place for JSON parsing with errors.\nReturns: (success, result_or_error)",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 40
                },
                {
                  "name": "log_parse_results",
                  "signature": "(success_count: int, error_count: int, filepath: Path) -> None",
                  "docstring": "Log parsing results consistently.\n\nDRY: Single place for result logging.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 56
                }
              ],
              "classes": [],
              "constants": [],
              "size": {
                "lines": 64,
                "bytes": 2047
              }
            },
            {
              "file": "claude_parser/infrastructure/message_repository.py",
              "path": "claude_parser/infrastructure/message_repository.py",
              "module_docstring": "Message repository implementation using functional programming.\n\nSOLID:\n- SRP: Single responsibility - data access for messages\n- DIP: Implements abstract repository interface\n\n95/5 Principle:\n- Uses orjson (not json) per specification\n- Uses pydantic for validation per specification\n- NO manual loops, state, or mutations - pure functional",
              "imports": [
                {
                  "module": "typing",
                  "from": true,
                  "names": [
                    "List",
                    "Tuple",
                    "Optional",
                    "Dict",
                    "Any"
                  ]
                },
                {
                  "module": "pathlib",
                  "from": true,
                  "names": [
                    "Path"
                  ]
                },
                {
                  "module": "logger_config",
                  "from": true,
                  "names": [
                    "logger"
                  ]
                },
                {
                  "module": "orjson",
                  "alias": null
                },
                {
                  "module": "pydantic",
                  "from": true,
                  "names": [
                    "ValidationError"
                  ]
                },
                {
                  "module": "toolz",
                  "from": true,
                  "names": [
                    "pipe",
                    "map",
                    "filter",
                    "concat",
                    "partition",
                    "reduce",
                    "merge"
                  ]
                },
                {
                  "module": "more_itertools",
                  "from": true,
                  "names": [
                    "partition"
                  ]
                },
                {
                  "module": "domain.interfaces.protocols",
                  "from": true,
                  "names": [
                    "MessageRepository"
                  ]
                },
                {
                  "module": "domain.value_objects.metadata",
                  "from": true,
                  "names": [
                    "ConversationMetadata"
                  ]
                },
                {
                  "module": "models",
                  "from": true,
                  "names": [
                    "Message"
                  ]
                },
                {
                  "module": "models.parser",
                  "from": true,
                  "names": [
                    "parse_message"
                  ]
                }
              ],
              "functions": [],
              "classes": [
                {
                  "name": "JsonlMessageRepository",
                  "bases": [
                    "MessageRepository"
                  ],
                  "docstring": "Repository for loading messages from JSONL files using functional approach.",
                  "methods": [
                    {
                      "name": "__init__",
                      "signature": "(self)",
                      "docstring": null,
                      "decorators": [],
                      "is_async": false,
                      "line_number": 34
                    },
                    {
                      "name": "load_messages",
                      "signature": "(self, filepath: Path) -> List[Message]",
                      "docstring": "Load and validate messages from JSONL file functionally.\n\nUses orjson and pydantic per specification.\nNo manual loops or state mutations.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 39
                    },
                    {
                      "name": "get_metadata_from_messages",
                      "signature": "(self, messages: List[Message], filepath: Path) -> ConversationMetadata",
                      "docstring": "Extract metadata from loaded messages functionally.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 153
                    },
                    {
                      "name": "get_metadata",
                      "signature": "(self, messages: List[Message], filepath: Path) -> ConversationMetadata",
                      "docstring": "Alias for get_metadata_from_messages for backward compatibility.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 189
                    },
                    {
                      "name": "load_messages_streaming",
                      "signature": "(self, filepath: Path)",
                      "docstring": "Generator for streaming message loading.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 198
                    }
                  ],
                  "attributes": [],
                  "properties": [
                    "errors"
                  ],
                  "class_variables": [],
                  "line_number": 31
                }
              ],
              "constants": [],
              "size": {
                "lines": 201,
                "bytes": 7761
              }
            }
          ],
          "summary": {
            "file_count": 5,
            "class_count": 1,
            "function_count": 10
          }
        },
        "domain": {
          "responsibility": "Domain domain functionality",
          "files": [
            {
              "file": "claude_parser/domain/__init__.py",
              "path": "claude_parser/domain/__init__.py",
              "module_docstring": "Domain layer - Core business logic.\n\nFollowing DDD with proper separation:\n- entities: Core domain models\n- value_objects: Immutable value types\n- services: Domain operations\n- filters: Message filtering strategies\n- interfaces: Domain contracts",
              "imports": [
                {
                  "module": "entities",
                  "from": true,
                  "names": [
                    "Conversation"
                  ]
                },
                {
                  "module": "value_objects",
                  "from": true,
                  "names": [
                    "ConversationMetadata"
                  ]
                },
                {
                  "module": "services",
                  "from": true,
                  "names": [
                    "ConversationAnalyzer",
                    "NavigationService"
                  ]
                },
                {
                  "module": "filters",
                  "from": true,
                  "names": [
                    "ContentFilter",
                    "TypeFilter",
                    "ErrorFilter"
                  ]
                },
                {
                  "module": "interfaces",
                  "from": true,
                  "names": [
                    "MessageFilter",
                    "MessageRepository"
                  ]
                }
              ],
              "functions": [],
              "classes": [],
              "constants": [],
              "size": {
                "lines": 42,
                "bytes": 886
              }
            },
            {
              "file": "claude_parser/domain/filters/error.py",
              "path": "claude_parser/domain/filters/error.py",
              "module_docstring": "Error detection filter.\n\nSOLID: Single Responsibility - Only error detection.\n95/5: Using toolz for functional operations.",
              "imports": [
                {
                  "module": "typing",
                  "from": true,
                  "names": [
                    "List"
                  ]
                },
                {
                  "module": "toolz",
                  "from": true,
                  "names": [
                    "pipe",
                    "map",
                    "filter"
                  ]
                },
                {
                  "module": "models",
                  "from": true,
                  "names": [
                    "Message"
                  ]
                }
              ],
              "functions": [],
              "classes": [
                {
                  "name": "ErrorFilter",
                  "bases": [],
                  "docstring": "Filter messages containing errors.",
                  "methods": [
                    {
                      "name": "matches",
                      "signature": "(self, message: Message) -> bool",
                      "docstring": "Check if message contains error indicators.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 20
                    },
                    {
                      "name": "extract_stack_traces",
                      "signature": "(self, messages: List[Message]) -> List[str]",
                      "docstring": "Extract stack traces from messages using toolz_filter.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 31
                    },
                    {
                      "name": "has_stack_trace",
                      "signature": "(self, message: Message) -> bool",
                      "docstring": "Check if message contains a stack trace.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 40
                    }
                  ],
                  "attributes": [
                    "ERROR_KEYWORDS",
                    "STACK_TRACE_INDICATORS"
                  ],
                  "properties": [],
                  "class_variables": [],
                  "line_number": 14
                }
              ],
              "constants": [],
              "size": {
                "lines": 48,
                "bytes": 1555
              }
            },
            {
              "file": "claude_parser/domain/filters/__init__.py",
              "path": "claude_parser/domain/filters/__init__.py",
              "module_docstring": "Message filters for domain operations.",
              "imports": [
                {
                  "module": "content",
                  "from": true,
                  "names": [
                    "ContentFilter"
                  ]
                },
                {
                  "module": "type",
                  "from": true,
                  "names": [
                    "TypeFilter"
                  ]
                },
                {
                  "module": "error",
                  "from": true,
                  "names": [
                    "ErrorFilter"
                  ]
                }
              ],
              "functions": [],
              "classes": [],
              "constants": [],
              "size": {
                "lines": 7,
                "bytes": 198
              }
            },
            {
              "file": "claude_parser/domain/filters/type.py",
              "path": "claude_parser/domain/filters/type.py",
              "module_docstring": "Type-based message filter.\n\nSOLID: Single Responsibility - Only type filtering.",
              "imports": [
                {
                  "module": "models",
                  "from": true,
                  "names": [
                    "Message"
                  ]
                }
              ],
              "functions": [],
              "classes": [
                {
                  "name": "TypeFilter",
                  "bases": [],
                  "docstring": "Filter messages by type.",
                  "methods": [
                    {
                      "name": "__init__",
                      "signature": "(self, message_type: type)",
                      "docstring": "Initialize with message type to filter.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 13
                    },
                    {
                      "name": "matches",
                      "signature": "(self, message: Message) -> bool",
                      "docstring": "Check if message matches the specified type.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 17
                    }
                  ],
                  "attributes": [],
                  "properties": [],
                  "class_variables": [],
                  "line_number": 10
                }
              ],
              "constants": [],
              "size": {
                "lines": 19,
                "bytes": 484
              }
            },
            {
              "file": "claude_parser/domain/filters/content.py",
              "path": "claude_parser/domain/filters/content.py",
              "module_docstring": "Content-based message filter.\n\nSOLID: Single Responsibility - Only content filtering.\n95/5: Using toolz for functional operations.",
              "imports": [
                {
                  "module": "models",
                  "from": true,
                  "names": [
                    "Message"
                  ]
                }
              ],
              "functions": [],
              "classes": [
                {
                  "name": "ContentFilter",
                  "bases": [],
                  "docstring": "Filter messages by content.",
                  "methods": [
                    {
                      "name": "__init__",
                      "signature": "(self, query: str, case_sensitive: bool)",
                      "docstring": "Initialize with search query.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 14
                    },
                    {
                      "name": "matches",
                      "signature": "(self, message: Message) -> bool",
                      "docstring": "Check if message content matches query.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 19
                    }
                  ],
                  "attributes": [],
                  "properties": [],
                  "class_variables": [],
                  "line_number": 11
                }
              ],
              "constants": [],
              "size": {
                "lines": 24,
                "bytes": 712
              }
            },
            {
              "file": "claude_parser/domain/value_objects/metadata.py",
              "path": "claude_parser/domain/value_objects/metadata.py",
              "module_docstring": "Conversation metadata value object.\n\nSOLID: Single Responsibility - Only metadata representation.\nDDD: Value Object - Immutable, no identity.",
              "imports": [
                {
                  "module": "typing",
                  "from": true,
                  "names": [
                    "Optional"
                  ]
                },
                {
                  "module": "pathlib",
                  "from": true,
                  "names": [
                    "Path"
                  ]
                },
                {
                  "module": "dataclasses",
                  "from": true,
                  "names": [
                    "dataclass"
                  ]
                }
              ],
              "functions": [],
              "classes": [
                {
                  "name": "ConversationMetadata",
                  "bases": [],
                  "docstring": "Value object for conversation metadata.",
                  "methods": [],
                  "attributes": [],
                  "properties": [],
                  "class_variables": [
                    {
                      "name": "session_id",
                      "type": "Optional[str]"
                    },
                    {
                      "name": "filepath",
                      "type": "Path"
                    },
                    {
                      "name": "current_dir",
                      "type": "Optional[str]"
                    },
                    {
                      "name": "git_branch",
                      "type": "Optional[str]"
                    },
                    {
                      "name": "message_count",
                      "type": "int"
                    },
                    {
                      "name": "error_count",
                      "type": "int"
                    }
                  ],
                  "line_number": 14
                }
              ],
              "constants": [],
              "size": {
                "lines": 21,
                "bytes": 495
              }
            },
            {
              "file": "claude_parser/domain/value_objects/__init__.py",
              "path": "claude_parser/domain/value_objects/__init__.py",
              "module_docstring": "Domain value objects.",
              "imports": [
                {
                  "module": "metadata",
                  "from": true,
                  "names": [
                    "ConversationMetadata"
                  ]
                }
              ],
              "functions": [],
              "classes": [],
              "constants": [],
              "size": {
                "lines": 5,
                "bytes": 107
              }
            },
            {
              "file": "claude_parser/domain/todo/swiper.py",
              "path": "claude_parser/domain/todo/swiper.py",
              "module_docstring": "TodoSwiper - Tinder-like navigation through todo history.",
              "imports": [
                {
                  "module": "typing",
                  "from": true,
                  "names": [
                    "List",
                    "Dict",
                    "Optional"
                  ]
                },
                {
                  "module": "rich.console",
                  "from": true,
                  "names": [
                    "Console"
                  ]
                },
                {
                  "module": "rich.panel",
                  "from": true,
                  "names": [
                    "Panel"
                  ]
                },
                {
                  "module": "rich.text",
                  "from": true,
                  "names": [
                    "Text"
                  ]
                },
                {
                  "module": "pendulum",
                  "alias": null
                },
                {
                  "module": "display",
                  "from": true,
                  "names": [
                    "TodoDisplay"
                  ]
                },
                {
                  "module": "io",
                  "from": true,
                  "names": [
                    "StringIO"
                  ]
                },
                {
                  "module": "rich.console",
                  "from": true,
                  "names": [
                    "Console"
                  ]
                },
                {
                  "module": "orjson",
                  "alias": null
                }
              ],
              "functions": [],
              "classes": [
                {
                  "name": "TodoSwiper",
                  "bases": [],
                  "docstring": "Swipe through todo history like Tinder.",
                  "methods": [
                    {
                      "name": "__init__",
                      "signature": "(self, history: List[List[Dict]])",
                      "docstring": "Initialize with todo history (newest first).",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 14
                    },
                    {
                      "name": "swipe_left",
                      "signature": "(self) -> bool",
                      "docstring": "Swipe left = go back in time (older todos).",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 20
                    },
                    {
                      "name": "swipe_right",
                      "signature": "(self) -> bool",
                      "docstring": "Swipe right = go forward in time (newer todos).",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 27
                    },
                    {
                      "name": "can_swipe_left",
                      "signature": "(self) -> bool",
                      "docstring": "Can we go back further in history?",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 34
                    },
                    {
                      "name": "can_swipe_right",
                      "signature": "(self) -> bool",
                      "docstring": "Can we go forward in history?",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 38
                    },
                    {
                      "name": "current",
                      "signature": "(self) -> Dict",
                      "docstring": "Get current todo snapshot with metadata.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 42
                    },
                    {
                      "name": "show",
                      "signature": "(self)",
                      "docstring": "Display current snapshot with Rich.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 89
                    },
                    {
                      "name": "interactive",
                      "signature": "(self)",
                      "docstring": "Interactive swiper mode.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 114
                    },
                    {
                      "name": "from_transcript",
                      "signature": "(transcript_path: str) -> 'TodoSwiper'",
                      "docstring": "Create swiper from transcript file - shows progression of SAME todos.",
                      "decorators": [
                        "staticmethod"
                      ],
                      "is_async": false,
                      "line_number": 141
                    },
                    {
                      "name": "_group_by_content_similarity",
                      "signature": "(snapshots)",
                      "docstring": "Group snapshots by content similarity to track same todo progression.",
                      "decorators": [
                        "staticmethod"
                      ],
                      "is_async": false,
                      "line_number": 178
                    }
                  ],
                  "attributes": [],
                  "properties": [],
                  "class_variables": [],
                  "line_number": 11
                }
              ],
              "constants": [],
              "size": {
                "lines": 209,
                "bytes": 7932
              }
            },
            {
              "file": "claude_parser/domain/todo/__init__.py",
              "path": "claude_parser/domain/todo/__init__.py",
              "module_docstring": "TodoDomain - Parse and manage Claude's TodoWrite format.\n\nDomain Boundaries (DDD):\n- Parser: Parse JSON (no I/O)\n- Storage: File operations (no business logic)  \n- Display: Formatting (no data manipulation)\n- Manager: Orchestrates the above (facade pattern)\n- Swiper: Navigate todo history (timeline integration)",
              "imports": [
                {
                  "module": "parser",
                  "from": true,
                  "names": [
                    "TodoParser"
                  ]
                },
                {
                  "module": "storage",
                  "from": true,
                  "names": [
                    "TodoStorage"
                  ]
                },
                {
                  "module": "display",
                  "from": true,
                  "names": [
                    "TodoDisplay"
                  ]
                },
                {
                  "module": "manager",
                  "from": true,
                  "names": [
                    "TodoManager"
                  ]
                },
                {
                  "module": "swiper",
                  "from": true,
                  "names": [
                    "TodoSwiper"
                  ]
                }
              ],
              "functions": [],
              "classes": [],
              "constants": [],
              "size": {
                "lines": 17,
                "bytes": 566
              }
            },
            {
              "file": "claude_parser/domain/todo/display.py",
              "path": "claude_parser/domain/todo/display.py",
              "module_docstring": "TodoDisplay - Single Responsibility: Formatting.\n\n95% library (Rich), 5% glue.",
              "imports": [
                {
                  "module": "typing",
                  "from": true,
                  "names": [
                    "List",
                    "Dict"
                  ]
                },
                {
                  "module": "rich.tree",
                  "from": true,
                  "names": [
                    "Tree"
                  ]
                }
              ],
              "functions": [],
              "classes": [
                {
                  "name": "TodoDisplay",
                  "bases": [],
                  "docstring": "Format todos for display. No I/O, no data manipulation.",
                  "methods": [
                    {
                      "name": "build_tree",
                      "signature": "(todos: List[Dict]) -> Tree",
                      "docstring": "Build Rich Tree from todos.\n\nArgs:\n    todos: List of todo dictionaries\n    \nReturns:\n    Rich Tree object for display",
                      "decorators": [
                        "staticmethod"
                      ],
                      "is_async": false,
                      "line_number": 13
                    },
                    {
                      "name": "calculate_progress",
                      "signature": "(todos: List[Dict]) -> Dict",
                      "docstring": "Calculate progress metrics.\n\nArgs:\n    todos: List of todo dictionaries\n    \nReturns:\n    Progress metrics dictionary",
                      "decorators": [
                        "staticmethod"
                      ],
                      "is_async": false,
                      "line_number": 50
                    }
                  ],
                  "attributes": [],
                  "properties": [],
                  "class_variables": [],
                  "line_number": 9
                }
              ],
              "constants": [],
              "size": {
                "lines": 75,
                "bytes": 2225
              }
            },
            {
              "file": "claude_parser/domain/todo/parser.py",
              "path": "claude_parser/domain/todo/parser.py",
              "module_docstring": "TodoParser - Single Responsibility: Parse JSON.\n\n95% library (orjson), 5% glue.",
              "imports": [
                {
                  "module": "orjson",
                  "alias": null
                },
                {
                  "module": "typing",
                  "from": true,
                  "names": [
                    "List",
                    "Dict",
                    "Union"
                  ]
                }
              ],
              "functions": [],
              "classes": [
                {
                  "name": "TodoParser",
                  "bases": [],
                  "docstring": "Parse todos from various formats. No I/O, pure functions.",
                  "methods": [
                    {
                      "name": "parse",
                      "signature": "(data: Union[str, bytes]) -> List[Dict]",
                      "docstring": "Parse TodoWrite output into list of todo dicts.\n\nArgs:\n    data: JSON string or bytes from TodoWrite tool\n    \nReturns:\n    List of todo dictionaries\n    \nRaises:\n    orjson.JSONDecodeError: If data is not valid JSON",
                      "decorators": [
                        "staticmethod"
                      ],
                      "is_async": false,
                      "line_number": 13
                    }
                  ],
                  "attributes": [],
                  "properties": [],
                  "class_variables": [],
                  "line_number": 9
                }
              ],
              "constants": [],
              "size": {
                "lines": 34,
                "bytes": 946
              }
            },
            {
              "file": "claude_parser/domain/todo/storage.py",
              "path": "claude_parser/domain/todo/storage.py",
              "module_docstring": "TodoStorage - Single Responsibility: File I/O.\n\n95% library (pathlib, orjson), 5% glue.",
              "imports": [
                {
                  "module": "pathlib",
                  "from": true,
                  "names": [
                    "Path"
                  ]
                },
                {
                  "module": "orjson",
                  "alias": null
                },
                {
                  "module": "typing",
                  "from": true,
                  "names": [
                    "List",
                    "Dict",
                    "Optional"
                  ]
                }
              ],
              "functions": [],
              "classes": [
                {
                  "name": "TodoStorage",
                  "bases": [],
                  "docstring": "Handle todo file storage. No business logic, just I/O.",
                  "methods": [
                    {
                      "name": "__init__",
                      "signature": "(self, session_id: str, agent_id: Optional[str])",
                      "docstring": "Initialize with session and agent IDs.\n\nArgs:\n    session_id: Session UUID from transcript\n    agent_id: Agent UUID (defaults to session_id)",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 13
                    },
                    {
                      "name": "get_path",
                      "signature": "(self) -> Path",
                      "docstring": "Get todo file path.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 24
                    },
                    {
                      "name": "read",
                      "signature": "(self) -> List[Dict]",
                      "docstring": "Read todos from file.\n\nReturns:\n    List of todo dicts, empty list if file doesn't exist",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 29
                    },
                    {
                      "name": "write",
                      "signature": "(self, todos: List[Dict]) -> str",
                      "docstring": "Write todos to file.\n\nArgs:\n    todos: List of todo dictionaries\n    \nReturns:\n    Path to written file",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 42
                    },
                    {
                      "name": "delete",
                      "signature": "(self) -> bool",
                      "docstring": "Delete todo file.\n\nReturns:\n    True if deleted, False if didn't exist",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 60
                    }
                  ],
                  "attributes": [],
                  "properties": [],
                  "class_variables": [],
                  "line_number": 10
                }
              ],
              "constants": [],
              "size": {
                "lines": 70,
                "bytes": 2008
              }
            },
            {
              "file": "claude_parser/domain/todo/manager.py",
              "path": "claude_parser/domain/todo/manager.py",
              "module_docstring": "TodoManager - Facade for todo operations.\n\nOrchestrates Parser, Storage, and Display (DDD).",
              "imports": [
                {
                  "module": "typing",
                  "from": true,
                  "names": [
                    "List",
                    "Dict",
                    "Optional",
                    "Union"
                  ]
                },
                {
                  "module": "rich.console",
                  "from": true,
                  "names": [
                    "Console"
                  ]
                },
                {
                  "module": "rich.progress",
                  "from": true,
                  "names": [
                    "Progress"
                  ]
                },
                {
                  "module": "parser",
                  "from": true,
                  "names": [
                    "TodoParser"
                  ]
                },
                {
                  "module": "storage",
                  "from": true,
                  "names": [
                    "TodoStorage"
                  ]
                },
                {
                  "module": "display",
                  "from": true,
                  "names": [
                    "TodoDisplay"
                  ]
                }
              ],
              "functions": [],
              "classes": [
                {
                  "name": "TodoManager",
                  "bases": [],
                  "docstring": "Facade for todo operations. Delegates to specialized classes.",
                  "methods": [
                    {
                      "name": "__init__",
                      "signature": "(self, session_id: str, agent_id: Optional[str])",
                      "docstring": "Initialize with session and agent IDs.\n\nArgs:\n    session_id: Session UUID from transcript\n    agent_id: Agent UUID (defaults to session_id)",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 17
                    },
                    {
                      "name": "read",
                      "signature": "(self) -> List[Dict]",
                      "docstring": "Read todos from storage.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 28
                    },
                    {
                      "name": "write",
                      "signature": "(self, todos: List[Dict]) -> str",
                      "docstring": "Write todos to storage.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 32
                    },
                    {
                      "name": "delete",
                      "signature": "(self) -> bool",
                      "docstring": "Delete todo file.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 36
                    },
                    {
                      "name": "display",
                      "signature": "(self, show_progress: bool)",
                      "docstring": "Display todos using Rich.\n\nArgs:\n    show_progress: Whether to show progress bar",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 40
                    },
                    {
                      "name": "parse",
                      "signature": "(data: Union[str, bytes]) -> List[Dict]",
                      "docstring": "Parse todos from JSON.\n\nDelegates to TodoParser (Single Responsibility).",
                      "decorators": [
                        "staticmethod"
                      ],
                      "is_async": false,
                      "line_number": 65
                    },
                    {
                      "name": "calculate_progress",
                      "signature": "(todos: List[Dict]) -> Dict",
                      "docstring": "Calculate progress metrics.\n\nDelegates to TodoDisplay (Single Responsibility).",
                      "decorators": [
                        "staticmethod"
                      ],
                      "is_async": false,
                      "line_number": 73
                    }
                  ],
                  "attributes": [],
                  "properties": [],
                  "class_variables": [],
                  "line_number": 14
                }
              ],
              "constants": [],
              "size": {
                "lines": 78,
                "bytes": 2428
              }
            },
            {
              "file": "claude_parser/domain/services/token_analyzer.py",
              "path": "claude_parser/domain/services/token_analyzer.py",
              "module_docstring": "Token analyzer service for tracking and analyzing token usage.\n\nSOLID: Single Responsibility - Token analysis only\nDDD: Domain service for token analytics\n95/5: Uses tokenator library for tracking",
              "imports": [
                {
                  "module": "typing",
                  "from": true,
                  "names": [
                    "Dict",
                    "List",
                    "Optional",
                    "Any"
                  ]
                },
                {
                  "module": "dataclasses",
                  "from": true,
                  "names": [
                    "dataclass"
                  ]
                },
                {
                  "module": "pathlib",
                  "from": true,
                  "names": [
                    "Path"
                  ]
                },
                {
                  "module": "orjson",
                  "alias": null
                },
                {
                  "module": "toolz",
                  "from": true,
                  "names": [
                    "pipe",
                    "map",
                    "filter",
                    "reduce",
                    "groupby"
                  ]
                },
                {
                  "module": "pendulum",
                  "from": true,
                  "names": [
                    "DateTime",
                    "now"
                  ]
                },
                {
                  "module": "claude_parser.models.usage",
                  "from": true,
                  "names": [
                    "UsageInfo"
                  ]
                },
                {
                  "module": "claude_parser.infrastructure.file_utils",
                  "from": true,
                  "names": [
                    "ensure_file_exists"
                  ]
                },
                {
                  "module": "claude_parser",
                  "from": true,
                  "names": [
                    "load"
                  ]
                }
              ],
              "functions": [],
              "classes": [
                {
                  "name": "TokenStats",
                  "bases": [],
                  "docstring": "Token usage statistics.",
                  "methods": [],
                  "attributes": [],
                  "properties": [
                    "total_tokens",
                    "cache_savings"
                  ],
                  "class_variables": [
                    {
                      "name": "total_input",
                      "type": "int"
                    },
                    {
                      "name": "total_output",
                      "type": "int"
                    },
                    {
                      "name": "total_cache_read",
                      "type": "int"
                    },
                    {
                      "name": "total_cache_created",
                      "type": "int"
                    },
                    {
                      "name": "message_count",
                      "type": "int"
                    },
                    {
                      "name": "cache_hit_rate",
                      "type": "float"
                    },
                    {
                      "name": "average_tokens_per_message",
                      "type": "float"
                    },
                    {
                      "name": "total_cost_usd",
                      "type": "float"
                    }
                  ],
                  "line_number": 21
                },
                {
                  "name": "TokenAnalyzer",
                  "bases": [],
                  "docstring": "Analyzes token usage patterns in conversations.\n\n95/5: Consider using tokenator library for real-time tracking.\nThis provides analysis of existing JSONL data.",
                  "methods": [
                    {
                      "name": "__init__",
                      "signature": "(self)",
                      "docstring": "Initialize token analyzer.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 64
                    },
                    {
                      "name": "analyze_conversation",
                      "signature": "(self, conversation: Any) -> TokenStats",
                      "docstring": "Analyze token usage in a conversation.\n\nArgs:\n    conversation: Conversation object with messages\n    \nReturns:\n    TokenStats with usage analysis",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 68
                    },
                    {
                      "name": "analyze_session_tokens",
                      "signature": "(self, transcript_path: str) -> Dict[str, Any]",
                      "docstring": "Analyze token usage for an entire session.\n\nArgs:\n    transcript_path: Path to JSONL transcript\n    \nReturns:\n    Detailed token analysis",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 119
                    },
                    {
                      "name": "_parse_usage",
                      "signature": "(self, usage_data: Dict) -> UsageInfo",
                      "docstring": "Parse usage data into UsageInfo object.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 152
                    },
                    {
                      "name": "_calculate_cost",
                      "signature": "(self, stats: TokenStats) -> float",
                      "docstring": "Calculate USD cost based on token usage.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 162
                    },
                    {
                      "name": "_build_token_timeline",
                      "signature": "(self, conversation: Any) -> List[Dict]",
                      "docstring": "Build timeline of token usage.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 174
                    },
                    {
                      "name": "_find_high_token_messages",
                      "signature": "(self, conversation: Any, threshold: int) -> List[Dict]",
                      "docstring": "Find messages that used high token counts.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 193
                    },
                    {
                      "name": "recommend_reinject_points",
                      "signature": "(self, conversation: Any, interval: int) -> List[int]",
                      "docstring": "Recommend message indices for context reinjection.\n\nArgs:\n    conversation: Conversation to analyze\n    interval: Token interval for reinjection (default 25K)\n    \nReturns:\n    List of message indices where reinjection should occur",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 211
                    }
                  ],
                  "attributes": [
                    "PRICING"
                  ],
                  "properties": [],
                  "class_variables": [],
                  "line_number": 49
                }
              ],
              "constants": [],
              "size": {
                "lines": 239,
                "bytes": 8576
              }
            },
            {
              "file": "claude_parser/domain/services/analyzer.py",
              "path": "claude_parser/domain/services/analyzer.py",
              "module_docstring": "Conversation analysis service.\n\nSOLID: Single Responsibility - Only analysis operations.\nDDD: Domain Service - Stateless operations on aggregates.",
              "imports": [
                {
                  "module": "typing",
                  "from": true,
                  "names": [
                    "TYPE_CHECKING",
                    "Dict",
                    "Any"
                  ]
                },
                {
                  "module": "entities.conversation",
                  "from": true,
                  "names": [
                    "Conversation"
                  ]
                }
              ],
              "functions": [],
              "classes": [
                {
                  "name": "ConversationAnalyzer",
                  "bases": [],
                  "docstring": "Domain service for conversation analysis.",
                  "methods": [
                    {
                      "name": "__init__",
                      "signature": "(self, conversation: 'Conversation')",
                      "docstring": "Initialize analyzer with a conversation.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 17
                    },
                    {
                      "name": "get_stats",
                      "signature": "(self) -> Dict[str, Any]",
                      "docstring": "Generate conversation statistics and insights.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 21
                    }
                  ],
                  "attributes": [],
                  "properties": [],
                  "class_variables": [],
                  "line_number": 14
                }
              ],
              "constants": [],
              "size": {
                "lines": 31,
                "bytes": 1091
              }
            },
            {
              "file": "claude_parser/domain/services/__init__.py",
              "path": "claude_parser/domain/services/__init__.py",
              "module_docstring": "Domain services.",
              "imports": [
                {
                  "module": "analyzer",
                  "from": true,
                  "names": [
                    "ConversationAnalyzer"
                  ]
                },
                {
                  "module": "navigation",
                  "from": true,
                  "names": [
                    "NavigationService"
                  ]
                }
              ],
              "functions": [],
              "classes": [],
              "constants": [],
              "size": {
                "lines": 6,
                "bytes": 165
              }
            },
            {
              "file": "claude_parser/domain/services/navigation.py",
              "path": "claude_parser/domain/services/navigation.py",
              "module_docstring": "Conversation navigation service.\n\nSOLID: Single Responsibility - Only navigation operations.\nDDD: Domain Service - Complex navigation logic.\n95/5: Using libraries (networkx, pendulum, toolz).",
              "imports": [
                {
                  "module": "typing",
                  "from": true,
                  "names": [
                    "List",
                    "Optional",
                    "TYPE_CHECKING"
                  ]
                },
                {
                  "module": "pendulum",
                  "alias": null
                },
                {
                  "module": "networkx",
                  "alias": "nx"
                },
                {
                  "module": "toolz",
                  "from": true,
                  "names": [
                    "pipe",
                    "filter",
                    "map"
                  ]
                },
                {
                  "module": "entities.conversation",
                  "from": true,
                  "names": [
                    "Conversation"
                  ]
                },
                {
                  "module": "models",
                  "from": true,
                  "names": [
                    "Message"
                  ]
                }
              ],
              "functions": [],
              "classes": [
                {
                  "name": "NavigationService",
                  "bases": [],
                  "docstring": "Service for navigating through conversation messages.",
                  "methods": [
                    {
                      "name": "__init__",
                      "signature": "(self, conversation: 'Conversation')",
                      "docstring": "Initialize with conversation to navigate.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 22
                    },
                    {
                      "name": "_build_indices",
                      "signature": "(self)",
                      "docstring": "Build navigation indices for O(1) lookups.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 27
                    },
                    {
                      "name": "get_by_uuid",
                      "signature": "(self, uuid: str) -> Optional['Message']",
                      "docstring": "Get message by UUID with O(1) lookup.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 47
                    },
                    {
                      "name": "get_surrounding",
                      "signature": "(self, uuid: str, before: int, after: int) -> List['Message']",
                      "docstring": "Get messages surrounding a specific message.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 51
                    },
                    {
                      "name": "get_messages_between_timestamps",
                      "signature": "(self, start: Optional[str], end: Optional[str]) -> List['Message']",
                      "docstring": "Get messages between two timestamps using pendulum.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 69
                    },
                    {
                      "name": "get_thread_from",
                      "signature": "(self, uuid: str) -> List['Message']",
                      "docstring": "Get thread using NetworkX for graph operations.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 100
                    }
                  ],
                  "attributes": [],
                  "properties": [],
                  "class_variables": [],
                  "line_number": 19
                }
              ],
              "constants": [],
              "size": {
                "lines": 148,
                "bytes": 4649
              }
            },
            {
              "file": "claude_parser/domain/services/session_analyzer.py",
              "path": "claude_parser/domain/services/session_analyzer.py",
              "module_docstring": "Session analyzer - Handles session boundaries and current session token counting.\n\nSOLID: Single Responsibility - Session analysis only\n95/5: Uses tiktoken for token counting",
              "imports": [
                {
                  "module": "typing",
                  "from": true,
                  "names": [
                    "List",
                    "Optional",
                    "Tuple"
                  ]
                },
                {
                  "module": "dataclasses",
                  "from": true,
                  "names": [
                    "dataclass"
                  ]
                },
                {
                  "module": "tiktoken",
                  "alias": null
                },
                {
                  "module": "toolz",
                  "from": true,
                  "names": [
                    "pipe",
                    "map",
                    "filter",
                    "reduce"
                  ]
                },
                {
                  "module": "claude_parser.models.usage",
                  "from": true,
                  "names": [
                    "UsageInfo"
                  ]
                }
              ],
              "functions": [],
              "classes": [
                {
                  "name": "SessionStats",
                  "bases": [],
                  "docstring": "Statistics for current session only.",
                  "methods": [],
                  "attributes": [],
                  "properties": [],
                  "class_variables": [
                    {
                      "name": "session_start_index",
                      "type": "int"
                    },
                    {
                      "name": "message_count",
                      "type": "int"
                    },
                    {
                      "name": "total_tokens",
                      "type": "int"
                    },
                    {
                      "name": "input_tokens",
                      "type": "int"
                    },
                    {
                      "name": "output_tokens",
                      "type": "int"
                    },
                    {
                      "name": "cache_read_tokens",
                      "type": "int"
                    },
                    {
                      "name": "cache_created_tokens",
                      "type": "int"
                    },
                    {
                      "name": "cache_hit_rate",
                      "type": "float"
                    },
                    {
                      "name": "cost_usd",
                      "type": "float"
                    },
                    {
                      "name": "model",
                      "type": "str"
                    },
                    {
                      "name": "context_limit",
                      "type": "int"
                    }
                  ],
                  "line_number": 17
                },
                {
                  "name": "SessionAnalyzer",
                  "bases": [],
                  "docstring": "Analyzes current session, not entire transcript.\n\nA session is defined as messages after the most recent summary.",
                  "methods": [
                    {
                      "name": "__init__",
                      "signature": "(self)",
                      "docstring": "Initialize session analyzer.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 47
                    },
                    {
                      "name": "find_current_session_start",
                      "signature": "(self, conversation) -> int",
                      "docstring": "Find where current session starts.\n\nSession starts after the last compact summary message.\n\nArgs:\n    conversation: Conversation object\n    \nReturns:\n    Index where current session starts",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 52
                    },
                    {
                      "name": "analyze_current_session",
                      "signature": "(self, conversation) -> SessionStats",
                      "docstring": "Analyze only the current session's token usage.\n\nArgs:\n    conversation: Full conversation object\n    \nReturns:\n    SessionStats for current session only",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 83
                    },
                    {
                      "name": "get_tokens_since_last_reinject",
                      "signature": "(self, conversation, reinject_interval: int) -> Tuple[int, bool]",
                      "docstring": "Get tokens since last reinject point.\n\nArgs:\n    conversation: Conversation object\n    reinject_interval: Token interval for reinjection\n    \nReturns:\n    Tuple of (tokens_since_reinject, should_reinject)",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 172
                    },
                    {
                      "name": "estimate_tokens_for_text",
                      "signature": "(self, text: str) -> int",
                      "docstring": "Estimate token count for text using tiktoken.\n\nArgs:\n    text: Text to count tokens for\n    \nReturns:\n    Estimated token count",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 188
                    },
                    {
                      "name": "_calculate_cost",
                      "signature": "(self, stats: SessionStats) -> float",
                      "docstring": "Calculate USD cost for session.\n\nArgs:\n    stats: Session statistics\n    \nReturns:\n    Cost in USD",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 199
                    },
                    {
                      "name": "format_session_banner",
                      "signature": "(self, stats: SessionStats) -> str",
                      "docstring": "Format concise session stats for display.\n\nArgs:\n    stats: Session statistics\n    \nReturns:\n    Formatted banner string with percentage remaining",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 218
                    }
                  ],
                  "attributes": [
                    "PRICING"
                  ],
                  "properties": [],
                  "class_variables": [],
                  "line_number": 33
                }
              ],
              "constants": [],
              "size": {
                "lines": 249,
                "bytes": 8724
              }
            },
            {
              "file": "claude_parser/domain/entities/conversation.py",
              "path": "claude_parser/domain/entities/conversation.py",
              "module_docstring": "Conversation entity - Core domain model.\n\nSOLID: Single Responsibility - ONLY conversation representation.\nDDD: Entity with identity (session_id).\n95/5: Using toolz for all filtering operations.",
              "imports": [
                {
                  "module": "typing",
                  "from": true,
                  "names": [
                    "List",
                    "Optional",
                    "Iterator"
                  ]
                },
                {
                  "module": "toolz",
                  "from": true,
                  "names": [
                    "filter"
                  ]
                },
                {
                  "module": "models",
                  "from": true,
                  "names": [
                    "Message",
                    "AssistantMessage",
                    "UserMessage",
                    "Summary"
                  ]
                },
                {
                  "module": "value_objects.metadata",
                  "from": true,
                  "names": [
                    "ConversationMetadata"
                  ]
                },
                {
                  "module": "filters",
                  "from": true,
                  "names": [
                    "ErrorFilter"
                  ]
                },
                {
                  "module": "models.content",
                  "from": true,
                  "names": [
                    "ToolUseContent",
                    "ToolResultContent"
                  ]
                }
              ],
              "functions": [],
              "classes": [
                {
                  "name": "Conversation",
                  "bases": [],
                  "docstring": "Conversation aggregate root.\nClean, focused entity following SOLID principles.\nAll navigation/analysis extracted to services.",
                  "methods": [
                    {
                      "name": "__init__",
                      "signature": "(self, messages: List[Message], metadata: ConversationMetadata)",
                      "docstring": "Initialize conversation with messages and metadata.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 24
                    },
                    {
                      "name": "filter_messages",
                      "signature": "(self, predicate) -> List[Message]",
                      "docstring": "Filter messages using custom predicate.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 97
                    },
                    {
                      "name": "search",
                      "signature": "(self, query: str, case_sensitive: bool) -> List[Message]",
                      "docstring": "Search messages containing text.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 101
                    },
                    {
                      "name": "filter",
                      "signature": "(self, predicate) -> List[Message]",
                      "docstring": "Alias for filter_messages for backward compatibility.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 113
                    },
                    {
                      "name": "with_errors",
                      "signature": "(self) -> List[Message]",
                      "docstring": "Find messages with errors.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 117
                    },
                    {
                      "name": "before_summary",
                      "signature": "(self, limit: int) -> List[Message]",
                      "docstring": "Get messages before the last summary.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 122
                    },
                    {
                      "name": "tool_messages",
                      "signature": "(self) -> List['ToolUseContent | ToolResultContent']",
                      "docstring": "Alias for tool_uses property for backward compatibility.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 140
                    },
                    {
                      "name": "messages_with_errors",
                      "signature": "(self) -> List[Message]",
                      "docstring": "Alias for with_errors() for backward compatibility.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 144
                    },
                    {
                      "name": "messages_before_summary",
                      "signature": "(self, limit: int) -> List[Message]",
                      "docstring": "Alias for before_summary() for backward compatibility.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 148
                    },
                    {
                      "name": "__len__",
                      "signature": "(self) -> int",
                      "docstring": "Get number of messages.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 153
                    },
                    {
                      "name": "__getitem__",
                      "signature": "(self, index: int | slice) -> Message | List[Message]",
                      "docstring": "Get message by index or slice.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 157
                    },
                    {
                      "name": "__iter__",
                      "signature": "(self) -> Iterator[Message]",
                      "docstring": "Iterate over messages.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 161
                    },
                    {
                      "name": "__repr__",
                      "signature": "(self) -> str",
                      "docstring": "String representation.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 165
                    }
                  ],
                  "attributes": [],
                  "properties": [
                    "metadata",
                    "session_id",
                    "filepath",
                    "current_dir",
                    "git_branch",
                    "messages",
                    "assistant_messages",
                    "user_messages",
                    "tool_uses",
                    "summaries"
                  ],
                  "class_variables": [],
                  "line_number": 17
                }
              ],
              "constants": [],
              "size": {
                "lines": 167,
                "bytes": 5811
              }
            },
            {
              "file": "claude_parser/domain/entities/__init__.py",
              "path": "claude_parser/domain/entities/__init__.py",
              "module_docstring": "Domain entities.",
              "imports": [
                {
                  "module": "conversation",
                  "from": true,
                  "names": [
                    "Conversation"
                  ]
                }
              ],
              "functions": [],
              "classes": [],
              "constants": [],
              "size": {
                "lines": 5,
                "bytes": 90
              }
            },
            {
              "file": "claude_parser/domain/interfaces/protocols.py",
              "path": "claude_parser/domain/interfaces/protocols.py",
              "module_docstring": "Domain interfaces and protocols.\n\nSOLID: Interface Segregation - Small, focused interfaces.\nDRY: Shared contracts for domain operations.",
              "imports": [
                {
                  "module": "typing",
                  "from": true,
                  "names": [
                    "Protocol",
                    "List"
                  ]
                },
                {
                  "module": "pathlib",
                  "from": true,
                  "names": [
                    "Path"
                  ]
                },
                {
                  "module": "abc",
                  "from": true,
                  "names": [
                    "ABC",
                    "abstractmethod"
                  ]
                },
                {
                  "module": "models",
                  "from": true,
                  "names": [
                    "Message"
                  ]
                }
              ],
              "functions": [],
              "classes": [
                {
                  "name": "MessageFilter",
                  "bases": [
                    "Protocol"
                  ],
                  "docstring": "Strategy pattern for message filtering.",
                  "methods": [
                    {
                      "name": "matches",
                      "signature": "(self, message: Message) -> bool",
                      "docstring": "Check if message matches filter criteria.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 18
                    }
                  ],
                  "attributes": [],
                  "properties": [],
                  "class_variables": [],
                  "line_number": 15
                },
                {
                  "name": "MessageRepository",
                  "bases": [
                    "ABC"
                  ],
                  "docstring": "Repository pattern for message data access.",
                  "methods": [
                    {
                      "name": "load_messages",
                      "signature": "(self, filepath: Path) -> List[Message]",
                      "docstring": "Load messages from data source.",
                      "decorators": [
                        "abstractmethod"
                      ],
                      "is_async": false,
                      "line_number": 27
                    }
                  ],
                  "attributes": [],
                  "properties": [],
                  "class_variables": [],
                  "line_number": 23
                }
              ],
              "constants": [],
              "size": {
                "lines": 29,
                "bytes": 707
              }
            },
            {
              "file": "claude_parser/domain/interfaces/__init__.py",
              "path": "claude_parser/domain/interfaces/__init__.py",
              "module_docstring": "Domain interfaces and protocols.",
              "imports": [
                {
                  "module": "protocols",
                  "from": true,
                  "names": [
                    "MessageFilter",
                    "MessageRepository"
                  ]
                }
              ],
              "functions": [],
              "classes": [],
              "constants": [],
              "size": {
                "lines": 5,
                "bytes": 145
              }
            }
          ],
          "summary": {
            "file_count": 22,
            "class_count": 18,
            "function_count": 0
          }
        },
        "analytics": {
          "responsibility": "Analytics domain functionality",
          "files": [
            {
              "file": "claude_parser/analytics/analyzer.py",
              "path": "claude_parser/analytics/analyzer.py",
              "module_docstring": "Analytics analyzer for conversations.\n\nProvides detailed analytics including token counting,\nmessage statistics, and usage patterns.",
              "imports": [
                {
                  "module": "typing",
                  "from": true,
                  "names": [
                    "Dict",
                    "Any",
                    "List",
                    "Optional"
                  ]
                },
                {
                  "module": "dataclasses",
                  "from": true,
                  "names": [
                    "dataclass",
                    "field"
                  ]
                },
                {
                  "module": "collections",
                  "from": true,
                  "names": [
                    "defaultdict"
                  ]
                },
                {
                  "module": "re",
                  "alias": null
                },
                {
                  "module": "domain.entities.conversation",
                  "from": true,
                  "names": [
                    "Conversation"
                  ]
                },
                {
                  "module": "models",
                  "from": true,
                  "names": [
                    "Message",
                    "AssistantMessage",
                    "UserMessage"
                  ]
                },
                {
                  "module": "models.content",
                  "from": true,
                  "names": [
                    "ToolUseContent",
                    "ToolResultContent"
                  ]
                },
                {
                  "module": "tiktoken",
                  "alias": null
                }
              ],
              "functions": [],
              "classes": [
                {
                  "name": "ConversationStats",
                  "bases": [],
                  "docstring": "Statistics for a conversation.",
                  "methods": [],
                  "attributes": [],
                  "properties": [],
                  "class_variables": [
                    {
                      "name": "total_messages",
                      "type": "int"
                    },
                    {
                      "name": "user_messages",
                      "type": "int"
                    },
                    {
                      "name": "assistant_messages",
                      "type": "int"
                    },
                    {
                      "name": "tool_uses",
                      "type": "int"
                    },
                    {
                      "name": "tool_results",
                      "type": "int"
                    },
                    {
                      "name": "total_tokens",
                      "type": "int"
                    },
                    {
                      "name": "user_tokens",
                      "type": "int"
                    },
                    {
                      "name": "assistant_tokens",
                      "type": "int"
                    },
                    {
                      "name": "avg_message_length",
                      "type": "float"
                    },
                    {
                      "name": "avg_response_length",
                      "type": "float"
                    },
                    {
                      "name": "tools_by_name",
                      "type": "Dict[str, int]"
                    },
                    {
                      "name": "messages_by_hour",
                      "type": "Dict[int, int]"
                    },
                    {
                      "name": "messages_by_day",
                      "type": "Dict[str, int]"
                    },
                    {
                      "name": "errors_count",
                      "type": "int"
                    },
                    {
                      "name": "conversation_duration_minutes",
                      "type": "float"
                    }
                  ],
                  "line_number": 18
                },
                {
                  "name": "ConversationAnalytics",
                  "bases": [],
                  "docstring": "Analytics engine for conversations.\n\nProvides comprehensive analytics including token counting,\nmessage statistics, tool usage patterns, and more.\n\nExample:\n    analytics = ConversationAnalytics(conversation)\n    stats = analytics.get_statistics()\n    \n    print(f\"Total messages: {stats.total_messages}\")\n    print(f\"Estimated tokens: {stats.total_tokens}\")\n    \n    # Get hourly distribution\n    hourly = analytics.get_hourly_distribution()\n    for hour, count in hourly.items():\n        print(f\"{hour:02d}:00 - {count} messages\")",
                  "methods": [
                    {
                      "name": "__init__",
                      "signature": "(self, conversation: Conversation)",
                      "docstring": "Initialize analytics for a conversation.\n\nArgs:\n    conversation: The conversation to analyze",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 64
                    },
                    {
                      "name": "get_statistics",
                      "signature": "(self) -> ConversationStats",
                      "docstring": "Get comprehensive statistics for the conversation.\n\nReturns:\n    ConversationStats object with all metrics",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 73
                    },
                    {
                      "name": "estimate_tokens",
                      "signature": "(self, text: str) -> int",
                      "docstring": "Estimate token count for text.\n\nUses a simple heuristic of ~4 characters per token.\nFor accurate counts, use tiktoken library.\n\nArgs:\n    text: The text to count tokens for\n    \nReturns:\n    Estimated token count",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 83
                    },
                    {
                      "name": "get_hourly_distribution",
                      "signature": "(self) -> Dict[int, int]",
                      "docstring": "Get message distribution by hour of day.\n\nReturns:\n    Dictionary mapping hour (0-23) to message count",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 109
                    },
                    {
                      "name": "get_daily_distribution",
                      "signature": "(self) -> Dict[str, int]",
                      "docstring": "Get message distribution by day.\n\nReturns:\n    Dictionary mapping date string to message count",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 124
                    },
                    {
                      "name": "get_tool_usage",
                      "signature": "(self) -> Dict[str, int]",
                      "docstring": "Get tool usage statistics.\n\nReturns:\n    Dictionary mapping tool name to usage count",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 139
                    },
                    {
                      "name": "get_error_messages",
                      "signature": "(self) -> List[Message]",
                      "docstring": "Get all messages containing errors.\n\nReturns:\n    List of messages with errors",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 153
                    },
                    {
                      "name": "get_response_times",
                      "signature": "(self) -> List[float]",
                      "docstring": "Calculate response times between user and assistant messages.\n\nReturns:\n    List of response times in seconds",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 161
                    },
                    {
                      "name": "get_conversation_duration",
                      "signature": "(self) -> float",
                      "docstring": "Get total conversation duration in minutes.\n\nReturns:\n    Duration in minutes",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 186
                    },
                    {
                      "name": "_calculate_statistics",
                      "signature": "(self) -> None",
                      "docstring": "Calculate all statistics for the conversation.",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 207
                    }
                  ],
                  "attributes": [
                    "CHARS_PER_TOKEN"
                  ],
                  "properties": [],
                  "class_variables": [],
                  "line_number": 42
                },
                {
                  "name": "TokenCounter",
                  "bases": [],
                  "docstring": "Utility class for accurate token counting.\n\nNote: For accurate token counting, install tiktoken:\n    pip install tiktoken\n\nThis class provides a fallback estimation if tiktoken\nis not available.",
                  "methods": [
                    {
                      "name": "__init__",
                      "signature": "(self, model: str)",
                      "docstring": "Initialize token counter.\n\nArgs:\n    model: The model to use for tokenization",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 273
                    },
                    {
                      "name": "count_tokens",
                      "signature": "(self, text: str) -> int",
                      "docstring": "Count tokens in text.\n\nArgs:\n    text: The text to count tokens for\n    \nReturns:\n    Token count (exact if tiktoken available, estimate otherwise)",
                      "decorators": [],
                      "is_async": false,
                      "line_number": 290
                    }
                  ],
                  "attributes": [],
                  "properties": [],
                  "class_variables": [],
                  "line_number": 263
                }
              ],
              "constants": [],
              "size": {
                "lines": 304,
                "bytes": 9899
              }
            },
            {
              "file": "claude_parser/analytics/__init__.py",
              "path": "claude_parser/analytics/__init__.py",
              "module_docstring": "Analytics engine for Claude Parser.\n\nProvides token counting, aggregations, and visualizations\nfor Claude conversations.\n\nExample:\n    from claude_parser import load\n    from claude_parser.analytics import ConversationAnalytics\n    \n    conv = load(\"conversation.jsonl\")\n    analytics = ConversationAnalytics(conv)\n    \n    # Get token counts\n    stats = analytics.get_statistics()\n    print(f\"Total tokens: {stats['total_tokens']}\")",
              "imports": [
                {
                  "module": "analyzer",
                  "from": true,
                  "names": [
                    "ConversationAnalytics",
                    "ConversationStats"
                  ]
                }
              ],
              "functions": [],
              "classes": [],
              "constants": [],
              "size": {
                "lines": 23,
                "bytes": 573
              }
            }
          ],
          "summary": {
            "file_count": 2,
            "class_count": 3,
            "function_count": 0
          }
        }
      }
    },
    "scripts": {
      "files": [
        {
          "file": "scripts/validate_task.py",
          "path": "scripts/validate_task.py",
          "module_docstring": "Task validation for dstask - enforces 95/5 and DRY principles.\n\nThis script can be used as:\n1. Pre-commit hook in ~/.dstask/.git/hooks/\n2. Manual validation: python validate_task.py <task_id>\n3. Automated enrichment on task creation",
          "imports": [
            {
              "module": "subprocess",
              "alias": null
            },
            {
              "module": "orjson",
              "alias": null
            },
            {
              "module": "sys",
              "alias": null
            },
            {
              "module": "pathlib",
              "from": true,
              "names": [
                "Path"
              ]
            },
            {
              "module": "typing",
              "from": true,
              "names": [
                "Dict",
                "List",
                "Tuple"
              ]
            },
            {
              "module": "re",
              "alias": null
            }
          ],
          "functions": [
            {
              "name": "get_task_notes",
              "signature": "(task_id: int) -> str",
              "docstring": "Get notes for a specific task.",
              "decorators": [],
              "is_async": false,
              "line_number": 19
            },
            {
              "name": "validate_task_notes",
              "signature": "(notes: str) -> Tuple[bool, List[str]]",
              "docstring": "Validate task notes have required information.",
              "decorators": [],
              "is_async": false,
              "line_number": 29
            },
            {
              "name": "suggest_libraries",
              "signature": "(task_summary: str) -> List[str]",
              "docstring": "Suggest libraries based on task summary.",
              "decorators": [],
              "is_async": false,
              "line_number": 56
            },
            {
              "name": "check_for_duplicates",
              "signature": "(task_summary: str) -> List[str]",
              "docstring": "Check for potential duplicate implementations.",
              "decorators": [],
              "is_async": false,
              "line_number": 78
            },
            {
              "name": "main",
              "signature": "()",
              "docstring": "Validate task or enrich with suggestions.",
              "decorators": [],
              "is_async": false,
              "line_number": 93
            }
          ],
          "classes": [],
          "constants": [],
          "size": {
            "lines": 126,
            "bytes": 3751
          }
        },
        {
          "file": "scripts/install_dstask_hooks.py",
          "path": "scripts/install_dstask_hooks.py",
          "module_docstring": "Install git hooks directly into ~/.dstask to enforce task quality at the data layer.\nThis is the ULTIMATE enforcement - happens on EVERY dstask operation!",
          "imports": [
            {
              "module": "orjson",
              "alias": null
            },
            {
              "module": "pendulum",
              "alias": null
            },
            {
              "module": "pathlib",
              "from": true,
              "names": [
                "Path"
              ]
            },
            {
              "module": "typing",
              "from": true,
              "names": [
                "Dict",
                "List"
              ]
            },
            {
              "module": "subprocess",
              "alias": null
            },
            {
              "module": "sys",
              "alias": null
            }
          ],
          "functions": [
            {
              "name": "create_pre_commit_hook",
              "signature": "()",
              "docstring": "Create the pre-commit hook for ~/.dstask/.git/hooks/",
              "decorators": [],
              "is_async": false,
              "line_number": 30
            },
            {
              "name": "create_post_commit_hook",
              "signature": "()",
              "docstring": "Create post-commit hook to flag non-compliant tasks.",
              "decorators": [],
              "is_async": false,
              "line_number": 115
            },
            {
              "name": "install_hooks",
              "signature": "()",
              "docstring": "Install the hooks into ~/.dstask/.git/hooks/",
              "decorators": [],
              "is_async": false,
              "line_number": 177
            },
            {
              "name": "test_hooks",
              "signature": "()",
              "docstring": "Test the hooks work.",
              "decorators": [],
              "is_async": false,
              "line_number": 205
            },
            {
              "name": "main",
              "signature": "()",
              "docstring": "Install and test dstask git hooks.",
              "decorators": [],
              "is_async": false,
              "line_number": 227
            }
          ],
          "classes": [],
          "constants": [
            "TASK_TEMPLATE"
          ],
          "size": {
            "lines": 256,
            "bytes": 7665
          }
        },
        {
          "file": "scripts/research_sync.py",
          "path": "scripts/research_sync.py",
          "module_docstring": "Perplexity Research Tool - 95/5 Architecture\nUses httpx SYNCHRONOUS client (no async needed)",
          "imports": [
            {
              "module": "os",
              "alias": null
            },
            {
              "module": "pathlib",
              "from": true,
              "names": [
                "Path"
              ]
            },
            {
              "module": "typing",
              "from": true,
              "names": [
                "Optional",
                "List",
                "Dict"
              ]
            },
            {
              "module": "pendulum",
              "alias": null
            },
            {
              "module": "rich.console",
              "from": true,
              "names": [
                "Console"
              ]
            },
            {
              "module": "rich.markdown",
              "from": true,
              "names": [
                "Markdown"
              ]
            },
            {
              "module": "rich.panel",
              "from": true,
              "names": [
                "Panel"
              ]
            },
            {
              "module": "orjson",
              "alias": null
            },
            {
              "module": "dotenv",
              "from": true,
              "names": [
                "load_dotenv"
              ]
            },
            {
              "module": "httpx",
              "alias": null
            },
            {
              "module": "tenacity",
              "from": true,
              "names": [
                "retry",
                "stop_after_attempt",
                "wait_exponential"
              ]
            },
            {
              "module": "sys",
              "alias": null
            }
          ],
          "functions": [
            {
              "name": "main",
              "signature": "()",
              "docstring": "Main entry point - fully synchronous.",
              "decorators": [],
              "is_async": false,
              "line_number": 194
            }
          ],
          "classes": [
            {
              "name": "PerplexityResearcher",
              "bases": [],
              "docstring": "Perplexity API wrapper - httpx handles 95% of complexity.",
              "methods": [
                {
                  "name": "__init__",
                  "signature": "(self, api_key: Optional[str])",
                  "docstring": null,
                  "decorators": [],
                  "is_async": false,
                  "line_number": 28
                },
                {
                  "name": "_call_api_streaming",
                  "signature": "(self, messages: List[Dict])",
                  "docstring": "Call API with streaming - httpx handles it simply.",
                  "decorators": [
                    "retry(stop=stop_after_attempt(3), wait=wait_exponential(multiplier=1, min=4, max=10))"
                  ],
                  "is_async": false,
                  "line_number": 88
                },
                {
                  "name": "research",
                  "signature": "(self, query: str) -> str",
                  "docstring": "Research with streaming output and auto-save.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 106
                },
                {
                  "name": "_save_to_file",
                  "signature": "(self, query: str, response: str)",
                  "docstring": "Save research to markdown file.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 154
                },
                {
                  "name": "interactive",
                  "signature": "(self)",
                  "docstring": "Interactive research mode - simple loop.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 165
                }
              ],
              "attributes": [],
              "properties": [],
              "class_variables": [],
              "line_number": 25
            }
          ],
          "constants": [],
          "size": {
            "lines": 216,
            "bytes": 7666
          }
        },
        {
          "file": "scripts/research.py",
          "path": "scripts/research.py",
          "module_docstring": "Perplexity Research Tool - 95/5 Architecture\nUses httpx SYNCHRONOUS client (no async needed)\nSupports conversation threads and file context",
          "imports": [
            {
              "module": "os",
              "alias": null
            },
            {
              "module": "pathlib",
              "from": true,
              "names": [
                "Path"
              ]
            },
            {
              "module": "typing",
              "from": true,
              "names": [
                "Optional",
                "List",
                "Dict"
              ]
            },
            {
              "module": "pendulum",
              "alias": null
            },
            {
              "module": "rich.console",
              "from": true,
              "names": [
                "Console"
              ]
            },
            {
              "module": "rich.markdown",
              "from": true,
              "names": [
                "Markdown"
              ]
            },
            {
              "module": "rich.panel",
              "from": true,
              "names": [
                "Panel"
              ]
            },
            {
              "module": "orjson",
              "alias": null
            },
            {
              "module": "hashlib",
              "alias": null
            },
            {
              "module": "typer",
              "alias": null
            },
            {
              "module": "dotenv",
              "from": true,
              "names": [
                "load_dotenv"
              ]
            },
            {
              "module": "httpx",
              "alias": null
            },
            {
              "module": "tenacity",
              "from": true,
              "names": [
                "retry",
                "stop_after_attempt",
                "wait_exponential"
              ]
            }
          ],
          "functions": [
            {
              "name": "main",
              "signature": "(query: Optional[List[str]], model: str, thread: Optional[str], file: Optional[str], context: Optional[List[str]])",
              "docstring": "Research tool for finding high-level libraries.",
              "decorators": [
                "app.command()"
              ],
              "is_async": false,
              "line_number": 357
            }
          ],
          "classes": [
            {
              "name": "PerplexityResearcher",
              "bases": [],
              "docstring": "Perplexity API wrapper with conversation threads and file context.",
              "methods": [
                {
                  "name": "__init__",
                  "signature": "(self, api_key: Optional[str], model: str, thread_id: Optional[str])",
                  "docstring": null,
                  "decorators": [],
                  "is_async": false,
                  "line_number": 59
                },
                {
                  "name": "_load_thread",
                  "signature": "(self) -> List[Dict]",
                  "docstring": "Load existing conversation thread or start new.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 161
                },
                {
                  "name": "_save_thread",
                  "signature": "(self)",
                  "docstring": "Save conversation thread to disk.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 180
                },
                {
                  "name": "_call_api_streaming",
                  "signature": "(self, messages: List[Dict])",
                  "docstring": "Call API with streaming - httpx handles it simply.",
                  "decorators": [
                    "retry(stop=stop_after_attempt(3), wait=wait_exponential(multiplier=1, min=4, max=10))"
                  ],
                  "is_async": false,
                  "line_number": 191
                },
                {
                  "name": "research",
                  "signature": "(self, query: str, file_path: Optional[str], context_files: Optional[List[str]]) -> str",
                  "docstring": "Research with streaming output, file context, and auto-save.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 209
                },
                {
                  "name": "_save_to_file",
                  "signature": "(self, query: str, response: str)",
                  "docstring": "Save research to markdown file.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 300
                },
                {
                  "name": "interactive",
                  "signature": "(self)",
                  "docstring": "Interactive research mode - simple loop.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 311
                }
              ],
              "attributes": [],
              "properties": [],
              "class_variables": [],
              "line_number": 56
            }
          ],
          "constants": [],
          "size": {
            "lines": 389,
            "bytes": 15583
          }
        },
        {
          "file": "scripts/manage_backlog.py",
          "path": "scripts/manage_backlog.py",
          "module_docstring": "Backlog management script for claude-parser using dstask.\nThis script can be run by Claude Code to manage tasks autonomously.\n\n95/5 Principle: Uses dstask CLI for task management\nLIBRARY FIRST: Uses subprocess for CLI interaction, orjson for JSON",
          "imports": [
            {
              "module": "subprocess",
              "alias": null
            },
            {
              "module": "sys",
              "alias": null
            },
            {
              "module": "pathlib",
              "from": true,
              "names": [
                "Path"
              ]
            },
            {
              "module": "typing",
              "from": true,
              "names": [
                "List",
                "Dict",
                "Optional"
              ]
            },
            {
              "module": "orjson",
              "alias": null
            },
            {
              "module": "rich.console",
              "from": true,
              "names": [
                "Console"
              ]
            },
            {
              "module": "rich.table",
              "from": true,
              "names": [
                "Table"
              ]
            },
            {
              "module": "rich",
              "from": true,
              "names": [
                "box"
              ]
            },
            {
              "module": "sys",
              "alias": null
            },
            {
              "module": "tempfile",
              "alias": null
            }
          ],
          "functions": [
            {
              "name": "init_backlog",
              "signature": "()",
              "docstring": "Initialize backlog with current tasks from documentation.",
              "decorators": [],
              "is_async": false,
              "line_number": 90
            },
            {
              "name": "show_status",
              "signature": "()",
              "docstring": "Show current backlog status.",
              "decorators": [],
              "is_async": false,
              "line_number": 206
            },
            {
              "name": "main",
              "signature": "()",
              "docstring": "Main CLI interface.",
              "decorators": [],
              "is_async": false,
              "line_number": 223
            }
          ],
          "classes": [
            {
              "name": "DstaskManager",
              "bases": [],
              "docstring": "Manages backlog using dstask CLI.",
              "methods": [
                {
                  "name": "__init__",
                  "signature": "(self, project: str)",
                  "docstring": null,
                  "decorators": [],
                  "is_async": false,
                  "line_number": 24
                },
                {
                  "name": "add_task",
                  "signature": "(self, summary: str, priority: str, tags: List[str], notes: str) -> str",
                  "docstring": "Add a new task to backlog.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 27
                },
                {
                  "name": "add_note",
                  "signature": "(self, task_id: str, note: str)",
                  "docstring": "Add note to existing task.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 53
                },
                {
                  "name": "list_tasks",
                  "signature": "(self, filter_str: str) -> List[Dict]",
                  "docstring": "List tasks with optional filter.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 66
                },
                {
                  "name": "complete_task",
                  "signature": "(self, task_id: str)",
                  "docstring": "Mark task as done.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 76
                },
                {
                  "name": "start_task",
                  "signature": "(self, task_id: str)",
                  "docstring": "Start working on task.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 80
                },
                {
                  "name": "get_next_tasks",
                  "signature": "(self) -> str",
                  "docstring": "Get prioritized next tasks.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 84
                }
              ],
              "attributes": [],
              "properties": [],
              "class_variables": [],
              "line_number": 21
            }
          ],
          "constants": [],
          "size": {
            "lines": 255,
            "bytes": 8456
          }
        },
        {
          "file": "scripts/check_inventory_sync.py",
          "path": "scripts/check_inventory_sync.py",
          "module_docstring": "Check if codebase inventory is synchronized with actual code.\n\nExits with 0 if synchronized, 1 if out of date.\nUsed by pre-commit hooks to enforce documentation updates.",
          "imports": [
            {
              "module": "sys",
              "alias": null
            },
            {
              "module": "subprocess",
              "alias": null
            },
            {
              "module": "pathlib",
              "from": true,
              "names": [
                "Path"
              ]
            },
            {
              "module": "orjson",
              "alias": null
            },
            {
              "module": "rich.console",
              "from": true,
              "names": [
                "Console"
              ]
            },
            {
              "module": "tempfile",
              "alias": null
            }
          ],
          "functions": [
            {
              "name": "check_inventory_sync",
              "signature": "()",
              "docstring": "Check if CODEBASE_INVENTORY.json is up to date.",
              "decorators": [],
              "is_async": false,
              "line_number": 19
            },
            {
              "name": "main",
              "signature": "()",
              "docstring": "Main entry point.",
              "decorators": [],
              "is_async": false,
              "line_number": 96
            }
          ],
          "classes": [],
          "constants": [],
          "size": {
            "lines": 105,
            "bytes": 4151
          }
        },
        {
          "file": "scripts/discover_jsonl_structure.py",
          "path": "scripts/discover_jsonl_structure.py",
          "module_docstring": "JSONL Structure Discovery Tool - Complete Analysis\nDiscovers ALL keys, nested structures, and variations in Claude Code JSONL files.\nUses streaming to handle huge files without choking.",
          "imports": [
            {
              "module": "orjson",
              "alias": null
            },
            {
              "module": "pathlib",
              "from": true,
              "names": [
                "Path"
              ]
            },
            {
              "module": "typing",
              "from": true,
              "names": [
                "Dict",
                "Set",
                "Any",
                "List",
                "Union"
              ]
            },
            {
              "module": "collections",
              "from": true,
              "names": [
                "defaultdict"
              ]
            },
            {
              "module": "mmap",
              "alias": null
            },
            {
              "module": "random",
              "alias": null
            },
            {
              "module": "rich.console",
              "from": true,
              "names": [
                "Console"
              ]
            },
            {
              "module": "rich.tree",
              "from": true,
              "names": [
                "Tree"
              ]
            },
            {
              "module": "rich.table",
              "from": true,
              "names": [
                "Table"
              ]
            },
            {
              "module": "rich.progress",
              "from": true,
              "names": [
                "track"
              ]
            },
            {
              "module": "rich",
              "from": true,
              "names": [
                "print"
              ]
            },
            {
              "module": "typer",
              "alias": null
            },
            {
              "module": "dataclasses",
              "from": true,
              "names": [
                "dataclass",
                "field"
              ]
            },
            {
              "module": "hashlib",
              "alias": null
            }
          ],
          "functions": [
            {
              "name": "analyze",
              "signature": "(directory: Path, output_dir: Path, limit: int, sample_rate: float)",
              "docstring": "Analyze all JSONL files and discover complete structure.",
              "decorators": [
                "app.command()"
              ],
              "is_async": false,
              "line_number": 429
            }
          ],
          "classes": [
            {
              "name": "FieldInfo",
              "bases": [],
              "docstring": "Information about a field.",
              "methods": [],
              "attributes": [],
              "properties": [],
              "class_variables": [
                {
                  "name": "types",
                  "type": "Set[str]"
                },
                {
                  "name": "samples",
                  "type": "List[Any]"
                },
                {
                  "name": "occurrences",
                  "type": "int"
                },
                {
                  "name": "nullable",
                  "type": "bool"
                },
                {
                  "name": "array_types",
                  "type": "Set[str]"
                },
                {
                  "name": "object_keys",
                  "type": "Set[str]"
                },
                {
                  "name": "unique_values",
                  "type": "Set[str]"
                },
                {
                  "name": "min_value",
                  "type": "Any"
                },
                {
                  "name": "max_value",
                  "type": "Any"
                }
              ],
              "line_number": 27
            },
            {
              "name": "StructureDiscoverer",
              "bases": [],
              "docstring": "Discovers complete JSONL structure including all variations.",
              "methods": [
                {
                  "name": "__init__",
                  "signature": "(self)",
                  "docstring": null,
                  "decorators": [],
                  "is_async": false,
                  "line_number": 42
                },
                {
                  "name": "analyze_value",
                  "signature": "(self, path: str, value: Any, parent_type: str)",
                  "docstring": "Recursively analyze value structure.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 54
                },
                {
                  "name": "process_line",
                  "signature": "(self, line: bytes) -> bool",
                  "docstring": "Process a single JSONL line. Returns True if successful.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 157
                },
                {
                  "name": "process_file",
                  "signature": "(self, file_path: Path, sample_rate: float) -> int",
                  "docstring": "Process a single file. Returns number of lines processed.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 179
                },
                {
                  "name": "generate_complete_structure",
                  "signature": "(self) -> Dict[str, Any]",
                  "docstring": "Generate complete structure dictionary.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 226
                },
                {
                  "name": "generate_typescript",
                  "signature": "(self) -> str",
                  "docstring": "Generate complete TypeScript definitions.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 275
                },
                {
                  "name": "generate_markdown_report",
                  "signature": "(self) -> str",
                  "docstring": "Generate comprehensive markdown documentation.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 354
                }
              ],
              "attributes": [],
              "properties": [],
              "class_variables": [],
              "line_number": 39
            }
          ],
          "constants": [],
          "size": {
            "lines": 523,
            "bytes": 21227
          }
        },
        {
          "file": "scripts/backlog_dashboard.py",
          "path": "scripts/backlog_dashboard.py",
          "module_docstring": "Backlog dashboard for Claude Code to autonomously manage tasks.\nThis provides a clean interface that Claude Code can use to track progress.\n\n95/5: Uses dstask for task management, rich for display",
          "imports": [
            {
              "module": "subprocess",
              "alias": null
            },
            {
              "module": "orjson",
              "alias": null
            },
            {
              "module": "rich.console",
              "from": true,
              "names": [
                "Console"
              ]
            },
            {
              "module": "rich.table",
              "from": true,
              "names": [
                "Table"
              ]
            },
            {
              "module": "rich.panel",
              "from": true,
              "names": [
                "Panel"
              ]
            },
            {
              "module": "rich.layout",
              "from": true,
              "names": [
                "Layout"
              ]
            },
            {
              "module": "rich.live",
              "from": true,
              "names": [
                "Live"
              ]
            },
            {
              "module": "rich",
              "from": true,
              "names": [
                "box"
              ]
            },
            {
              "module": "typing",
              "from": true,
              "names": [
                "List",
                "Dict"
              ]
            },
            {
              "module": "sys",
              "alias": null
            },
            {
              "module": "time",
              "from": true,
              "names": [
                "sleep"
              ]
            }
          ],
          "functions": [
            {
              "name": "parse_dstask_json",
              "signature": "(json_output: str) -> List[Dict]",
              "docstring": "Parse dstask JSON output.",
              "decorators": [],
              "is_async": false,
              "line_number": 22
            },
            {
              "name": "get_tasks_by_priority",
              "signature": "() -> Dict[str, List[Dict]]",
              "docstring": "Get tasks grouped by priority.",
              "decorators": [],
              "is_async": false,
              "line_number": 29
            },
            {
              "name": "get_active_tasks",
              "signature": "() -> List[Dict]",
              "docstring": "Get currently active tasks.",
              "decorators": [],
              "is_async": false,
              "line_number": 48
            },
            {
              "name": "get_completed_today",
              "signature": "() -> List[Dict]",
              "docstring": "Get tasks completed today.",
              "decorators": [],
              "is_async": false,
              "line_number": 53
            },
            {
              "name": "create_dashboard",
              "signature": "()",
              "docstring": "Create the main dashboard.",
              "decorators": [],
              "is_async": false,
              "line_number": 60
            },
            {
              "name": "main",
              "signature": "()",
              "docstring": "Main entry point.",
              "decorators": [],
              "is_async": false,
              "line_number": 165
            }
          ],
          "classes": [],
          "constants": [],
          "size": {
            "lines": 178,
            "bytes": 5628
          }
        },
        {
          "file": "scripts/verify_spec_v2.py",
          "path": "scripts/verify_spec_v2.py",
          "module_docstring": "95/5 Principle Verification - SOLID Version\nThis script follows its own rules: functional programming with toolz",
          "imports": [
            {
              "module": "sys",
              "alias": null
            },
            {
              "module": "re",
              "alias": null
            },
            {
              "module": "ast",
              "alias": null
            },
            {
              "module": "pathlib",
              "from": true,
              "names": [
                "Path"
              ]
            },
            {
              "module": "typing",
              "from": true,
              "names": [
                "Tuple",
                "Set",
                "Dict",
                "Any"
              ]
            },
            {
              "module": "toolz",
              "from": true,
              "names": [
                "pipe",
                "concat",
                "merge",
                "partition",
                "groupby",
                "count",
                "compose",
                "reduce",
                "get_in",
                "valmap"
              ]
            },
            {
              "module": "toolz.curried",
              "from": true,
              "names": [
                "map",
                "filter",
                "get"
              ]
            },
            {
              "module": "functools",
              "from": true,
              "names": [
                "partial"
              ]
            },
            {
              "module": "more_itertools",
              "from": true,
              "names": [
                "flatten"
              ]
            },
            {
              "module": "verification_config",
              "from": true,
              "names": [
                "COLORS",
                "APPROVED_LIBRARIES",
                "FORBIDDEN_IMPORTS",
                "FORBIDDEN_PATTERNS",
                "EXEMPTIONS",
                "REQUIRED_TESTS",
                "PATHS",
                "EXCLUDED_FILES"
              ]
            }
          ],
          "functions": [
            {
              "name": "print_status",
              "signature": "(passed: bool, message: str) -> None",
              "docstring": "Print colored status message.",
              "decorators": [],
              "is_async": false,
              "line_number": 30
            },
            {
              "name": "read_file_safe",
              "signature": "(path: Path) -> str",
              "docstring": "Safely read file content.",
              "decorators": [],
              "is_async": false,
              "line_number": 35
            },
            {
              "name": "get_python_files",
              "signature": "(base_path: str) -> list",
              "docstring": "Get all Python files from a directory.",
              "decorators": [],
              "is_async": false,
              "line_number": 42
            },
            {
              "name": "extract_imports_from_line",
              "signature": "(line: str) -> str",
              "docstring": "Extract module name from import line.",
              "decorators": [],
              "is_async": false,
              "line_number": 59
            },
            {
              "name": "check_line_against_patterns",
              "signature": "(patterns: list, line: str) -> list",
              "docstring": "Check if line matches any forbidden pattern.",
              "decorators": [],
              "is_async": false,
              "line_number": 70
            },
            {
              "name": "format_violation",
              "signature": "(file_path: Path, line_no: int, message: str, line: str) -> str",
              "docstring": "Format a violation message.",
              "decorators": [],
              "is_async": false,
              "line_number": 79
            },
            {
              "name": "check_forbidden_imports",
              "signature": "() -> Tuple[bool, list]",
              "docstring": "Check for forbidden imports using functional approach.",
              "decorators": [],
              "is_async": false,
              "line_number": 87
            },
            {
              "name": "check_approved_libraries",
              "signature": "() -> Tuple[bool, list]",
              "docstring": "Check that only approved libraries are imported.",
              "decorators": [],
              "is_async": false,
              "line_number": 130
            },
            {
              "name": "check_manual_loops",
              "signature": "() -> Tuple[bool, list]",
              "docstring": "Check for manual loops and state management.",
              "decorators": [],
              "is_async": false,
              "line_number": 177
            },
            {
              "name": "check_95_5_principle",
              "signature": "() -> Tuple[bool, list]",
              "docstring": "Check that the API follows 95/5 principle.",
              "decorators": [],
              "is_async": false,
              "line_number": 217
            },
            {
              "name": "check_tests_exist",
              "signature": "() -> Tuple[bool, list]",
              "docstring": "Check that required test files exist.",
              "decorators": [],
              "is_async": false,
              "line_number": 239
            },
            {
              "name": "check_unused_files",
              "signature": "() -> Tuple[bool, list]",
              "docstring": "Check for unused files using functional approach.",
              "decorators": [],
              "is_async": false,
              "line_number": 255
            },
            {
              "name": "run_all_checks",
              "signature": "() -> Dict[str, Tuple[bool, list]]",
              "docstring": "Run all verification checks and return results.",
              "decorators": [],
              "is_async": false,
              "line_number": 344
            },
            {
              "name": "display_results",
              "signature": "(results: Dict[str, Tuple[bool, list]]) -> int",
              "docstring": "Display verification results.",
              "decorators": [],
              "is_async": false,
              "line_number": 355
            },
            {
              "name": "main",
              "signature": "() -> int",
              "docstring": "Main entry point.",
              "decorators": [],
              "is_async": false,
              "line_number": 444
            }
          ],
          "classes": [],
          "constants": [],
          "size": {
            "lines": 452,
            "bytes": 15476
          }
        },
        {
          "file": "scripts/backlog_priorities.py",
          "path": "scripts/backlog_priorities.py",
          "module_docstring": "Extract and display backlog priorities with notes from tags.",
          "imports": [
            {
              "module": "subprocess",
              "alias": null
            },
            {
              "module": "orjson",
              "alias": null
            },
            {
              "module": "typing",
              "from": true,
              "names": [
                "List",
                "Dict",
                "Any"
              ]
            },
            {
              "module": "toolz",
              "from": true,
              "names": [
                "pipe",
                "filter",
                "map"
              ]
            },
            {
              "module": "operator",
              "from": true,
              "names": [
                "methodcaller"
              ]
            },
            {
              "module": "toolz",
              "from": true,
              "names": [
                "groupby"
              ]
            },
            {
              "module": "operator",
              "from": true,
              "names": [
                "methodcaller"
              ]
            }
          ],
          "functions": [
            {
              "name": "get_tasks",
              "signature": "() -> List[Dict[str, Any]]",
              "docstring": "Get all tasks from dstask.",
              "decorators": [],
              "is_async": false,
              "line_number": 8
            },
            {
              "name": "extract_notes",
              "signature": "(tags: List[str]) -> str",
              "docstring": "Extract notes from tags that start with 'notes:'.",
              "decorators": [],
              "is_async": false,
              "line_number": 18
            },
            {
              "name": "print_task_priorities",
              "signature": "()",
              "docstring": "Display tasks organized by priority with extracted notes.",
              "decorators": [],
              "is_async": false,
              "line_number": 31
            }
          ],
          "classes": [],
          "constants": [],
          "size": {
            "lines": 90,
            "bytes": 2967
          }
        },
        {
          "file": "scripts/verification_config.py",
          "path": "scripts/verification_config.py",
          "module_docstring": "Configuration for 95/5 Principle Verification\nSOLID: Single Responsibility - Just configuration, no logic",
          "imports": [],
          "functions": [],
          "classes": [],
          "constants": [
            "COLORS",
            "APPROVED_LIBRARIES",
            "FORBIDDEN_IMPORTS",
            "FORBIDDEN_PATTERNS",
            "REQUIRED_TESTS",
            "PATHS",
            "EXCLUDED_FILES"
          ],
          "size": {
            "lines": 164,
            "bytes": 5782
          }
        },
        {
          "file": "scripts/verify_spec.py",
          "path": "scripts/verify_spec.py",
          "module_docstring": "Specification Compliance Verifier\nRun this before committing to ensure 95/5 principle is followed",
          "imports": [
            {
              "module": "sys",
              "alias": null
            },
            {
              "module": "subprocess",
              "alias": null
            },
            {
              "module": "pathlib",
              "from": true,
              "names": [
                "Path"
              ]
            },
            {
              "module": "typing",
              "from": true,
              "names": [
                "List",
                "Tuple"
              ]
            },
            {
              "module": "re",
              "alias": null
            }
          ],
          "functions": [
            {
              "name": "print_status",
              "signature": "(passed: bool, message: str)",
              "docstring": "Print colored status message",
              "decorators": [],
              "is_async": false,
              "line_number": 18
            },
            {
              "name": "check_forbidden_imports",
              "signature": "() -> Tuple[bool, List[str]]",
              "docstring": "Check for forbidden imports that violate 95/5 principle",
              "decorators": [],
              "is_async": false,
              "line_number": 23
            },
            {
              "name": "check_required_libraries",
              "signature": "() -> Tuple[bool, List[str]]",
              "docstring": "Check that required libraries are in dependency files",
              "decorators": [],
              "is_async": false,
              "line_number": 87
            },
            {
              "name": "check_95_5_principle",
              "signature": "() -> Tuple[bool, List[str]]",
              "docstring": "Check that the 95% use case is actually simple",
              "decorators": [],
              "is_async": false,
              "line_number": 130
            },
            {
              "name": "check_models_use_pydantic",
              "signature": "() -> Tuple[bool, List[str]]",
              "docstring": "Ensure all models use pydantic.BaseModel",
              "decorators": [],
              "is_async": false,
              "line_number": 153
            },
            {
              "name": "check_tests_exist",
              "signature": "() -> Tuple[bool, List[str]]",
              "docstring": "Check that test files exist for main features",
              "decorators": [],
              "is_async": false,
              "line_number": 171
            },
            {
              "name": "run_verification",
              "signature": "()",
              "docstring": "Run all verification checks",
              "decorators": [],
              "is_async": false,
              "line_number": 190
            }
          ],
          "classes": [],
          "constants": [
            "RED",
            "GREEN",
            "YELLOW",
            "RESET"
          ],
          "size": {
            "lines": 246,
            "bytes": 8623
          }
        },
        {
          "file": "scripts/analyze_tokens.py",
          "path": "scripts/analyze_tokens.py",
          "module_docstring": "Token usage analyzer CLI.\n\n95/5: Uses typer for CLI, rich for display",
          "imports": [
            {
              "module": "pathlib",
              "from": true,
              "names": [
                "Path"
              ]
            },
            {
              "module": "typer",
              "alias": null
            },
            {
              "module": "rich.console",
              "from": true,
              "names": [
                "Console"
              ]
            },
            {
              "module": "rich.table",
              "from": true,
              "names": [
                "Table"
              ]
            },
            {
              "module": "rich.panel",
              "from": true,
              "names": [
                "Panel"
              ]
            },
            {
              "module": "rich",
              "from": true,
              "names": [
                "print"
              ]
            },
            {
              "module": "claude_parser",
              "from": true,
              "names": [
                "load"
              ]
            },
            {
              "module": "claude_parser.domain.services.token_analyzer",
              "from": true,
              "names": [
                "TokenAnalyzer",
                "TokenStats"
              ]
            }
          ],
          "functions": [
            {
              "name": "format_number",
              "signature": "(n: int) -> str",
              "docstring": "Format large numbers with commas.",
              "decorators": [],
              "is_async": false,
              "line_number": 22
            },
            {
              "name": "format_percentage",
              "signature": "(n: float) -> str",
              "docstring": "Format percentage.",
              "decorators": [],
              "is_async": false,
              "line_number": 27
            },
            {
              "name": "analyze",
              "signature": "(file_path: Path, verbose: bool, timeline: bool)",
              "docstring": "Analyze token usage in a Claude Code session.",
              "decorators": [
                "app.command()"
              ],
              "is_async": false,
              "line_number": 33
            },
            {
              "name": "compare",
              "signature": "(file1: Path, file2: Path)",
              "docstring": "Compare token usage between two sessions.",
              "decorators": [
                "app.command()"
              ],
              "is_async": false,
              "line_number": 148
            },
            {
              "name": "_get_efficiency_emoji",
              "signature": "(rate: float) -> str",
              "docstring": "Get emoji based on efficiency rate.",
              "decorators": [],
              "is_async": false,
              "line_number": 199
            }
          ],
          "classes": [],
          "constants": [],
          "size": {
            "lines": 212,
            "bytes": 7651
          }
        },
        {
          "file": "scripts/enforce_context.py",
          "path": "scripts/enforce_context.py",
          "module_docstring": "Local enforcement of AI context awareness.\nRuns BEFORE any code changes to ensure Claude loads context.\n\nThis script can be called from:\n1. Shell aliases\n2. VS Code tasks\n3. Makefile targets\n4. Direct execution",
          "imports": [
            {
              "module": "sys",
              "alias": null
            },
            {
              "module": "subprocess",
              "alias": null
            },
            {
              "module": "pathlib",
              "from": true,
              "names": [
                "Path"
              ]
            },
            {
              "module": "rich.console",
              "from": true,
              "names": [
                "Console"
              ]
            },
            {
              "module": "rich.panel",
              "from": true,
              "names": [
                "Panel"
              ]
            },
            {
              "module": "orjson",
              "alias": null
            }
          ],
          "functions": [
            {
              "name": "check_context_loaded",
              "signature": "()",
              "docstring": "Check if AI context files have been accessed recently.",
              "decorators": [],
              "is_async": false,
              "line_number": 22
            },
            {
              "name": "display_context_reminder",
              "signature": "()",
              "docstring": "Display reminder panel for Claude.",
              "decorators": [],
              "is_async": false,
              "line_number": 65
            },
            {
              "name": "show_quick_stats",
              "signature": "()",
              "docstring": "Show quick codebase stats.",
              "decorators": [],
              "is_async": false,
              "line_number": 89
            },
            {
              "name": "main",
              "signature": "()",
              "docstring": "Main enforcement flow.",
              "decorators": [],
              "is_async": false,
              "line_number": 102
            }
          ],
          "classes": [],
          "constants": [],
          "size": {
            "lines": 119,
            "bytes": 3694
          }
        },
        {
          "file": "scripts/discover_structure_simple.py",
          "path": "scripts/discover_structure_simple.py",
          "module_docstring": "Simple JSONL structure discovery without typer.",
          "imports": [
            {
              "module": "orjson",
              "alias": null
            },
            {
              "module": "pathlib",
              "from": true,
              "names": [
                "Path"
              ]
            },
            {
              "module": "collections",
              "from": true,
              "names": [
                "defaultdict"
              ]
            },
            {
              "module": "sys",
              "alias": null
            },
            {
              "module": "rich.console",
              "from": true,
              "names": [
                "Console"
              ]
            },
            {
              "module": "rich.progress",
              "from": true,
              "names": [
                "track"
              ]
            }
          ],
          "functions": [
            {
              "name": "main",
              "signature": "()",
              "docstring": null,
              "decorators": [],
              "is_async": false,
              "line_number": 116
            }
          ],
          "classes": [
            {
              "name": "StructureDiscoverer",
              "bases": [],
              "docstring": null,
              "methods": [
                {
                  "name": "__init__",
                  "signature": "(self)",
                  "docstring": null,
                  "decorators": [],
                  "is_async": false,
                  "line_number": 16
                },
                {
                  "name": "analyze_value",
                  "signature": "(self, path, value, depth)",
                  "docstring": "Recursively analyze structure.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 29
                },
                {
                  "name": "process_line",
                  "signature": "(self, line)",
                  "docstring": "Process single JSONL line.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 85
                },
                {
                  "name": "process_file",
                  "signature": "(self, file_path)",
                  "docstring": "Process a JSONL file.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 103
                }
              ],
              "attributes": [],
              "properties": [],
              "class_variables": [],
              "line_number": 15
            }
          ],
          "constants": [],
          "size": {
            "lines": 202,
            "bytes": 7219
          }
        },
        {
          "file": "scripts/feature_matrix.py",
          "path": "scripts/feature_matrix.py",
          "module_docstring": "Generate feature matrix documentation for Claude Parser SDK.\n\n95/5: Using typer for CLI, rich for display\nSOLID: Single responsibility - only feature matrix generation",
          "imports": [
            {
              "module": "typer",
              "alias": null
            },
            {
              "module": "rich.console",
              "from": true,
              "names": [
                "Console"
              ]
            },
            {
              "module": "rich.table",
              "from": true,
              "names": [
                "Table"
              ]
            },
            {
              "module": "rich",
              "from": true,
              "names": [
                "box"
              ]
            },
            {
              "module": "pathlib",
              "from": true,
              "names": [
                "Path"
              ]
            },
            {
              "module": "sys",
              "alias": null
            },
            {
              "module": "claude_parser.features",
              "from": true,
              "names": [
                "get_registry",
                "FeatureStatus"
              ]
            },
            {
              "module": "claude_parser.features.registry",
              "from": true,
              "names": [
                "save_registry"
              ]
            },
            {
              "module": "claude_parser.features.formatters",
              "from": true,
              "names": [
                "to_markdown_table"
              ]
            }
          ],
          "functions": [
            {
              "name": "show",
              "signature": "(category: str, status: str, incomplete: bool)",
              "docstring": "Display feature matrix in terminal.",
              "decorators": [
                "app.command()"
              ],
              "is_async": false,
              "line_number": 28
            },
            {
              "name": "markdown",
              "signature": "(output: Path)",
              "docstring": "Generate markdown documentation.",
              "decorators": [
                "app.command()"
              ],
              "is_async": false,
              "line_number": 122
            },
            {
              "name": "save",
              "signature": "()",
              "docstring": "Save registry to JSON file.",
              "decorators": [
                "app.command()"
              ],
              "is_async": false,
              "line_number": 179
            },
            {
              "name": "check",
              "signature": "()",
              "docstring": "Check for incomplete features and unused imports.",
              "decorators": [
                "app.command()"
              ],
              "is_async": false,
              "line_number": 186
            }
          ],
          "classes": [],
          "constants": [],
          "size": {
            "lines": 213,
            "bytes": 7415
          }
        },
        {
          "file": "scripts/codebase_inventory.py",
          "path": "scripts/codebase_inventory.py",
          "module_docstring": "Codebase Inventory Generator for AI/LLM Context.\n\nUses AST to extract comprehensive codebase structure into hierarchical JSON.\nFollows LIBRARY_FIRST_RULE.md and 95/5 principle.",
          "imports": [
            {
              "module": "ast",
              "alias": null
            },
            {
              "module": "os",
              "alias": null
            },
            {
              "module": "pathlib",
              "from": true,
              "names": [
                "Path"
              ]
            },
            {
              "module": "typing",
              "from": true,
              "names": [
                "Dict",
                "List",
                "Any",
                "Optional"
              ]
            },
            {
              "module": "typing_extensions",
              "from": true,
              "names": [
                "Annotated"
              ]
            },
            {
              "module": "orjson",
              "alias": null
            },
            {
              "module": "rich.console",
              "from": true,
              "names": [
                "Console"
              ]
            },
            {
              "module": "rich.table",
              "from": true,
              "names": [
                "Table"
              ]
            },
            {
              "module": "rich.tree",
              "from": true,
              "names": [
                "Tree"
              ]
            },
            {
              "module": "rich",
              "from": true,
              "names": [
                "box"
              ]
            },
            {
              "module": "typer",
              "alias": null
            },
            {
              "module": "toolz",
              "from": true,
              "names": [
                "pipe",
                "map",
                "filter",
                "groupby"
              ]
            }
          ],
          "functions": [
            {
              "name": "generate",
              "signature": "(path: Annotated[Path, typer.Argument(help='Path to codebase root')], output: Annotated[Optional[Path], typer.Option('--output', '-o', help='Output file path')], format: Annotated[str, typer.Option('--format', '-f', help='Output format: json, summary, tree')], show_tree: Annotated[bool, typer.Option('--tree', help='Display visual tree')], show_stats: Annotated[bool, typer.Option('--stats', help='Display statistics table')])",
              "docstring": "Generate comprehensive codebase inventory for AI/LLM context.",
              "decorators": [
                "app.command()"
              ],
              "is_async": false,
              "line_number": 270
            },
            {
              "name": "display_tree",
              "signature": "(inventory: Dict[str, Any])",
              "docstring": "Display visual tree of codebase structure.",
              "decorators": [],
              "is_async": false,
              "line_number": 310
            },
            {
              "name": "display_stats",
              "signature": "(inventory: Dict[str, Any])",
              "docstring": "Display statistics table.",
              "decorators": [],
              "is_async": false,
              "line_number": 335
            },
            {
              "name": "generate_markdown_summary",
              "signature": "(inventory: Dict[str, Any]) -> str",
              "docstring": "Generate markdown summary of inventory.",
              "decorators": [],
              "is_async": false,
              "line_number": 361
            }
          ],
          "classes": [
            {
              "name": "CodebaseAnalyzer",
              "bases": [],
              "docstring": "AST-based codebase analyzer for inventory generation.",
              "methods": [
                {
                  "name": "__init__",
                  "signature": "(self, root_dir: Path)",
                  "docstring": null,
                  "decorators": [],
                  "is_async": false,
                  "line_number": 29
                },
                {
                  "name": "extract_file_inventory",
                  "signature": "(self, filepath: Path) -> Dict[str, Any]",
                  "docstring": "Extract inventory from a single Python file using AST.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 33
                },
                {
                  "name": "_extract_function",
                  "signature": "(self, node: ast.FunctionDef) -> Dict[str, Any]",
                  "docstring": "Extract function information from AST node.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 91
                },
                {
                  "name": "_extract_class",
                  "signature": "(self, node: ast.ClassDef) -> Dict[str, Any]",
                  "docstring": "Extract class information from AST node.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 115
                },
                {
                  "name": "analyze_codebase",
                  "signature": "(self) -> Dict[str, Any]",
                  "docstring": "Analyze entire codebase and generate hierarchical inventory.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 159
                },
                {
                  "name": "_get_subdomain",
                  "signature": "(self, filepath: str) -> str",
                  "docstring": "Extract subdomain from claude_parser file path.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 242
                },
                {
                  "name": "_infer_domain_responsibility",
                  "signature": "(self, domain: str) -> str",
                  "docstring": "Infer domain responsibility from directory name.",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 251
                }
              ],
              "attributes": [],
              "properties": [],
              "class_variables": [],
              "line_number": 26
            }
          ],
          "constants": [],
          "size": {
            "lines": 392,
            "bytes": 16362
          }
        },
        {
          "file": "scripts/create_enforced_task.py",
          "path": "scripts/create_enforced_task.py",
          "module_docstring": "Enforced task creation for Claude Code sessions.\n\nThis ensures EVERY task has FULL CONTEXT before any Claude agent works on it.\nNo more partial implementations, no more violations, no more tech debt.\n\nUsage:\n    python create_enforced_task.py \"Task description\"\n    \nThis will:\n1. Research libraries automatically\n2. Check for duplicates\n3. Analyze affected files\n4. Create task with COMPLETE context",
          "imports": [
            {
              "module": "subprocess",
              "alias": null
            },
            {
              "module": "sys",
              "alias": null
            },
            {
              "module": "pathlib",
              "from": true,
              "names": [
                "Path"
              ]
            },
            {
              "module": "orjson",
              "alias": null
            },
            {
              "module": "typing",
              "from": true,
              "names": [
                "List",
                "Dict",
                "Tuple"
              ]
            },
            {
              "module": "re",
              "alias": null
            },
            {
              "module": "pendulum",
              "alias": null
            }
          ],
          "functions": [
            {
              "name": "run_research",
              "signature": "(query: str) -> str",
              "docstring": "Run research.py to find libraries.",
              "decorators": [],
              "is_async": false,
              "line_number": 27
            },
            {
              "name": "check_for_duplicates",
              "signature": "(keywords: List[str]) -> List[str]",
              "docstring": "Check codebase for potential duplicates.",
              "decorators": [],
              "is_async": false,
              "line_number": 41
            },
            {
              "name": "analyze_complexity",
              "signature": "(files: List[str]) -> Dict[str, str]",
              "docstring": "Run radon complexity check on files.",
              "decorators": [],
              "is_async": false,
              "line_number": 59
            },
            {
              "name": "get_file_sizes",
              "signature": "(pattern: str) -> List[Tuple[str, int]]",
              "docstring": "Get files matching pattern with line counts.",
              "decorators": [],
              "is_async": false,
              "line_number": 78
            },
            {
              "name": "extract_keywords",
              "signature": "(description: str) -> List[str]",
              "docstring": "Extract keywords from task description.",
              "decorators": [],
              "is_async": false,
              "line_number": 99
            },
            {
              "name": "create_task_with_context",
              "signature": "(description: str) -> None",
              "docstring": "Create a task with FULL ENFORCED CONTEXT.",
              "decorators": [],
              "is_async": false,
              "line_number": 111
            },
            {
              "name": "main",
              "signature": "()",
              "docstring": null,
              "decorators": [],
              "is_async": false,
              "line_number": 216
            }
          ],
          "classes": [],
          "constants": [],
          "size": {
            "lines": 233,
            "bytes": 7112
          }
        },
        {
          "file": "scripts/audit_tasks.py",
          "path": "scripts/audit_tasks.py",
          "module_docstring": "Audit all tasks for proper context and flag for refinement.\n\nThis script:\n1. Checks all open tasks for required context\n2. Flags tasks missing critical information\n3. Suggests refinements\n4. Can bulk-update tasks with template",
          "imports": [
            {
              "module": "subprocess",
              "alias": null
            },
            {
              "module": "orjson",
              "alias": null
            },
            {
              "module": "sys",
              "alias": null
            },
            {
              "module": "typing",
              "from": true,
              "names": [
                "Dict",
                "List",
                "Tuple"
              ]
            },
            {
              "module": "pathlib",
              "from": true,
              "names": [
                "Path"
              ]
            }
          ],
          "functions": [
            {
              "name": "get_all_tasks",
              "signature": "() -> List[Dict]",
              "docstring": "Get all open tasks from dstask.",
              "decorators": [],
              "is_async": false,
              "line_number": 68
            },
            {
              "name": "check_task_context",
              "signature": "(task: Dict) -> Tuple[bool, List[str]]",
              "docstring": "Check if task has proper context.",
              "decorators": [],
              "is_async": false,
              "line_number": 80
            },
            {
              "name": "flag_task",
              "signature": "(task_id: int, issues: List[str]) -> None",
              "docstring": "Flag a task as needing refinement.",
              "decorators": [],
              "is_async": false,
              "line_number": 105
            },
            {
              "name": "generate_refinement",
              "signature": "(task: Dict) -> str",
              "docstring": "Generate refinement template for task.",
              "decorators": [],
              "is_async": false,
              "line_number": 120
            },
            {
              "name": "audit_all_tasks",
              "signature": "(fix: bool) -> None",
              "docstring": "Audit all tasks and optionally fix them.",
              "decorators": [],
              "is_async": false,
              "line_number": 125
            },
            {
              "name": "create_phase_tasks",
              "signature": "() -> None",
              "docstring": "Create properly contexted tasks for each cleanup phase.",
              "decorators": [],
              "is_async": false,
              "line_number": 182
            },
            {
              "name": "main",
              "signature": "()",
              "docstring": null,
              "decorators": [],
              "is_async": false,
              "line_number": 204
            }
          ],
          "classes": [],
          "constants": [
            "REQUIRED_SECTIONS",
            "TEMPLATE"
          ],
          "size": {
            "lines": 217,
            "bytes": 6304
          }
        },
        {
          "file": "scripts/detect_unused.py",
          "path": "scripts/detect_unused.py",
          "module_docstring": "Detect unused Python files in the codebase.\nFiles that are not imported anywhere are likely dead code.",
          "imports": [
            {
              "module": "ast",
              "alias": null
            },
            {
              "module": "sys",
              "alias": null
            },
            {
              "module": "pathlib",
              "from": true,
              "names": [
                "Path"
              ]
            },
            {
              "module": "typing",
              "from": true,
              "names": [
                "Set",
                "Dict",
                "List",
                "Tuple"
              ]
            }
          ],
          "functions": [
            {
              "name": "get_imports_from_file",
              "signature": "(file_path: Path) -> Set[str]",
              "docstring": "Extract all imports from a Python file.",
              "decorators": [],
              "is_async": false,
              "line_number": 18
            },
            {
              "name": "get_all_python_files",
              "signature": "(root_dir: Path) -> List[Path]",
              "docstring": "Get all Python files in the project.",
              "decorators": [],
              "is_async": false,
              "line_number": 41
            },
            {
              "name": "module_path_from_file",
              "signature": "(file_path: Path, root_dir: Path) -> str",
              "docstring": "Convert file path to module import path.",
              "decorators": [],
              "is_async": false,
              "line_number": 57
            },
            {
              "name": "analyze_usage",
              "signature": "(root_dir: Path) -> Tuple[Dict[Path, Set[Path]], List[Path]]",
              "docstring": "Analyze which files are used by which other files.",
              "decorators": [],
              "is_async": false,
              "line_number": 72
            },
            {
              "name": "categorize_file",
              "signature": "(file_path: Path) -> str",
              "docstring": "Categorize a file based on its location and purpose.",
              "decorators": [],
              "is_async": false,
              "line_number": 131
            },
            {
              "name": "main",
              "signature": "()",
              "docstring": "Main function to detect unused files.",
              "decorators": [],
              "is_async": false,
              "line_number": 156
            }
          ],
          "classes": [],
          "constants": [
            "RED",
            "GREEN",
            "YELLOW",
            "BLUE",
            "RESET"
          ],
          "size": {
            "lines": 211,
            "bytes": 7893
          }
        },
        {
          "file": "scripts/research/research_navigation_libs.py",
          "path": "scripts/research/research_navigation_libs.py",
          "module_docstring": "Quick research on navigation libraries for conversation data.",
          "imports": [],
          "functions": [],
          "classes": [],
          "constants": [],
          "size": {
            "lines": 111,
            "bytes": 2493
          }
        },
        {
          "file": "scripts/research/research_testing.py",
          "path": "scripts/research/research_testing.py",
          "module_docstring": "Research the best testing library setup for 95/5 development.\n\nFollowing our principle: research FIRST, then implement.",
          "imports": [
            {
              "module": "subprocess",
              "alias": null
            },
            {
              "module": "json",
              "alias": null
            }
          ],
          "functions": [
            {
              "name": "ask_sonar",
              "signature": "(question)",
              "docstring": "Ask sonar-pro model for expert advice.",
              "decorators": [],
              "is_async": false,
              "line_number": 10
            }
          ],
          "classes": [],
          "constants": [],
          "size": {
            "lines": 56,
            "bytes": 1944
          }
        },
        {
          "file": "scripts/security/security_scan.py",
          "path": "scripts/security/security_scan.py",
          "module_docstring": "Security scan for GitHub preparation.\nChecks for secrets, API keys, and sensitive data.",
          "imports": [
            {
              "module": "re",
              "alias": null
            },
            {
              "module": "pathlib",
              "from": true,
              "names": [
                "Path"
              ]
            },
            {
              "module": "typing",
              "from": true,
              "names": [
                "List",
                "Tuple"
              ]
            }
          ],
          "functions": [
            {
              "name": "scan_file",
              "signature": "(file_path: Path) -> List[Tuple[str, int, str]]",
              "docstring": "Scan a single file for secrets.",
              "decorators": [],
              "is_async": false,
              "line_number": 23
            },
            {
              "name": "main",
              "signature": "()",
              "docstring": "Run security scan.",
              "decorators": [],
              "is_async": false,
              "line_number": 36
            }
          ],
          "classes": [],
          "constants": [
            "SECRET_PATTERNS"
          ],
          "size": {
            "lines": 71,
            "bytes": 2139
          }
        },
        {
          "file": "scripts/security/clean_secrets.py",
          "path": "scripts/security/clean_secrets.py",
          "module_docstring": "Clean up secrets and prepare for GitHub.",
          "imports": [
            {
              "module": "pathlib",
              "from": true,
              "names": [
                "Path"
              ]
            },
            {
              "module": "re",
              "alias": null
            }
          ],
          "functions": [
            {
              "name": "clean_file",
              "signature": "(file_path: Path, replacements: dict)",
              "docstring": "Clean secrets from a file.",
              "decorators": [],
              "is_async": false,
              "line_number": 9
            },
            {
              "name": "main",
              "signature": "()",
              "docstring": null,
              "decorators": [],
              "is_async": false,
              "line_number": 26
            }
          ],
          "classes": [],
          "constants": [],
          "size": {
            "lines": 88,
            "bytes": 2169
          }
        },
        {
          "file": "scripts/experiments/test_parse_debug.py",
          "path": "scripts/experiments/test_parse_debug.py",
          "module_docstring": "Debug parse_message.",
          "imports": [
            {
              "module": "orjson",
              "alias": null
            },
            {
              "module": "claude_parser.models",
              "from": true,
              "names": [
                "parse_message",
                "UserMessage",
                "ToolResult",
                "MessageType"
              ]
            },
            {
              "module": "traceback",
              "alias": null
            }
          ],
          "functions": [],
          "classes": [],
          "constants": [],
          "size": {
            "lines": 44,
            "bytes": 2123
          }
        },
        {
          "file": "scripts/experiments/test_discovery_tdd.py",
          "path": "scripts/experiments/test_discovery_tdd.py",
          "module_docstring": "TDD-style test to understand Claude's directory structure.",
          "imports": [
            {
              "module": "pathlib",
              "from": true,
              "names": [
                "Path"
              ]
            },
            {
              "module": "orjson",
              "alias": null
            }
          ],
          "functions": [
            {
              "name": "test_understand_claude_structure",
              "signature": "()",
              "docstring": "Understand how Claude encodes project paths.",
              "decorators": [],
              "is_async": false,
              "line_number": 7
            }
          ],
          "classes": [],
          "constants": [],
          "size": {
            "lines": 102,
            "bytes": 4024
          }
        },
        {
          "file": "scripts/experiments/test_parse_with_module.py",
          "path": "scripts/experiments/test_parse_with_module.py",
          "module_docstring": "Test with actual parse_message.",
          "imports": [
            {
              "module": "orjson",
              "alias": null
            },
            {
              "module": "claude_parser.models",
              "from": true,
              "names": [
                "parse_message"
              ]
            },
            {
              "module": "traceback",
              "alias": null
            },
            {
              "module": "traceback",
              "alias": null
            }
          ],
          "functions": [
            {
              "name": "debug_parse",
              "signature": "(data)",
              "docstring": null,
              "decorators": [],
              "is_async": false,
              "line_number": 14
            }
          ],
          "classes": [],
          "constants": [],
          "size": {
            "lines": 59,
            "bytes": 2361
          }
        },
        {
          "file": "scripts/experiments/test_real_conversation_navigation.py",
          "path": "scripts/experiments/test_real_conversation_navigation.py",
          "module_docstring": "TDD test - Find actual messages from our current conversation using keywords.",
          "imports": [
            {
              "module": "claude_parser",
              "from": true,
              "names": [
                "find_current_transcript",
                "load"
              ]
            },
            {
              "module": "pendulum",
              "alias": null
            }
          ],
          "functions": [
            {
              "name": "test_find_our_conversation_by_keyword",
              "signature": "()",
              "docstring": "Find specific messages from our current conversation using keywords.",
              "decorators": [],
              "is_async": false,
              "line_number": 6
            }
          ],
          "classes": [],
          "constants": [],
          "size": {
            "lines": 145,
            "bytes": 5423
          }
        },
        {
          "file": "scripts/experiments/debug_parse_errors.py",
          "path": "scripts/experiments/debug_parse_errors.py",
          "module_docstring": "Debug parsing errors in JSONL file.",
          "imports": [
            {
              "module": "pathlib",
              "from": true,
              "names": [
                "Path"
              ]
            },
            {
              "module": "claude_parser",
              "from": true,
              "names": [
                "load"
              ]
            },
            {
              "module": "claude_parser.infrastructure.message_repository",
              "from": true,
              "names": [
                "JsonlMessageRepository"
              ]
            },
            {
              "module": "orjson",
              "alias": null
            }
          ],
          "functions": [],
          "classes": [],
          "constants": [],
          "size": {
            "lines": 35,
            "bytes": 1203
          }
        },
        {
          "file": "scripts/experiments/fix_test_calls.py",
          "path": "scripts/experiments/fix_test_calls.py",
          "module_docstring": "Fix test method calls to use properties.",
          "imports": [
            {
              "module": "re",
              "alias": null
            },
            {
              "module": "pathlib",
              "from": true,
              "names": [
                "Path"
              ]
            }
          ],
          "functions": [],
          "classes": [],
          "constants": [],
          "size": {
            "lines": 24,
            "bytes": 704
          }
        },
        {
          "file": "scripts/experiments/test_discovery.py",
          "path": "scripts/experiments/test_discovery.py",
          "module_docstring": "Test discovery tool with real data.",
          "imports": [
            {
              "module": "pathlib",
              "from": true,
              "names": [
                "Path"
              ]
            },
            {
              "module": "claude_parser.discovery",
              "from": true,
              "names": [
                "find_transcript_for_cwd",
                "list_all_projects"
              ]
            }
          ],
          "functions": [],
          "classes": [],
          "constants": [],
          "size": {
            "lines": 36,
            "bytes": 1258
          }
        },
        {
          "file": "scripts/experiments/test_parse_line.py",
          "path": "scripts/experiments/test_parse_line.py",
          "module_docstring": "Test parsing a specific line.",
          "imports": [
            {
              "module": "orjson",
              "alias": null
            },
            {
              "module": "claude_parser.models",
              "from": true,
              "names": [
                "parse_message"
              ]
            }
          ],
          "functions": [],
          "classes": [],
          "constants": [],
          "size": {
            "lines": 22,
            "bytes": 1081
          }
        },
        {
          "file": "scripts/experiments/test_strict.py",
          "path": "scripts/experiments/test_strict.py",
          "module_docstring": "Test strict validation.",
          "imports": [
            {
              "module": "pathlib",
              "from": true,
              "names": [
                "Path"
              ]
            },
            {
              "module": "claude_parser",
              "from": true,
              "names": [
                "load"
              ]
            },
            {
              "module": "claude_parser.parser",
              "from": true,
              "names": [
                "validate_claude_format"
              ]
            }
          ],
          "functions": [],
          "classes": [],
          "constants": [],
          "size": {
            "lines": 28,
            "bytes": 806
          }
        }
      ],
      "summary": {
        "file_count": 33,
        "class_count": 7,
        "function_count": 95
      }
    },
    "packages": {
      "files": [
        {
          "file": "packages/python-sdk/tests/test_parser.py",
          "path": "packages/python-sdk/tests/test_parser.py",
          "module_docstring": "Test Specifications for JSONL Parser - Sprint 1, F001\nMUST PASS: All message types parse correctly",
          "imports": [
            {
              "module": "pytest",
              "alias": null
            },
            {
              "module": "pathlib",
              "from": true,
              "names": [
                "Path"
              ]
            },
            {
              "module": "typing",
              "from": true,
              "names": [
                "List",
                "Dict",
                "Any"
              ]
            },
            {
              "module": "claude_parser.core.parsers",
              "from": true,
              "names": [
                "JsonlParser",
                "ParseError"
              ]
            }
          ],
          "functions": [],
          "classes": [
            {
              "name": "TestJsonlParser",
              "bases": [],
              "docstring": "F001: JSONL Parser - Foundation Sprint",
              "methods": [
                {
                  "name": "test_parse_empty_file",
                  "signature": "(self)",
                  "docstring": "GIVEN: An empty JSONL file\nWHEN: Parser attempts to parse it\nTHEN: Returns empty list without errors",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 14
                },
                {
                  "name": "test_parse_single_line",
                  "signature": "(self)",
                  "docstring": "GIVEN: JSONL file with one valid JSON line\nWHEN: Parser reads the file\nTHEN: Returns list with one parsed object",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 22
                },
                {
                  "name": "test_parse_multiple_lines",
                  "signature": "(self)",
                  "docstring": "GIVEN: JSONL file with multiple valid lines\nWHEN: Parser reads the file\nTHEN: Returns list with all parsed objects in order",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 30
                },
                {
                  "name": "test_parse_malformed_json",
                  "signature": "(self)",
                  "docstring": "GIVEN: JSONL file with malformed JSON on line 3\nWHEN: Parser encounters the error\nTHEN: Raises ParseError with line number and continues or stops based on mode",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 38
                },
                {
                  "name": "test_parse_message_types",
                  "signature": "(self)",
                  "docstring": "GIVEN: JSONL with all Claude message types (user, assistant, tool, system, summary)\nWHEN: Parser reads the file\nTHEN: Correctly identifies and parses each message type",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 46
                },
                {
                  "name": "test_parse_nested_objects",
                  "signature": "(self)",
                  "docstring": "GIVEN: JSONL with deeply nested JSON objects\nWHEN: Parser reads complex structures\nTHEN: Preserves full object hierarchy",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 62
                },
                {
                  "name": "test_parse_large_file_streaming",
                  "signature": "(self)",
                  "docstring": "GIVEN: Large JSONL file (>100MB)\nWHEN: Parser uses streaming mode\nTHEN: Yields objects without loading entire file into memory",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 70
                },
                {
                  "name": "test_parse_with_unicode",
                  "signature": "(self)",
                  "docstring": "GIVEN: JSONL with unicode characters (emoji, multilingual)\nWHEN: Parser reads the file\nTHEN: Correctly preserves all unicode content",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 78
                },
                {
                  "name": "test_parse_with_escape_sequences",
                  "signature": "(self)",
                  "docstring": "GIVEN: JSONL with escaped characters (\\n, \\t, \\\", etc)\nWHEN: Parser reads the file\nTHEN: Correctly interprets escape sequences",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 86
                },
                {
                  "name": "test_parse_empty_lines",
                  "signature": "(self)",
                  "docstring": "GIVEN: JSONL with empty lines between valid JSON\nWHEN: Parser reads the file\nTHEN: Skips empty lines and continues parsing",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 94
                },
                {
                  "name": "test_parse_with_bom",
                  "signature": "(self)",
                  "docstring": "GIVEN: JSONL file with UTF-8 BOM\nWHEN: Parser reads the file\nTHEN: Correctly handles BOM and parses content",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 102
                },
                {
                  "name": "test_parse_compressed_file",
                  "signature": "(self)",
                  "docstring": "GIVEN: Gzipped JSONL file\nWHEN: Parser detects .gz extension\nTHEN: Automatically decompresses and parses",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 110
                },
                {
                  "name": "test_parse_validation_mode",
                  "signature": "(self)",
                  "docstring": "GIVEN: Parser in strict validation mode\nWHEN: Parsing JSONL with schema violations\nTHEN: Reports all validation errors with line numbers",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 118
                },
                {
                  "name": "test_parse_recovery_mode",
                  "signature": "(self)",
                  "docstring": "GIVEN: Parser in recovery mode\nWHEN: Encounters errors\nTHEN: Logs errors but continues parsing valid lines",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 126
                },
                {
                  "name": "test_parse_performance_benchmark",
                  "signature": "(self)",
                  "docstring": "GIVEN: 10MB JSONL file\nWHEN: Parser reads entire file\nTHEN: Completes in under 1 second",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 134
                }
              ],
              "attributes": [],
              "properties": [],
              "class_variables": [],
              "line_number": 11
            },
            {
              "name": "TestJsonlParserIntegration",
              "bases": [],
              "docstring": "Integration tests for parser with real Claude JSONL files",
              "methods": [
                {
                  "name": "test_parse_real_claude_export",
                  "signature": "(self)",
                  "docstring": "GIVEN: Actual Claude Code JSONL export\nWHEN: Parser processes the file\nTHEN: Extracts all messages, sessions, and metadata correctly",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 146
                },
                {
                  "name": "test_parse_multi_session_file",
                  "signature": "(self)",
                  "docstring": "GIVEN: JSONL with multiple session IDs\nWHEN: Parser processes the file\nTHEN: Correctly groups messages by session",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 154
                },
                {
                  "name": "test_parse_with_tool_sequences",
                  "signature": "(self)",
                  "docstring": "GIVEN: JSONL with tool_use followed by tool_result\nWHEN: Parser processes the sequence\nTHEN: Links tool uses with their results",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 162
                }
              ],
              "attributes": [],
              "properties": [],
              "class_variables": [],
              "line_number": 143
            }
          ],
          "constants": [],
          "size": {
            "lines": 168,
            "bytes": 6080
          }
        },
        {
          "file": "packages/python-sdk/tests/test_models.py",
          "path": "packages/python-sdk/tests/test_models.py",
          "module_docstring": "Test Specifications for Message Models - Sprint 1, F002\nMUST PASS: Type-safe message representation with validation",
          "imports": [
            {
              "module": "pytest",
              "alias": null
            },
            {
              "module": "pendulum",
              "alias": null
            },
            {
              "module": "typing",
              "from": true,
              "names": [
                "Optional",
                "Dict",
                "Any"
              ]
            },
            {
              "module": "claude_parser.core.models",
              "from": true,
              "names": [
                "Message",
                "UserMessage",
                "AssistantMessage",
                "ToolUse",
                "ToolResult",
                "Summary",
                "Session",
                "MessageType",
                "ValidationError"
              ]
            }
          ],
          "functions": [],
          "classes": [
            {
              "name": "TestMessageModels",
              "bases": [],
              "docstring": "F002: Message Models - Foundation Sprint",
              "methods": [
                {
                  "name": "test_user_message_creation",
                  "signature": "(self)",
                  "docstring": "GIVEN: User message data from JSONL\nWHEN: Creating UserMessage model\nTHEN: All fields correctly mapped and accessible",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 17
                },
                {
                  "name": "test_assistant_message_creation",
                  "signature": "(self)",
                  "docstring": "GIVEN: Assistant message data from JSONL\nWHEN: Creating AssistantMessage model\nTHEN: Content and metadata preserved",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 34
                },
                {
                  "name": "test_tool_use_model",
                  "signature": "(self)",
                  "docstring": "GIVEN: Tool use data from JSONL\nWHEN: Creating ToolUse model\nTHEN: Tool name, parameters, and ID accessible",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 50
                },
                {
                  "name": "test_tool_result_model",
                  "signature": "(self)",
                  "docstring": "GIVEN: Tool result data from JSONL\nWHEN: Creating ToolResult model\nTHEN: Result and tool reference preserved",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 69
                },
                {
                  "name": "test_summary_model",
                  "signature": "(self)",
                  "docstring": "GIVEN: Summary message from JSONL\nWHEN: Creating Summary model\nTHEN: Summary text and leaf UUID accessible",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 83
                },
                {
                  "name": "test_message_type_enum",
                  "signature": "(self)",
                  "docstring": "GIVEN: Various message type strings\nWHEN: Converting to MessageType enum\nTHEN: Correct enum values returned",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 96
                },
                {
                  "name": "test_message_validation",
                  "signature": "(self)",
                  "docstring": "GIVEN: Invalid message data (missing required fields)\nWHEN: Creating message model\nTHEN: Raises ValidationError with clear message",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 105
                },
                {
                  "name": "test_message_timestamp_parsing",
                  "signature": "(self)",
                  "docstring": "GIVEN: Various timestamp formats\nWHEN: Parsing timestamps\nTHEN: Correctly converts to datetime objects",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 114
                },
                {
                  "name": "test_message_parent_child_relationship",
                  "signature": "(self)",
                  "docstring": "GIVEN: Messages with parentUuid references\nWHEN: Building message chain\nTHEN: Can traverse parent-child relationships",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 128
                },
                {
                  "name": "test_message_serialization",
                  "signature": "(self)",
                  "docstring": "GIVEN: Message model instances\nWHEN: Serializing to dict/JSON\nTHEN: Produces valid JSONL-compatible output",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 136
                },
                {
                  "name": "test_message_equality",
                  "signature": "(self)",
                  "docstring": "GIVEN: Two message instances with same data\nWHEN: Comparing with == operator\nTHEN: Returns True for equivalent messages",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 144
                },
                {
                  "name": "test_message_hashing",
                  "signature": "(self)",
                  "docstring": "GIVEN: Message instances\nWHEN: Using as dict keys or in sets\nTHEN: Hashing works based on UUID",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 152
                },
                {
                  "name": "test_message_metadata_access",
                  "signature": "(self)",
                  "docstring": "GIVEN: Message with metadata fields\nWHEN: Accessing cwd, gitBranch, version\nTHEN: Returns correct values or None if missing",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 160
                },
                {
                  "name": "test_message_content_types",
                  "signature": "(self)",
                  "docstring": "GIVEN: Messages with different content types (text, code, mixed)\nWHEN: Parsing content field\nTHEN: Preserves formatting and special characters",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 168
                }
              ],
              "attributes": [],
              "properties": [],
              "class_variables": [],
              "line_number": 14
            },
            {
              "name": "TestSessionModel",
              "bases": [],
              "docstring": "F003: Session Model - Foundation Sprint",
              "methods": [
                {
                  "name": "test_session_creation",
                  "signature": "(self)",
                  "docstring": "GIVEN: Session data from JSONL\nWHEN: Creating Session model\nTHEN: Session ID and metadata accessible",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 180
                },
                {
                  "name": "test_session_message_collection",
                  "signature": "(self)",
                  "docstring": "GIVEN: Session with multiple messages\nWHEN: Adding messages to session\nTHEN: Maintains chronological order",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 188
                },
                {
                  "name": "test_session_duration_calculation",
                  "signature": "(self)",
                  "docstring": "GIVEN: Session with start and end timestamps\nWHEN: Calculating duration\nTHEN: Returns correct time delta",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 196
                },
                {
                  "name": "test_session_parent_child_hierarchy",
                  "signature": "(self)",
                  "docstring": "GIVEN: Sessions with parent-child relationships\nWHEN: Building session tree\nTHEN: Can traverse hierarchy correctly",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 204
                },
                {
                  "name": "test_session_statistics",
                  "signature": "(self)",
                  "docstring": "GIVEN: Session with messages and tool uses\nWHEN: Calculating statistics\nTHEN: Returns message count, tool count, error count",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 212
                }
              ],
              "attributes": [],
              "properties": [],
              "class_variables": [],
              "line_number": 177
            }
          ],
          "constants": [],
          "size": {
            "lines": 218,
            "bytes": 7320
          }
        },
        {
          "file": "packages/python-sdk/tests/test_api.py",
          "path": "packages/python-sdk/tests/test_api.py",
          "module_docstring": "Test Specifications for Basic API - Sprint 1, F004\nMUST PASS: Simple one-liner API for 95% use cases",
          "imports": [
            {
              "module": "pytest",
              "alias": null
            },
            {
              "module": "pathlib",
              "from": true,
              "names": [
                "Path"
              ]
            },
            {
              "module": "typing",
              "from": true,
              "names": [
                "List",
                "Dict",
                "Any"
              ]
            },
            {
              "module": "claude_parser",
              "from": true,
              "names": [
                "ClaudeConversation",
                "load",
                "save",
                "iterate",
                "filter",
                "append"
              ]
            }
          ],
          "functions": [],
          "classes": [
            {
              "name": "TestBasicAPI",
              "bases": [],
              "docstring": "F004: Basic API - Foundation Sprint (95% use cases)",
              "methods": [
                {
                  "name": "test_load_conversation",
                  "signature": "(self)",
                  "docstring": "GIVEN: Path to Claude JSONL file\nWHEN: Using load() function\nTHEN: Returns ClaudeConversation object with all data",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 14
                },
                {
                  "name": "test_conversation_messages_property",
                  "signature": "(self)",
                  "docstring": "GIVEN: Loaded conversation\nWHEN: Accessing .messages property\nTHEN: Returns list of all messages in order",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 25
                },
                {
                  "name": "test_conversation_assistant_messages",
                  "signature": "(self)",
                  "docstring": "GIVEN: Loaded conversation with mixed messages\nWHEN: Accessing .assistant_messages\nTHEN: Returns only assistant messages",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 37
                },
                {
                  "name": "test_conversation_user_messages",
                  "signature": "(self)",
                  "docstring": "GIVEN: Loaded conversation with mixed messages\nWHEN: Accessing .user_messages\nTHEN: Returns only user messages",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 48
                },
                {
                  "name": "test_conversation_tool_uses",
                  "signature": "(self)",
                  "docstring": "GIVEN: Conversation with tool interactions\nWHEN: Accessing .tool_uses\nTHEN: Returns all tool use and result pairs",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 59
                },
                {
                  "name": "test_conversation_session_id",
                  "signature": "(self)",
                  "docstring": "GIVEN: Loaded conversation\nWHEN: Accessing .session_id\nTHEN: Returns current session identifier",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 70
                },
                {
                  "name": "test_conversation_current_dir",
                  "signature": "(self)",
                  "docstring": "GIVEN: Conversation with cwd metadata\nWHEN: Accessing .current_dir\nTHEN: Returns working directory path",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 80
                },
                {
                  "name": "test_conversation_git_branch",
                  "signature": "(self)",
                  "docstring": "GIVEN: Conversation with git metadata\nWHEN: Accessing .git_branch\nTHEN: Returns active git branch name",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 90
                },
                {
                  "name": "test_iterate_large_file",
                  "signature": "(self)",
                  "docstring": "GIVEN: Large JSONL file (>100MB)\nWHEN: Using iterate() function\nTHEN: Yields messages without loading entire file",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 100
                },
                {
                  "name": "test_filter_messages",
                  "signature": "(self)",
                  "docstring": "GIVEN: JSONL file with mixed messages\nWHEN: Using filter() with predicate\nTHEN: Returns only matching messages",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 112
                },
                {
                  "name": "test_append_single_message",
                  "signature": "(self)",
                  "docstring": "GIVEN: Existing JSONL file\nWHEN: Using append() to add message\nTHEN: Message added to end of file",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 122
                },
                {
                  "name": "test_save_conversation",
                  "signature": "(self)",
                  "docstring": "GIVEN: Modified conversation object\nWHEN: Using save() function\nTHEN: Writes valid JSONL file",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 131
                },
                {
                  "name": "test_conversation_before_summary",
                  "signature": "(self)",
                  "docstring": "GIVEN: Conversation with summary message\nWHEN: Calling before_summary(limit=20)\nTHEN: Returns last 20 messages before summary",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 142
                },
                {
                  "name": "test_conversation_with_errors",
                  "signature": "(self)",
                  "docstring": "GIVEN: Conversation containing error messages\nWHEN: Calling with_errors()\nTHEN: Returns messages containing errors",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 154
                },
                {
                  "name": "test_conversation_length",
                  "signature": "(self)",
                  "docstring": "GIVEN: Loaded conversation\nWHEN: Using len() on conversation\nTHEN: Returns total message count",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 165
                },
                {
                  "name": "test_conversation_iteration",
                  "signature": "(self)",
                  "docstring": "GIVEN: Loaded conversation\nWHEN: Iterating with for loop\nTHEN: Yields messages in order",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 175
                },
                {
                  "name": "test_conversation_indexing",
                  "signature": "(self)",
                  "docstring": "GIVEN: Loaded conversation\nWHEN: Accessing by index\nTHEN: Returns message at position",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 186
                },
                {
                  "name": "test_empty_file_handling",
                  "signature": "(self)",
                  "docstring": "GIVEN: Empty JSONL file\nWHEN: Loading with API\nTHEN: Returns empty conversation without error",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 198
                },
                {
                  "name": "test_malformed_file_graceful_degradation",
                  "signature": "(self)",
                  "docstring": "GIVEN: JSONL with some malformed lines\nWHEN: Loading in default mode\nTHEN: Skips bad lines, loads valid ones",
                  "decorators": [],
                  "is_async": false,
                  "line_number": 209
                }
              ],
              "attributes": [],
              "properties": [],
              "class_variables": [],
              "line_number": 11
            }
          ],
          "constants": [],
          "size": {
            "lines": 218,
            "bytes": 8041
          }
        }
      ],
      "summary": {
        "file_count": 3,
        "class_count": 5,
        "function_count": 0
      }
    }
  }
}