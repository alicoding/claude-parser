
## Research Query - 2025-08-25 09:16:19

**Query:** Python library for parsing JSON schema validation pydantic marshmallow

**Response:**

For **parsing and validating JSON data against a schema in Python**, the highest-level libraries are **Pydantic**, **Marshmallow**, and **jsonschema** (including the high-performance variant jsonschema-rs). Each library serves slightly different use cases:

- **Pydantic**: Best for data validation and parsing using Python type hints and dataclasses. It is highly integrated with modern Python and is ideal for simple to moderately complex validation tasks[2][4].
- **Marshmallow**: Suited for more complex validation scenarios, custom validation logic, and serialization/deserialization. It uses its own field definitions and validation mechanisms, making it flexible for advanced use cases[2][4].
- **jsonschema/jsonschema-rs**: Directly validates JSON data against a JSON Schema (drafts 4, 6, 7, 2019-09, etc.), following the official specification. jsonschema-rs is a high-performance drop-in replacement for jsonschema[1][3][5].

**Recommended libraries and usage examples:**

| Library         | Use Case                                      | Example Usage                                                                 |
|-----------------|-----------------------------------------------|-------------------------------------------------------------------------------|
| **Pydantic**    | Pythonic data models, type-based validation   | `from pydantic import BaseModel`<br>`class User(BaseModel): ...`              |
| **Marshmallow** | Complex validation, custom serialization      | `from marshmallow import Schema, fields, validate`<br>`class UserSchema(Schema): ...` |
| **jsonschema**  | Strict JSON Schema validation                 | `from jsonschema import validate`<br>`validate(instance=data, schema=schema)`  |
| **jsonschema-rs** | High-performance JSON Schema validation     | `import jsonschema_rs`<br>`jsonschema_rs.validate(schema, instance)`           |

**Example: Pydantic**
```python
from pydantic import BaseModel, Field

class User(BaseModel):
    name: str
    age: int = Field(gt=0)

user = User(name="Alice", age=30)
```
This will raise a validation error if `age` is not greater than 0[2][4].

**Example: Marshmallow**
```python
from marshmallow import Schema, fields, validate

class UserSchema(Schema):
    name = fields.Str(required=True)
    age = fields.Int(required=True, validate=validate.Range(min=0))

data = {"name": "Esteban", "age": -45}
errors = UserSchema().validate(data)
```
This will report an error if `age` is negative[2].

**Example: jsonschema**
```python
from jsonschema import validate

schema = {
    "type": "object",
    "properties": {
        "name": {"type": "string"},
        "age": {"type": "integer", "minimum": 0}
    },
    "required": ["name", "age"]
}

data = {"name": "Alice", "age": 30}
validate(instance=data, schema=schema)
```
This will raise a `ValidationError` if the data does not conform to the schema[3][5].

**Example: jsonschema-rs**
```python
import jsonschema_rs

schema = {"maxLength": 5}
instance = "foo"
jsonschema_rs.validate(schema, instance)
```
This is much faster than the standard jsonschema library and supports multiple drafts[1].

**Summary:**  
- Use **Pydantic** for Pythonic, type-annotated models and simple validation.
- Use **Marshmallow** for advanced validation and custom serialization.
- Use **jsonschema** or **jsonschema-rs** for strict JSON Schema validation, especially if you need to validate against official schema drafts.

If you need to parse a JSON Schema itself (i.e., introspect or manipulate the schema), clarify your requirements, as most libraries focus on validation rather than schema parsing. If you have a specific workflow or integration need, please provide more details for a tailored recommendation.

---
