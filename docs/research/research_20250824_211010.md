
## Research Query - 2025-08-24 21:10:19

**Query:** Python package structure best practices pyproject.toml plugin system configurable

**Response:**

For a modern, **configurable Python package with a plugin system**, best practices are:

- Use the **src/package layout** for your codebase.
- Centralize configuration and build metadata in **pyproject.toml**.
- Implement plugin discovery using established libraries (e.g., **pluggy**).
- Expose configuration options and plugin entry points via **pyproject.toml**.

**Recommended package structure:**

```
my_package_repo/
├── pyproject.toml         # Project metadata, dependencies, plugin config
├── README.md
├── LICENSE
├── CHANGELOG.md
├── docs/
├── src/
│   └── my_package/
│       ├── __init__.py
│       ├── core.py
│       └── plugins/
│           ├── __init__.py
│           └── example_plugin.py
└── tests/
```
This **src/** layout keeps your source code isolated, improves import reliability, and is widely recommended for scientific and general Python projects[1][5].

**pyproject.toml best practices:**

- Define build system and dependencies in `[build-system]` and `[project]` sections[2][4].
- Use `[project.optional-dependencies]` for plugins or extras.
- For plugin systems, leverage entry points (supported by setuptools, Poetry, etc.):

```toml
[project.entry-points."my_package.plugins"]
example_plugin = "my_package.plugins.example_plugin:PluginClass"
```
This allows dynamic plugin discovery and registration, making your package extensible and configurable[2][4].

**Plugin system implementation:**

- Use a library like **pluggy** (used by pytest) for plugin management, avoiding custom code.
- Plugins register themselves via entry points in **pyproject.toml**.
- Your main package loads plugins using pluggy’s API, reading entry points from the configuration.

**Configurability:**

- Store user-facing configuration in **pyproject.toml** or a dedicated config file.
- Use libraries like **pydantic** for config validation (not manual checks).

**Summary of best practices:**

- **src/** layout for code isolation[1].
- Centralized, declarative config in **pyproject.toml**[2][4].
- Plugin system via entry points and a library like pluggy.
- Minimal custom code—prefer high-level libraries for plugin and config management.

If you need concrete examples for pluggy integration or pyproject.toml entry point configuration, please specify your plugin system requirements (e.g., plugin API, config options, discovery mechanism).

---
