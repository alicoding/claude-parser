
## Research Query - 2025-08-24 23:54:29

**Query:** LlamaIndex built-in caching refresh policies automatic reindexing file change detection incremental updates

**Response:**

Could you please provide more details about what you're trying to achieve? For example, are you asking about:

• How to use LlamaIndex’s built‐in caching refresh policies for automatic reindexing when files change?  
• How LlamaIndex detects file changes to perform incremental updates?  

Knowing more about your use case, file types, and version of LlamaIndex (or specific integration details) would help me give a precise answer. Feel free to share file paths, configuration details, or error messages if any.

Sources:  
• https://docs.cloud.llamaindex.ai/llamaparse/features/cache_options  
• https://zilliz.com/ai-faq/does-llamaindex-support-incremental-indexing-for-realtime-data  
• https://milvus.io/ai-quick-reference/how-do-i-handle-document-updates-in-llamaindex

---

## Research Query - 2025-08-24 23:54:48

**Query:** LlamaIndex RefreshIndex IngestionPipeline document management incremental indexing upsert update changed files

**Response:**

LlamaIndex supports **incremental indexing and document management** through its `refresh_ref_docs` method, which allows you to update only changed or new documents in an index without a full rebuild[2][3][5]. However, automatic detection of changed files and removal of deleted documents requires additional handling.

**Key capabilities and workflow:**

- **Incremental Updates & Upserts:**  
  Use `refresh_ref_docs(documents)` to refresh the index with documents that have changed (same `doc_id` but different content) or to insert new documents not previously indexed[2][3][5].  
  This method saves compute by only updating documents with changes in text or metadata, and returns a list of booleans indicating which documents were refreshed[2][3].

- **Document Deletion:**  
  `refresh_ref_docs` does **not** remove nodes for documents that have been deleted from your source files[1].  
  You must manually identify deleted files and call `delete_ref_doc(doc_id, delete_from_docstore=True)` to remove them from the index[1].

- **File Change Detection:**  
  LlamaIndex does **not** natively watch the filesystem for changes.  
  You need to implement your own logic to detect changed, new, or deleted files (e.g., by scanning file paths and comparing to indexed doc IDs)[1].

- **Metadata-based Refresh:**  
  You can refresh documents based on metadata (such as user ID or version) by passing documents with updated metadata to `refresh_ref_docs`[5].  
  For versioning, include a `version` field in document metadata and filter queries accordingly[4].

**Example workflow:**

```python
from llama_index.core import VectorStoreIndex, SimpleDirectoryReader

# Load documents and assign unique doc_id (e.g., file path)
documents = SimpleDirectoryReader(input_dir="data", filename_as_id=True).load_data()

# Refresh index with changed/new documents
refreshed = index.refresh_ref_docs(documents)

# Remove deleted documents
doc_ids = [doc.get_doc_id() for doc in documents]
for path in index.docstore.get_all_ref_doc_info():
    if path not in doc_ids:
        index.delete_ref_doc(path, delete_from_docstore=True)
```
[1][3]

**IngestionPipeline Integration:**  
You can use an IngestionPipeline to preprocess documents before indexing, but incremental updates and refreshes are managed at the index level using the above methods.

**Summary Table:**

| Feature                | Built-in Support | Manual Steps Required |
|------------------------|------------------|----------------------|
| Incremental indexing   | Yes (`refresh_ref_docs`) | No                 |
| Upsert/update          | Yes              | No                   |
| Detect changed files   | No               | Yes                  |
| Remove deleted files   | No               | Yes                  |
| Metadata/versioning    | Yes              | No                   |

**Best Practices:**
- Assign stable, unique `doc_id` (e.g., file path) to each document for reliable updates and deletions[1][3].
- Implement your own file change detection logic to trigger refreshes and deletions.
- Use metadata for versioning and filtering during queries[4][5].

If you need code examples for a specific pipeline or integration, please provide more details about your file structure, update triggers, or desired automation level.

---
