
## Research Query - 2025-08-24 21:10:50

**Query:** Python CLI best practices typer click rich argparse configuration

**Response:**

For building robust Python CLIs, best practices are to use high-level libraries like **Typer** or **Click** for most use cases, avoid manual argparse unless you need minimal dependencies, and leverage **Rich** for advanced output formatting. Configuration should be handled declaratively, and CLI logic should be separated from core library code for maintainability.

**Key Best Practices:**

- **Library Choice:**  
  - Use **Typer** (built on Click) for modern, type-annotated, auto-documented CLIs.
  - Use **Click** for complex, multi-command CLIs needing composability, prompts, and testing support[4].
  - Use **argparse** only for simple scripts or when avoiding external dependencies[2][3][4].
  - Use **Rich** for beautiful output, tables, and progress bars—integrates well with Typer and Click.

- **Project Structure:**  
  - Keep CLI code separate from core library logic.  
  - For reusable libraries, consider a separate CLI package that depends on the core library[5].

- **User Experience:**  
  - Always provide clear help messages (`--help`), descriptions, and argument validation[3].
  - Use type checking and restrict choices for arguments where possible[3].
  - Handle errors gracefully with meaningful messages and exit codes[1].

- **Configuration:**  
  - Prefer declarative configuration (e.g., via config files or environment variables) over hardcoding.
  - Use libraries like **pydantic** for config validation (not manual checks).

- **Testing:**  
  - Use Click’s `CliRunner` or Typer’s test utilities for CLI testing[4].

**Comparison Table: Typer vs Click vs argparse**

| Feature                | Typer           | Click           | argparse         |
|------------------------|-----------------|-----------------|------------------|
| Type annotations       | Yes             | No              | No               |
| Auto help/docs         | Yes             | Yes             | Yes              |
| Nested commands        | Yes             | Yes             | Yes (manual)     |
| Output formatting      | Rich integration| Rich integration| Manual           |
| Standard library       | No              | No              | Yes              |
| Best for               | Modern CLIs     | Complex CLIs    | Simple scripts   |

**Example: Typer with Rich Output**

```python
import typer
from rich import print

app = typer.Typer()

@app.command()
def greet(name: str, greet: str = "Hello"):
    print(f"[bold green]{greet}, {name}![/bold green]")

if __name__ == "__main__":
    app()
```

**Summary Recommendations:**
- Use **Typer** for new projects unless you have a strong reason to use Click directly.
- Use **Rich** for output formatting.
- Avoid manual argparse unless you need zero dependencies.
- Keep CLI and library code separate for maintainability and testability[5][1][4].

If you need concrete examples or have a specific use case (e.g., config file handling, multi-command CLI, packaging), please provide more details for tailored guidance.

---
