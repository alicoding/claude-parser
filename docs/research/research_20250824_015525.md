
## Research Query - 2025-08-24 01:55:35

**Query:** python AST abstract syntax tree code analysis transformation library

**Response:**

For **Python code analysis and transformation using abstract syntax trees (AST)**, the highest-level, most capable libraries are:

- **astToolkit**: A modern, composable, type-safe toolkit for AST manipulation, analysis, transformation, and code generation. It provides a layered API for matching, transforming, and generating Python code, making complex transformations concise and robust[4].
- **LibCST**: A concrete syntax tree library that allows parsing, modifying, and re-generating Python code with full fidelity, including comments and formatting[3].
- **ast (standard library)**: The built-in Python module for parsing, analyzing, and transforming Python code at the AST level. It is lower-level and more manual than the above libraries[2][5].

Hereâ€™s a comparison of the top options:

| Library      | Level         | Transformation | Code Generation | Comments/Formatting | Type Safety | Example Use Case |
|--------------|--------------|---------------|-----------------|--------------------|-------------|------------------|
| **astToolkit** | High         | Yes           | Yes             | Yes                | Yes         | Change all multiplications to additions in code[4] |
| **LibCST**     | High         | Yes           | Yes             | Yes                | Yes         | Refactor code while preserving formatting[3] |
| **ast**        | Standard lib | Yes (manual)  | Yes (manual)    | No                 | No          | Basic AST analysis and transformation[2][5] |

**Recommended: astToolkit or LibCST** for most code analysis/transformation tasks, as they provide high-level, declarative APIs and preserve code formatting.

### Example: Using astToolkit for AST Transformation

```python
from astToolkit import Be, IfThis, Make, NodeChanger, Then
import ast

code = """
def double(x):
    return x * 2
"""

tree = ast.parse(code)

# Find multiplication nodes and replace with addition
find_mult = Be.Mult
change_to_add = Then.replaceWith(ast.Add())
NodeChanger(find_mult, change_to_add).visit(tree)

print(ast.unparse(tree))  # Output: def double(x): return x + x
```
[4]

### Example: Using LibCST for Code Transformation

LibCST provides a similar high-level API and preserves formatting and comments.

### When to use each:

- **astToolkit**: For type-safe, composable, and layered AST transformations and code generation[4].
- **LibCST**: When you need to preserve formatting, comments, and want a robust, modern API[3].
- **ast**: For simple, low-level AST analysis or when you want zero dependencies[2][5].

If you have a specific transformation or analysis task, please provide more details (e.g., code sample, desired transformation), and I can show the exact usage with the best library.

---
