{
  "thread_id": "20250824_131609",
  "model": "sonar-pro",
  "created": "2025-08-24T13:17:07.939964-04:00",
  "messages": [
    {
      "role": "system",
      "content": "You are a research assistant for a codebase with STRICT quality standards.\n\n🚨 MANDATORY: ALL SOLUTIONS MUST FOLLOW docs/LIBRARY_FIRST_RULE.md\n- LIBRARY FIRST OR DIE: 95% library code, 5% glue\n- Every line of custom code is a failure to find the right library\n- Real failures: 634 lines for 25-line TTL problem, 2,553 lines for 200-line memory project\n\nCRITICAL: You MUST ask for full context before providing answers\n- If the user's query lacks specific details, ASK for more information\n- If you're unsure about the exact problem, ASK for clarification\n- If file paths or error messages would help, REQUEST them\n- NEVER hallucinate or guess - always work with concrete information\n\nMANDATORY WORKFLOW (per LIBRARY_FIRST_RULE.md):\n1. Task: \"Build X functionality\"\n2. STOP: \"What library does X?\"\n3. Search: Find the highest-level library that does X\n4. Found? Recommend it with examples. END.\n5. Not found? Provide evidence (PyPI, GitHub, Stack Overflow links)\n\nFORBIDDEN (violations = instant failure per LIBRARY_FIRST_RULE.md):\n- json (must use orjson)\n- datetime (must use pendulum)\n- requests/urllib (must use httpx)\n- logging (must use loguru)\n- argparse (must use typer/click)\n- while True loops (must use apscheduler)\n- Manual retry logic (must use tenacity)\n- Manual batch processing (must use more-itertools)\n- Any manual async/await/threading code\n- Any library requiring manual resource management\n\nAPPROVED LIBRARIES (use these first):\n- Scheduling: apscheduler (NOT while True)\n- Events: blinker (NOT if/elif chains)\n- Retry: tenacity (NOT try/except loops)\n- Batch: more-itertools (NOT manual chunking)\n- Dates: pendulum (NOT datetime parsing)\n- Async Tasks: arq, celery (NOT asyncio.create_task)\n- CLI: typer (NOT argparse)\n- Validation: pydantic (NOT manual checks)\n- HTTP: httpx (NOT urllib)\n- Testing: pytest (NOT unittest)\n\nWhen researching:\n- Find the HIGHEST-LEVEL library that solves the problem\n- Prefer libraries that handle complexity internally\n- Look for declarative/functional approaches over imperative\n- Choose libraries with simple APIs (1-3 function calls for 95% of use cases)\n\nSuccess metrics:\n✅ Success: 95% library code, 5% glue\n❌ Failure: 95% custom code, 5% libraries\n\nREMEMBER: Someone already solved your problem - FIND THEIR LIBRARY."
    },
    {
      "role": "user",
      "content": "Temporal workflow communication patterns between workflows signals queries activities child workflows"
    },
    {
      "role": "assistant",
      "content": "Temporal supports several communication patterns between workflows, signals, queries, activities, and child workflows, each with distinct semantics and best practices.\n\n**Key communication patterns:**\n\n- **Signals:** Asynchronous, one-way messages sent to a workflow to modify its state or trigger behavior. Signals can be sent from clients or other workflows (as \"external signals\") and are processed in the order received. Signals do not return data to the sender[1][3][4].\n- **Queries:** Synchronous, read-only requests to a workflow to retrieve its current state. Queries cannot modify workflow state and are handled immediately when the workflow is running[1].\n- **Activities:** External, potentially long-running tasks invoked by workflows. Activities are the primary way workflows interact with the outside world (e.g., microservices, databases)[5].\n- **Child Workflows:** Workflows can start other workflows as children, enabling hierarchical orchestration. Parent workflows can track child workflow completion and handle their results or failures[5].\n\n**Workflow-to-Workflow Communication:**\n\n| Pattern                | Directionality | Synchronous? | Returns Data? | Use Case                                 |\n|------------------------|---------------|--------------|---------------|------------------------------------------|\n| Signal                 | One-way       | No           | No            | Notify or update workflow state          |\n| Query                  | One-way       | Yes          | Yes           | Read workflow state                      |\n| Activity Invocation    | One-way       | No           | Yes           | Call external service/task               |\n| Child Workflow         | One-way       | No           | Yes           | Orchestrate sub-processes                |\n| External Signal        | One-way       | No           | No            | Workflow-to-workflow notification        |\n\n**Important details and patterns:**\n\n- **Signal Delivery Guarantees:** Signals are delivered at-least-once, but only to workflows that exist and are open. If you signal a child workflow immediately after starting it, you must ensure the child is created before sending the signal. A common pattern is to force a new workflow task (e.g., with a timer) after starting children, then send signals[2].\n- **Message Handler Concurrency:** Temporal workflows process messages (signals, updates) in the order received, but handlers can interleave with the main workflow logic. Handlers should be reentrant and workflows should initialize state before processing messages to avoid race conditions[1].\n- **External Signals:** Workflows can signal other workflows using getExternalWorkflowHandle (TypeScript/Go), ensuring deterministic execution and proper event recording[3].\n- **Queries:** Queries are strictly read-only and cannot mutate workflow state. They are useful for exposing workflow state to clients without affecting execution[1].\n- **Child Workflow Coordination:** Parent workflows can start child workflows and wait for their completion. To ensure signals are sent only after child workflows are running, use workflow task sequencing or timers as described above[2].\n\n**Best practices:**\n\n- Use **signals** for asynchronous, fire-and-forget communication.\n- Use **queries** for synchronous, read-only state inspection.\n- Use **activities** for external side effects.\n- Use **child workflows** for modular, hierarchical orchestration.\n- Carefully manage the sequencing of signals to newly started child workflows to avoid race conditions[2].\n\nIf you need concrete code examples or have a specific scenario (e.g., signaling between parent and child workflows, or integrating with microservices), please provide more details about your use case, language/SDK, and any error messages or workflow definitions."
    },
    {
      "role": "user",
      "content": "Temporal Python SDK workflow signal between workflows external workflow handle send signal from one workflow to another"
    },
    {
      "role": "assistant",
      "content": "To send a **signal from one workflow to another** using the Temporal Python SDK, you must use an **external workflow handle**. This allows a workflow to communicate asynchronously with another running workflow by sending a signal to it[3].\n\n**Workflow-to-Workflow Signal Pattern (Python SDK):**\n\n1. **Get an external workflow handle** for the target workflow execution.\n2. **Send a signal** using the handle.\n\n**Example:**\n\nSuppose you have a signal handler defined in your target workflow:\n\n```python\nfrom temporalio import workflow\n\n@workflow.defn\nclass TargetWorkflow:\n    @workflow.signal\n    async def my_signal(self, data:"
    },
    {
      "role": "user",
      "content": "show complete Python code example external workflow handle signal another workflow"
    },
    {
      "role": "assistant",
      "content": "Here is a **complete Python code example** showing how one Temporal workflow can signal another workflow using an external workflow handle, following Temporal Python SDK best practices[1][3]:\n\n```python\nfrom typing import Optional\nfrom temporalio import workflow\n\n# Target workflow that will receive the signal\n@workflow.defn\nclass WorkflowA:\n    def __init__(self) -> None:\n        self._signal: Optional[str] = None\n\n    @workflow.run\n    async def run(self) -> str:\n        # Wait until the signal is received\n        await workflow.wait_condition(lambda: self._signal is not None)\n        return self._signal\n\n    @workflow.signal\n    def your_signal(self, value: str) -> None:\n        # Signal handler: store the value\n        self._signal = value\n\n# Workflow that sends a signal to WorkflowA\n@workflow.defn\nclass WorkflowB:\n    @workflow.run\n    async def run(self) -> None:\n        # Get an external workflow handle for WorkflowA with id \"workflow-a\"\n        handle = workflow.get_external_workflow_handle_for(WorkflowA.run, \"workflow-a\")\n        # Send the signal to WorkflowA\n        await handle.signal(WorkflowA.your_signal, \"signal argument\")\n```\n\n**Key points:**\n- `get_external_workflow_handle_for` is used to obtain a handle to another workflow by its type and workflow ID.\n- `await handle.signal(WorkflowA.your_signal, \"signal argument\")` sends the signal to the target workflow.\n- The signal handler (`your_signal`) in `WorkflowA` updates the workflow's state, which can be awaited or acted upon[1][3].\n\nThis pattern is the recommended way to send signals between workflows in the Temporal Python SDK. If you need to use an untyped handle (when you don't know the workflow type), use `get_external_workflow_handle` instead[1]."
    }
  ]
}