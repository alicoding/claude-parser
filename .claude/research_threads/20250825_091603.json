{
  "thread_id": "20250825_091603",
  "model": "sonar-pro",
  "created": "2025-08-25T09:16:19.323776-04:00",
  "messages": [
    {
      "role": "system",
      "content": "You are a research assistant for a codebase with STRICT quality standards.\n\nüö® MANDATORY: ALL SOLUTIONS MUST FOLLOW docs/LIBRARY_FIRST_RULE.md\n- LIBRARY FIRST OR DIE: 95% library code, 5% glue\n- Every line of custom code is a failure to find the right library\n- Real failures: 634 lines for 25-line TTL problem, 2,553 lines for 200-line memory project\n\nCRITICAL: You MUST ask for full context before providing answers\n- If the user's query lacks specific details, ASK for more information\n- If you're unsure about the exact problem, ASK for clarification\n- If file paths or error messages would help, REQUEST them\n- NEVER hallucinate or guess - always work with concrete information\n\nMANDATORY WORKFLOW (per LIBRARY_FIRST_RULE.md):\n1. Task: \"Build X functionality\"\n2. STOP: \"What library does X?\"\n3. Search: Find the highest-level library that does X\n4. Found? Recommend it with examples. END.\n5. Not found? Provide evidence (PyPI, GitHub, Stack Overflow links)\n\nFORBIDDEN (violations = instant failure per LIBRARY_FIRST_RULE.md):\n- json (must use orjson)\n- datetime (must use pendulum)\n- requests/urllib (must use httpx)\n- logging (must use loguru)\n- argparse (must use typer/click)\n- while True loops (must use apscheduler)\n- Manual retry logic (must use tenacity)\n- Manual batch processing (must use more-itertools)\n- Any manual async/await/threading code\n- Any library requiring manual resource management\n\nAPPROVED LIBRARIES (use these first):\n- Scheduling: apscheduler (NOT while True)\n- Events: blinker (NOT if/elif chains)\n- Retry: tenacity (NOT try/except loops)\n- Batch: more-itertools (NOT manual chunking)\n- Dates: pendulum (NOT datetime parsing)\n- Async Tasks: arq, celery (NOT asyncio.create_task)\n- CLI: typer (NOT argparse)\n- Validation: pydantic (NOT manual checks)\n- HTTP: httpx (NOT urllib)\n- Testing: pytest (NOT unittest)\n\nWhen researching:\n- Find the HIGHEST-LEVEL library that solves the problem\n- Prefer libraries that handle complexity internally\n- Look for declarative/functional approaches over imperative\n- Choose libraries with simple APIs (1-3 function calls for 95% of use cases)\n\nSuccess metrics:\n‚úÖ Success: 95% library code, 5% glue\n‚ùå Failure: 95% custom code, 5% libraries\n\nREMEMBER: Someone already solved your problem - FIND THEIR LIBRARY."
    },
    {
      "role": "user",
      "content": "Python library for parsing JSON schema validation pydantic marshmallow"
    },
    {
      "role": "assistant",
      "content": "For **parsing and validating JSON data against a schema in Python**, the highest-level libraries are **Pydantic**, **Marshmallow**, and **jsonschema** (including the high-performance variant jsonschema-rs). Each library serves slightly different use cases:\n\n- **Pydantic**: Best for data validation and parsing using Python type hints and dataclasses. It is highly integrated with modern Python and is ideal for simple to moderately complex validation tasks[2][4].\n- **Marshmallow**: Suited for more complex validation scenarios, custom validation logic, and serialization/deserialization. It uses its own field definitions and validation mechanisms, making it flexible for advanced use cases[2][4].\n- **jsonschema/jsonschema-rs**: Directly validates JSON data against a JSON Schema (drafts 4, 6, 7, 2019-09, etc.), following the official specification. jsonschema-rs is a high-performance drop-in replacement for jsonschema[1][3][5].\n\n**Recommended libraries and usage examples:**\n\n| Library         | Use Case                                      | Example Usage                                                                 |\n|-----------------|-----------------------------------------------|-------------------------------------------------------------------------------|\n| **Pydantic**    | Pythonic data models, type-based validation   | `from pydantic import BaseModel`<br>`class User(BaseModel): ...`              |\n| **Marshmallow** | Complex validation, custom serialization      | `from marshmallow import Schema, fields, validate`<br>`class UserSchema(Schema): ...` |\n| **jsonschema**  | Strict JSON Schema validation                 | `from jsonschema import validate`<br>`validate(instance=data, schema=schema)`  |\n| **jsonschema-rs** | High-performance JSON Schema validation     | `import jsonschema_rs`<br>`jsonschema_rs.validate(schema, instance)`           |\n\n**Example: Pydantic**\n```python\nfrom pydantic import BaseModel, Field\n\nclass User(BaseModel):\n    name: str\n    age: int = Field(gt=0)\n\nuser = User(name=\"Alice\", age=30)\n```\nThis will raise a validation error if `age` is not greater than 0[2][4].\n\n**Example: Marshmallow**\n```python\nfrom marshmallow import Schema, fields, validate\n\nclass UserSchema(Schema):\n    name = fields.Str(required=True)\n    age = fields.Int(required=True, validate=validate.Range(min=0))\n\ndata = {\"name\": \"Esteban\", \"age\": -45}\nerrors = UserSchema().validate(data)\n```\nThis will report an error if `age` is negative[2].\n\n**Example: jsonschema**\n```python\nfrom jsonschema import validate\n\nschema = {\n    \"type\": \"object\",\n    \"properties\": {\n        \"name\": {\"type\": \"string\"},\n        \"age\": {\"type\": \"integer\", \"minimum\": 0}\n    },\n    \"required\": [\"name\", \"age\"]\n}\n\ndata = {\"name\": \"Alice\", \"age\": 30}\nvalidate(instance=data, schema=schema)\n```\nThis will raise a `ValidationError` if the data does not conform to the schema[3][5].\n\n**Example: jsonschema-rs**\n```python\nimport jsonschema_rs\n\nschema = {\"maxLength\": 5}\ninstance = \"foo\"\njsonschema_rs.validate(schema, instance)\n```\nThis is much faster than the standard jsonschema library and supports multiple drafts[1].\n\n**Summary:**  \n- Use **Pydantic** for Pythonic, type-annotated models and simple validation.\n- Use **Marshmallow** for advanced validation and custom serialization.\n- Use **jsonschema** or **jsonschema-rs** for strict JSON Schema validation, especially if you need to validate against official schema drafts.\n\nIf you need to parse a JSON Schema itself (i.e., introspect or manipulate the schema), clarify your requirements, as most libraries focus on validation rather than schema parsing. If you have a specific workflow or integration need, please provide more details for a tailored recommendation."
    }
  ]
}