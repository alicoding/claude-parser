{
  "thread_id": "20250824_163518",
  "model": "sonar-pro",
  "created": "2025-08-24T16:35:33.766069-04:00",
  "messages": [
    {
      "role": "system",
      "content": "You are a research assistant for a codebase with STRICT quality standards.\n\nüö® MANDATORY: ALL SOLUTIONS MUST FOLLOW docs/LIBRARY_FIRST_RULE.md\n- LIBRARY FIRST OR DIE: 95% library code, 5% glue\n- Every line of custom code is a failure to find the right library\n- Real failures: 634 lines for 25-line TTL problem, 2,553 lines for 200-line memory project\n\nCRITICAL: You MUST ask for full context before providing answers\n- If the user's query lacks specific details, ASK for more information\n- If you're unsure about the exact problem, ASK for clarification\n- If file paths or error messages would help, REQUEST them\n- NEVER hallucinate or guess - always work with concrete information\n\nMANDATORY WORKFLOW (per LIBRARY_FIRST_RULE.md):\n1. Task: \"Build X functionality\"\n2. STOP: \"What library does X?\"\n3. Search: Find the highest-level library that does X\n4. Found? Recommend it with examples. END.\n5. Not found? Provide evidence (PyPI, GitHub, Stack Overflow links)\n\nFORBIDDEN (violations = instant failure per LIBRARY_FIRST_RULE.md):\n- json (must use orjson)\n- datetime (must use pendulum)\n- requests/urllib (must use httpx)\n- logging (must use loguru)\n- argparse (must use typer/click)\n- while True loops (must use apscheduler)\n- Manual retry logic (must use tenacity)\n- Manual batch processing (must use more-itertools)\n- Any manual async/await/threading code\n- Any library requiring manual resource management\n\nAPPROVED LIBRARIES (use these first):\n- Scheduling: apscheduler (NOT while True)\n- Events: blinker (NOT if/elif chains)\n- Retry: tenacity (NOT try/except loops)\n- Batch: more-itertools (NOT manual chunking)\n- Dates: pendulum (NOT datetime parsing)\n- Async Tasks: arq, celery (NOT asyncio.create_task)\n- CLI: typer (NOT argparse)\n- Validation: pydantic (NOT manual checks)\n- HTTP: httpx (NOT urllib)\n- Testing: pytest (NOT unittest)\n\nWhen researching:\n- Find the HIGHEST-LEVEL library that solves the problem\n- Prefer libraries that handle complexity internally\n- Look for declarative/functional approaches over imperative\n- Choose libraries with simple APIs (1-3 function calls for 95% of use cases)\n\nSuccess metrics:\n‚úÖ Success: 95% library code, 5% glue\n‚ùå Failure: 95% custom code, 5% libraries\n\nREMEMBER: Someone already solved your problem - FIND THEIR LIBRARY."
    },
    {
      "role": "user",
      "content": "Python pre-commit hooks to enforce coding standards forbidden imports file size limits best practices"
    },
    {
      "role": "assistant",
      "content": "To enforce **coding standards, forbidden imports, and file size limits** in Python using pre-commit hooks, you should use the highest-level, library-based solutions available, as required by your strict library-first policy.\n\n**Best-practice workflow:**\n\n1. **Use pre-commit** as the framework to manage all hooks[3][1].\n2. **Leverage existing, specialized hooks** for each requirement‚Äîavoid custom scripts unless absolutely necessary.\n\n---\n\n### 1. Enforcing Coding Standards\n\n- **Linting:** Use the official Flake8 or pylint pre-commit hooks.\n- **Formatting:** Use Black or isort hooks for code formatting.\n\n**Example (.pre-commit-config.yaml):**\n```yaml\nrepos:\n  - repo: https://github.com/pre-commit/mirrors-flake8\n    rev: v6.0.0\n    hooks:\n      - id: flake8\n\n  - repo: https://github.com/psf/black\n    rev: 24.3.0\n    hooks:\n      - id: black\n```\nThese hooks will automatically enforce PEP8 and code formatting on every commit[1][5].\n\n---\n\n### 2. Forbidding Imports\n\n- **Use the prebuilt forbid-check hook** from pre-commit-hooks, which blocks commits containing forbidden imports.\n\n**Example (.pre-commit-config.yaml):**\n```yaml\nrepos:\n  - repo: https://github.com/pre-commit/pre-commit-hooks\n    rev: v4.5.0\n    hooks:\n      - id: forbid-check\n        args: [--pattern, '^import\\s+(json|datetime|requests|argparse|logging|urllib|asyncio|threading)$']\n        files: \\.py$\n```\n- Adjust the regex in `--pattern` to match your forbidden imports list (e.g., json, datetime, requests, etc.)[3].\n\n---\n\n### 3. Enforcing File Size Limits\n\n- **Use the check-added-large-files hook** from pre-commit-hooks to block large files.\n\n**Example (.pre-commit-config.yaml):**\n```yaml\nrepos:\n  - repo: https://github.com/pre-commit/pre-commit-hooks\n    rev: v4.5.0\n    hooks:\n      - id: check-added-large-files\n        args: ['--maxkb=100']\n```\nThis will prevent files larger than 100KB from being committed[4].\n\n---\n\n### 4. General Best Practices\n\n- **Always use prebuilt hooks from the pre-commit ecosystem**‚Äînever write custom scripts unless no library exists[1][3].\n- **Pin hook versions** for reproducibility.\n- **Document your .pre-commit-config.yaml** so contributors understand enforced standards.\n- **Run pre-commit install** after cloning to activate hooks locally[4].\n- **Use pre-commit.ci** for server-side enforcement[1].\n\n---\n\n**Summary Table**\n\n| Requirement         | Library Hook (pre-commit)                        | Example Hook ID                |\n|---------------------|--------------------------------------------------|-------------------------------|\n| Coding Standards    | mirrors-flake8, psf/black                        | flake8, black                 |\n| Forbidden Imports   | pre-commit-hooks/forbid-check                    | forbid-check                  |\n| File Size Limits    | pre-commit-hooks/check-added-large-files         | check-added-large-files       |\n\n---\n\n**Do not write custom code** for these checks‚Äîuse the official hooks and configure them as shown above. If you need to enforce additional rules not covered by existing hooks, provide evidence that no such hook exists before proceeding with custom scripts, per your library-first mandate."
    }
  ]
}